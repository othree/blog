<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>O3noBLOG - web</title>
<link>https://blog.othree.net//log/ web/</link>
<description></description>
<copyright>Copyright 2017</copyright>
<lastBuildDate>2017-06-07 00:09</lastBuildDate>
<generator>http://www.movabletype.org/?v=4.381</generator>
<docs>http://blogs.law.harvard.edu/tech/rss</docs> 


<item>
<title>a11y</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/34944175192/" title="Pa11y Dashboard by othree, on Flickr"><img src="https://farm5.staticflickr.com/4251/34944175192_71a6475ca3_b.jpg" width="1024" height="595" alt="Pa11y Dashboard, " srcset="https://farm5.staticflickr.com/4251/34944175192_71a6475ca3_b.jpg 1024w, https://farm5.staticflickr.com/4251/34944175192_32efc09322_h.jpg 1600w" /></a></p>
<p>標題的 a11y 其實是 accessibility （親和力）的縮寫，現在英文世界似乎很大量的使用這個簡稱，今年的 JSConf EU 前陣子放出演講錄影，其中有一場是在講網路親和力的議題「YES, your site too can (and should) be accessible.」：</p>
<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/H4FzW9oFObs?rel=0&amp;showinfo=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
<p>講者是 Laura Carvajal，在 <a href="https://ft.com">Financial Times</a> 工作，而這場演講就是他們改進 ft.com 網站親和力的過程和一些想法，我覺得精華在後半，前面是介紹自動化工具 <a href="http://pa11y.org/">Pa11y</a>，a11y 是 accessibility，至於首字母的 <strong>P</strong>，看 README 應該是 pal 的意思；他們把這個自動化工具整合進他們的開發流程，然後慢慢的修改，直到把回報的問題都修完，其實現在自動化工具已經很強了，連顏色對比度夠不夠都能算出來（瀏覽器的開發工具以後也會有相關資訊），不過要驗證親和力做的如何，還是有很大量的驗證其實是需要手動測試。</p>
<p>手動測試的部分他們是請了 <a href="http://digitalaccessibilitycentre.org/">DAC</a> (Digital Accessibility Centre) 來做，演講中還有一些測試者的測試影片，每位測試者都會先說他身體有怎樣的障礙，然後他邊測試會邊口述他在做什麼，遇到怎樣的問題，建議可以怎麼處理，感覺就是很專業的測試員。總之，在他們處理完所有 Pa11y 檢測到的問題後，才請 DAC 做親和力評估驗證，結果還是收到了一份兩百多頁的測試報告，回報了各種 ft.com 網站上的親和力問題，之後又花了幾個月的時間來處理這些問題，最後終於得到 DAC 的<a href="http://digitalaccessibilitycentre.org/index.php/financial-times">認證</a>，這份認證資訊還蠻完整的，還說明了他們認證時網站的狀況，還有哪些問題待解決，甚至連可能會使用到但是還沒處理過親和力問題的同組織的網站（服務）都有列出來，另外在 ft.com 的<a href="https://www.ft.com/accessibility">親和力聲明</a>也可以看到 DAC 的認證。</p>
<p>接著 Laura Carvajal 介紹到如何實際體會（參與）這些親和力問題，其中一個很經典的狀態就是只用鍵盤做所有的控制，他提供了一些強迫自己只能用鍵盤操控的方法，並且在這種狀態下工作，其它還有像是使用 Mac 的 VoiceOver 做為 ScreenReader、使用 Windows 的高對比模式等等，他建議可以實際自己去體驗看看的，甚至強迫自己使用一陣子，會對這些問題更有體會，除此之外，他還透過一些活動來讓其他公司內的人也來參與，像是模擬一個障礙者會面臨的環境，以他的例子來說是把網頁模糊化，模擬視力障礙的使用者狀態，然後在這個狀態下請人去完成一些任務，像是填一個表單，並且有提供些獎勵增加參與人數，記得他們是提供 Amazon Credit，這樣可以讓更多人體會到需要依靠輔具來上網的不便，長久下來也可以讓這些工作的推動更加順利。</p>
<p>這幾天我也試著裝起了 <a href="https://github.com/pa11y/dashboard">Pa11y Dashboard</a> 開始做些檢測，看到的 Error 加上 Warning 數量真是有點驚人，再來慢慢處理吧...</p>
]]></description>
<link>https://blog.othree.net/log/2017/06/07/a11y/</link>
<guid>https://blog.othree.net/log/2017/06/07/a11y/</guid>
<category>web</category>
<pubDate>2017-06-07 00:09</pubDate>
</item>

<item>
<title>Telegram Instant View</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/34366696420/" title="Telegram Instant View by othree, on Flickr"><img src="https://farm5.staticflickr.com/4194/34366696420_ced4830286_b.jpg" width="1024" height="592" alt="Telegram Instant View, " srcset="https://farm5.staticflickr.com/4194/34366696420_ced4830286_b.jpg 1024w, https://farm5.staticflickr.com/4194/34366696420_83f48bbf29_h.jpg 1600w" /></a></p>
<p>Telegram 前幾天發佈了 4.0，有幾個比較大的功能，包括了 <a href="https://telegram.org/blog/video-messages-and-telescope">Video Message</a>、<a href="https://telegram.org/blog/payments">Payment for Bots</a> 還有就是 <a href="https://telegram.org/blog/instant-view">Instant View</a> 準備要<a href="https://telegram.org/blog/instant-view-contest-200K">開放給所有網頁使用</a>了，Instant View 目的和 Facebook 的 Instant Article 以及 Google 的 AMP 一樣，都是為了提升使用者體驗，讓使用者能夠快的看到文章的內容，不過之前沒有開放，所以一直不知道背後的運作原理是怎樣，直到這次 4.0 發佈才得以一窺其原理，和 Instant Article 與 AMP 不一樣，不再是提供另一個新的版本，而是透過一種新的 template 語言來協助 Telegram service 把自己的網頁內容轉譯成 Instant Article 的內容（Instant View page object），不完全算是程式語言，裡面比較像是一些定義，加上用 <a href="https://zh.wikipedia.org/zh-tw/XPath">XPath</a> 來做文件內容的選取，蠻意外會用 XPath 的，還好我對 XPath 有點經驗，就花了一點時間研究了一下，也把自己 blog 的 tempalte 基本版做出來了：</p>
<pre><code>?exists:  //article/div[@id=&quot;comments&quot;]

author:  &quot;othree&quot;
channel: &quot;@othree&quot;

body:     //article
title:    $body//h3[1]

cover: $body/section[@itemprop=&quot;articleBody&quot;]/p[1]/a[@itemprop=&quot;image&quot;]/img

published_date: $body/header/time[@itemprop=&quot;datePublished dateModified&quot;]/@datetime

@remove: //article/header
@remove: //article/footer
@remove: //article/div[@id=&quot;comments&quot;]
@remove: //noscript
@remove: //a[has-class(&quot;dsq-brlink&quot;)]
</code></pre>
<p>語法還算蠻好理解的，官方也提供了幾個有完整註解的<a href="https://instantview.telegram.org/samples/">範例</a>，仔細一看似乎之前其實也只有 medium 是非官方有支援的網站，也因為這個實做方式，對不同的網站就要有不同的 template 來處理，所以官方辦了個競賽，搶先替<a href="https://instantview.telegram.org/contest">清單上的網站</a>做出可用的 template 就會有獎金，目前個人網站雖然已經可以在官方的 editor 做 template、驗證並發測試連結，不過還要等 domain 被加進白名單後才會真的啟用，目前這個關卡還沒開放就是。</p>
<p>其實我是比較喜歡這種實做方式的，不用為了增加支援一個新的網路服務就多做一個版本，不會影響原本的網頁原始碼，不會讓  <code>&lt;head&gt;</code> 越來越肥大，當然缺點就是網站改版，HTML 結構有變化的話就要跟著修改 template，不過我是認為這個實做方法對於網路生態是比較好一些的。</p>
]]></description>
<link>https://blog.othree.net/log/2017/05/21/telegram-instant-view/</link>
<guid>https://blog.othree.net/log/2017/05/21/telegram-instant-view/</guid>
<category>web</category>
<pubDate>2017-05-21 23:45</pubDate>
</item>

<item>
<title>MovableType and CommonMark</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/33655820694/" title="Typora by othree, on Flickr"><img src="https://farm5.staticflickr.com/4175/33655820694_e30f901655_b.jpg" width="650" height="622" alt="Typora" srcset="https://farm5.staticflickr.com/4175/33655820694_e30f901655_b.jpg 1024w" /></a></p>
<p>我這邊用的 blog 系統是 <a href="https://www.movabletype.org/">MovableType</a> 不是新聞了，然後也因為用 MovableType 我一直都只能用最初版的 markdown 引擎，沒錯，就是 Daring Fireball 作者 John Gruber 的<a href="http://daringfireball.net/projects/markdown/">那一版</a>，這個版本其實已經可以滿足我大部分的需求了，不過當我想要用 <a href="https://typora.io/">Typora</a> 寫文章的時候，就遇到問題了，Typora 在輸出成 Markdown 文件時，code block 只支援三個 ``` 包起來的 <a href="http://spec.commonmark.org/0.27/#fenced-code-block">Fenced Code Block</a>，而不支援 <a href="http://spec.commonmark.org/0.27/#indented-code-block">Indented Code Block</a>，剛好初版的 Markdown 格式只有 Indented Code Block，兩者其實要比的話，我是比較喜歡 Indented Code Block 的，比較符合 Markdown 的 sense，不過用 Fenced Code Block 有個優點是可以指定程式碼的語言，也因此才能夠有 syntax highlight 的效果。</p>
<p>總之，因為這個原因，用 Typora 寫技術文章對我來說就很不方便，一直以來都有想解決這個問題，前兩天還去 Typora 發 issue 說希望他們可以支援 Indented Code Block，結果發完沒多久，躺在床上快要睡覺的時候突然想到，CommonMark 這麼多語言有實做，搞不好有 Perl 的啊，結果快速搜尋了一下，還真的有一個 <a href="https://github.com/nwellnhof/perl-commonmark">perl-commonmark</a>，橋接 Perl 和 <a href="https://github.com/jgm/cmark">cmark</a>，也有發佈到 CPAN 上，當下心裡就盤算著，隔天起來要來把它接到 MovableType 去看看。</p>
<p>結果隔天實做起來是沒花我太多時間，雖然對 Perl 不熟，但是可以直接拿初版 Markdown.pl 來修改，原本的 Markdown.pl 這個檔案裡面實際上自己是一個 Markdown 的 Perl Package，同時也可以作為 MovableType 的 plugin script，我只需要把 plugin script 的部分留下，然後把最後做轉換的 function 換掉就好了，當然系統要裝好 cmark 和 Perl 的 CommonMark，cmark 應該很多環境都有了，我在 archlinux 上是直接用 pacman 裝：</p>
<pre><code class="language-bash">pacman -S cmark
</code></pre>
<p>然後 CommonMark 是用 CPAN 裝，本來要用 cpanminus 的不知道為何用它會抓不到 package：</p>
<pre><code class="language-bash">sudo CPAN CommonMark
</code></pre>
<p>我的 nginx 跑 CGI 時用的 perl 不是系統預設位置的，所以 CPAN 執行檔的路徑我是特別指定給他的，這樣 MovableType 執行的時候才找的到 CommonMark Module，實際上沒花多少功夫，我就把 MovableType 和 CommonMark 串起來了，當下心情真的是非常難以言喻，一來是這個問題其實存在已經許久了，二是我竟然把第一個支援 Markdown 的部落格系統接上 2017 年最新的 CommonMark 實做，雖然現在應該是也幫不到什麼人了。不過沒高興多久，就發現在 UTF-8 字元似乎有些狀況，有中文的文章會爛掉，或是 Dashboard 那頁的文字會變亂碼，後來為了這個問題又弄了好幾個小時，推測問題應該是因為 cmark 那邊回來的字串已經失去編碼的 metadata，所以在做 summary 切文字的時候，就會出現切錯地方的狀況，花了很多時間交叉比對和測試，最後的結果只是用 Perl 的 Encoding 把 cmark 傳回來的字串重新 encode 過而已，其實很簡單。除此之外，我其實還有試著想接看看 <a href="https://github.com/github/cmark">cmark-gfm</a>，因為它還多支援了 Table，不過幾次測試都不太順利，就沒繼續嘗試下去了。</p>
<p>目前的成果放在 GitHub 上，取名叫 <a href="https://github.com/othree/MT-CommonMark">MT-CommonMark</a>，附上簡單的安裝說明，暫時是沒打算發去 movabletype.org 那邊。</p>
<p>做好之後 MT-CommonMark 之後，我就開始在部落格上測試程式碼的 syntax highlight了，研究一陣子之後選擇的是 <a href="http://prismjs.com/">prismjs</a>，選擇它的原因很多，不過有兩個是比較主要的：</p>
<ul>
<li>作者有 <a href="http://lea.verou.me/">Lea Verou</a></li>
<li>支援的 class name 格式剛好和 cmark 輸出的一樣</li>
</ul>
<p>結果兩者也很順利的搭配起來，中間就沒有再遇到什麼問題了。</p>
]]></description>
<link>https://blog.othree.net/log/2017/05/07/movabletype-and-commonmark/</link>
<guid>https://blog.othree.net/log/2017/05/07/movabletype-and-commonmark/</guid>
<category>web</category>
<pubDate>2017-05-07 09:47</pubDate>
</item>

<item>
<title>GitHub Flavored Markdown 標準規範</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15576500626/" title="Github Markdown Cheat Sheet by othree, on Flickr"><img src="https://farm6.staticflickr.com/5599/15576500626_b56732d883_b.jpg" width="1024" height="683" alt="Github Markdown Cheat Sheet" srcset="https://farm6.staticflickr.com/5599/15576500626_b56732d883_b.jpg 1024w, https://farm6.staticflickr.com/5599/15576500626_e0027ae0fb_h.jpg 1600w" /></a></p>
<p>前陣子看到 DK <a href="https://blog.gslin.org/archives/2017/03/16/7187/">提到</a> GitHub 的 Markdown：<a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown">GitHub Flavored Markdown</a> <a href="https://githubengineering.com/a-formal-spec-for-github-markdown/">發表正式的 spec</a> 了，當時有大概看了一下內容，不過昨天才有空寫出來（然後今天也看到碼天狗有提到這件事），基本上這份 <a href="https://github.github.com/gfm/">spec</a> 是基於 <a href="http://commonmark.org/">CommonMark</a> 的，只是多了一些語法，包括：</p>
<ul>
<li>刪除線</li>
<li>表格</li>
<li><a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments">待辦清單</a></li>
<li>自動連結（包括網址和 email）</li>
<li>Raw HTML 黑名單：
<ul>
<li><code>&lt;title&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li><code>&lt;style&gt;</code></li>
<li><code>&lt;xmp&gt;</code></li>
<li><code>&lt;iframe&gt;</code></li>
<li><code>&lt;noembed&gt;</code></li>
<li><code>&lt;noframes&gt;</code></li>
<li><code>&lt;script&gt;</code></li>
<li><code>&lt;plaintext&gt;</code></li>
</ul>
</li>
</ul>
<p>新增的部分都有很顯眼的標註，其中 Raw HTML 黑名單的 HTML 標籤的 <code>&lt;</code> 都會被轉成 entity，基本上看起來是安全性考量，不過不太確定為何有些很老的標籤出現，感覺上和安全性比較沒關係。另外我還注意到 <a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/#using-emoji">emoji</a>和<a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/#referencing-issues-and-pull-requests">reference link</a>沒包含在這份 spec 內，emoji 或許是因為實做上的問題，轉成 unicode 字元相容性不好，要用 img 會有不少相依性問題，而 reference link 大概是因這是比較針對 GitHub 網站的特性。</p>
<p>GitHub 轉換 Markdown 引擎的過程也有在文中說明，這次 Markdown 引擎是從 <a href="https://github.com/vmg/sundown">Sundown</a>（更早是 Ruby 實做的 <a href="https://github.com/vmg/redcarpet">redcarpet</a> 的樣子）改成 <a href="https://github.com/jgm/cmark">cmark</a>，當然為了這些新語法，他們 fork 了<a href="https://github.com/github/cmark">自己的版本出來</a>，然後在真的套上 GitHub 本站前，有先做過測試，結果發現有 1% 的文件（所有的 Markdown 文件，包括 user comment、issue...etc）會受到影響，而且判斷方法不是單純 diff 輸出結果，而是 diff 正規化過的 HTML 文件樹，不過即使只有 1% 的文件，那也是很大量，後來他們又更仔細分析，發現會受影響的幾乎都是 issue、user comment 之類的內容，是存放在 GitHub 資料庫內的，而不是 repository 內的文件，所以他們可以直接修改，如果是 repository 內的文件，因為要看 sha1 hash，所以是改不了的，後來他們魔改 Sundown，讓它吃舊文件然後吐出符合新 spec 的 Markdown 文件，接著跑了幾天把全部需要修改的舊文件（1%）都轉完，所以現在除了少數文件外，剩下的文件都是符合 GFM spec 的文件了。</p>
]]></description>
<link>https://blog.othree.net/log/2017/03/27/github-flavored-markdown/</link>
<guid>https://blog.othree.net/log/2017/03/27/github-flavored-markdown/</guid>
<category>web</category>
<pubDate>2017-03-27 20:41</pubDate>
</item>

<item>
<title>GitHub 提供專案授權簡介與概要</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/32722736844/" title="Do What The F*ck You Want To Public License by othree, on Flickr"><img src="https://farm3.staticflickr.com/2898/32722736844_c977dc8ff8_b.jpg" width="1024" height="595" alt="Do What The F*ck You Want To Public License, " srcset="https://farm3.staticflickr.com/2898/32722736844_c977dc8ff8_b.jpg 1024w, https://farm3.staticflickr.com/2898/32722736844_e56ae26374_h.jpg 1600w" /></a></p>
<p>大概上週看到有人在 Twitter 講到 GitHub 現在會在專案上顯示該專案所使用授權條款的摘要，長的像是上面那樣，官方也有發表<a href="https://github.com/blog/2335-open-source-license-descriptions-and-metadata">公告</a>，其實這個修改是結合之前的<a href="https://github.com/blog/2252-license-now-displayed-on-repository-overview">授權偵測</a>和 <a href="https://choosealicense.com/">Choose a License</a>。</p>
<p>Choose a License 也是一個 GitHub 的附加服務，用來協助使用者挑選適合的授權條款，現在在 GitHub 建立新的專案時，可以順便初始化專案，包括建立 README、產生 <code>.gitignore</code> 和挑選要使用的授權條款：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/33495590202/" title="Initialize Project by othree, on Flickr"><img src="https://farm4.staticflickr.com/3953/33495590202_f04d677f58_b.jpg" width="722" height="141" alt="Initialize Project" srcset="https://farm4.staticflickr.com/3953/33495590202_f04d677f58_b.jpg 1024w" /></a></p>
<p>授權條款旁邊的 i 點下去其實就會送到 Choose a License 網站去了（不過兩邊沒有連動接起來就是），Choose a License 網站則針對每種條款都一份重點摘要，分為 Permissions、Conditions 和 Limitations 三個區塊，分別條列出該條款可以做什麼（例如商業使用）、有什麼條件（例如需要也使用相同條款授權）和條款的限制（例如免責），而現在 GitHub 上顯示的條款摘要其實就是這邊的資訊搬過來的：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/33495653292/" title="Choose a License by othree, on Flickr"><img src="https://farm4.staticflickr.com/3770/33495653292_b2822ac569_b.jpg" width="1024" height="601" alt="Choose a License" srcset="https://farm4.staticflickr.com/3770/33495653292_b2822ac569_b.jpg 1024w, https://farm4.staticflickr.com/3770/33495653292_0a6bd0bf6e_h.jpg 1600w" /></a></p>
<p>Choose a License 網站其實有很多授權條款的整理，而不是只有常見的幾種，可以看 <a href="https://choosealicense.com/appendix/">appendix</a> 頁面有完整清單，可惜裡面沒有 <a href="https://github.com/vim/vim/blob/master/runtime/doc/uganda.txt">Vim License</a>，另外特別想說的是 GitHub 自己（應該沒錯）提供的 <a href="https://choosealicense.com/licenses/unlicense/">Unlincense</a>，相似於創作領域的 <a href="http://creativecommons.tw/cc0">CC0</a>，就類似丟到 Public Domain 的意思，不過保留了免責條款，講到免責聲明，就還要順便提一下 <a href="https://choosealicense.com/licenses/wtfpl/">WTFPL</a>，它其實也是超自由的 License，差別就是連免責聲明都沒，其實是更加接近丟到 Public Domain 吧？</p>
<p>最後想說的是 GitHub 用來判斷專案使用的授權，用的是 <a href="https://github.com/benbalter/licensee">licensee</a> 這個 Ruby Gem，看起來完全就是為了做這些事情寫的，我看好像也沒其他類似功能的專案，作者 Ben Balter 其實也是 GitHub 員工。</p>
]]></description>
<link>https://blog.othree.net/log/2017/03/26/github-license-summary/</link>
<guid>https://blog.othree.net/log/2017/03/26/github-license-summary/</guid>
<category>web</category>
<pubDate>2017-03-26 20:16</pubDate>
</item>

<item>
<title>Guetzli: A New Open Source JPEG Encoder</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/33444227946/" title="Guetzli by othree, on Flickr"><img src="https://farm4.staticflickr.com/3665/33444227946_858cf890f3_b.jpg" width="773" height="699" alt="Guetzli" srcset="" /></a></p>
<p>今天一早起來就看到 Google <a href="https://research.googleblog.com/2017/03/announcing-guetzli-new-open-source-jpeg.html">發表</a>的新的 JPEG 壓縮程式，叫 Guetzli（一種瑞士餅乾），這是 Google 繼 <a href="https://github.com/google/zopfli">Zopfli</a>、<a href="https://github.com/google/brotli">Brotli</a> 之後，算是第三個比較容易被大家廣為使用的新的節省網路流量的工具，這次主要針對 JPEG 圖片格式，和之前 Mozilla 的 <a href="https://github.com/mozilla/mozjpeg">mozjpeg</a> 的作法一樣，保持目前 JPEG decoder 的相容性，然後看能加強 JPEG 圖檔到什麼程度，我稍微測試了一下，結果還不錯，目前還沒有 homebrew formula，如果要自己 build 的可以參考<a href="https://agileblaze.com/google-guetzli-image-compression-setup-on-macos/">這篇</a>，基本上就是用 bazel 來編譯，然後可能會需要先裝 libpng 和 gflags，這兩個可以用 homebrew 安裝：</p>
<pre><code class="language-bash">brew install libpng gflags 
</code></pre>
<p>然後裝 <a href="https://bazel.build/">bazel</a></p>
<pre><code class="language-bash">brew install bazel
</code></pre>
<p>然後到專案目錄下執行編譯指令：</p>
<pre><code class="language-bash">bazel build -c opt //:guetzli
</code></pre>
<p>結果就會把執行檔放到 <code>bazel-bin/guetzli</code> 這位置，就可以拿來用了，不過其實官方 GitHub repo 上的 <a href="https://github.com/google/guetzli/releases">release</a> 那邊就有編譯好的版本，抓下來用 Terminal 執行 <code>chmod +x</code> 也可以用（我是自己丟到 <code>/usr/local/bin/</code> 裡面），指令很簡單，可以加上 <code>--quality</code>，預設是 95，不過最小只能 84，設更小的值會跟你說，真的想要的話自己去改原始碼...</p>
<p>速度就如大家所說的，和其它工具比起來真的慢很多，感覺是有一些 recursive 找最佳解的過程，輸出的結果我覺得最讓人印象深刻的是對於純色色塊的處理，也比 mozjpeg 好上不少，輸出檔案的大小不一定會是最小的，不過品質好很多，差異是達到我可以放棄這點容量差距，而寧願要這畫質改進，然後就是 Quality 100 可能會體積暴漲，我隨便測試了幾張圖片，看起來設到 90 品質就蠻不錯的，看來目前通行的圖片最佳化工具又要有一輪更新了。</p>
]]></description>
<link>https://blog.othree.net/log/2017/03/17/guetzli-new-os-jpeg-encoder/</link>
<guid>https://blog.othree.net/log/2017/03/17/guetzli-new-os-jpeg-encoder/</guid>
<category>web</category>
<pubDate>2017-03-17 12:57</pubDate>
</item>

<item>
<title>網路發佈資料之最佳實踐</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/32951614622/" title="Data on the Web Best Practices by othree, on Flickr"><img src="https://farm3.staticflickr.com/2901/32951614622_395e8d1b32_b.jpg" width="1024" height="576" alt="Data on the Web Best Practices" srcset="https://farm3.staticflickr.com/2901/32951614622_395e8d1b32_b.jpg 1024w" /></a></p>
<p>前幾天 W3C 發佈了這份文件 <a href="https://www.w3.org/TR/dwbp/">Data on the Web Best Practices</a> （DWBP），內容是關於在網路上發佈資料時的最佳實踐（公開或非公開的都適用），讓我想到了之前的 g0v summit 羅佩琪分享提到的一個重點，開放是有成本的，當時演講的影片：</p>
<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/aIuHcEmKZ2I" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
<p>稍微看過這份文件後，覺得之前確實蠻缺乏這份整理好的文件，每點看了就都覺得，確實是應該要這樣的，不過沒有這種整理好的 checklist 其實真的要做的時候還蠻容易漏東漏西的，然後就是，每一點都是成本啊！！</p>
<p>整份文件還蠻有翻譯的價值的，比較不像是 HTML Spec 會常常更新，不過我自然沒這麼多時間可以翻譯，所以就先把重點標題翻起來放，以後有人要開始就先有個基礎了，DWBP 整份文件有 35 點 Best Practice，每一點都有標題、簡述、原因、預期結果、可能實做方法、如何測試、證據、好處、範例等內容，其中好處的部分是分成八種：</p>
<ul>
<li>Comprehension，人類容易理解理解</li>
<li>Processability，可程式自動處理</li>
<li>Discoverability，可讓程式自動發現</li>
<li>Reuse，容易重複使用</li>
<li>Trust，可靠</li>
<li>Linkability，可連結</li>
<li>Access，容易存取</li>
<li>Interoperability，容易互動（發佈者和使用者之間）</li>
</ul>
<p>我只翻譯了其中的標題和簡述，順便附上每一點的好處（上面的八種好處），以下就是這 35 點 Best Practice：</p>
]]><![CDATA[<ul>
<li>Metadata<br />
詮釋資料
<ul>
<li>Provide metadata<br />
提供詮釋資料(metadata)<br />
Provide metadata for both human users and computer applications.<br />
提供可讓人類閱讀和程式可處理的詮釋資料<br />
優點：R, C, D, P</li>
<li>Provide descriptive metadata<br />
提供資料介紹的詮釋資料<br />
Provide metadata that describes the overall features of datasets and distributions.<br />
提供介紹資料集整體特性和發佈資訊的詮釋資料<br />
優點：R, C, D</li>
<li>Provide structural metadata<br />
提供資料結構的詮釋資料<br />
Provide metadata that describes the schema and internal structure of a distribution.<br />
每次發佈都提供資料綱要(schema)和資料結構的詮釋資料<br />
優點：R, C, P</li>
</ul>
</li>
<li>Data Licenses<br />
資料授權
<ul>
<li>Provide data license information<br />
提供資料授權的資訊<br />
Provide a link to or copy of the license agreement that controls use of the data.<br />
提供鏈節到資料所使用授權的協議文件<br />
優點：R, T</li>
</ul>
</li>
<li>Data Provenance<br />
資料發佈者
<ul>
<li>Provide data provenance information<br />
提供資料發佈者的訊息<br />
Provide complete information about the origins of the data and any changes you have made.<br />
提供完整的資料發佈者的訊息以及所有的修改紀錄<br />
優點：R, C, T</li>
</ul>
</li>
<li>Data Quality<br />
資料品質
<ul>
<li>Provide data quality information<br />
提供資料品質資訊<br />
Provide information about data quality and fitness for particular purposes.<br />
提供資料針對特定用途的品質和適應性資訊<br />
優點：R, T</li>
</ul>
</li>
<li>Data Versioning<br />
資料版本
<ul>
<li>Provide a version indicator<br />
提供明確版本號<br />
Assign and indicate a version number or date for each dataset.<br />
提供每個資料集的明確版本號或是發佈日期<br />
優點：R, T</li>
<li>Provide version history<br />
提供版本歷史<br />
Provide a complete version history that explains the changes made in each version.<br />
提供完整的版本歷史，說明每個版本的變動<br />
優點：R, T</li>
</ul>
</li>
<li>Data Identifiers<br />
資料識別符
<ul>
<li>Use persistent URIs as identifiers of datasets<br />
使用固定的 URI 作為資料集的識別符(identifier)<br />
Identify each dataset by a carefully chosen, persistent URI.<br />
為每個資料集都謹慎的挑選一個永久固定的 URI 作為識別用<br />
優點：R, L, D, I</li>
<li>Use persistent URIs as identifiers within datasets<br />
在資料集之間使用 URI 做為連結的識別符<br />
Reuse other people's URIs as identifiers within datasets where possible.<br />
連結其它資料集時，盡可能使用其它資料集既存的 URI 作為資料集之間連結的識別符<br />
優點：R, L, D, I</li>
<li>Assign URIs to dataset versions and series<br />
提供特定版本和最新版本的的識別用 URI<br />
Assign URIs to individual versions of datasets as well as to the overall series.<br />
每個版本都提供一個獨立的識別用 URI，整個系列的資料也要提供一個特定的識別 URI<br />
優點：R, D, T</li>
</ul>
</li>
<li>Data Formats<br />
資料格式
<ul>
<li>Use machine-readable standardized data formats<br />
使用程式可處理的標準格式<br />
Make data available in a machine-readable, standardized data format that is well suited to its intended or potential use.<br />
提供程式可處理的標準資料格式，並且是適合資料預期及潛在應用的格式<br />
優點：R, P</li>
<li>Use locale-neutral data representations<br />
使用非地區性的資料表現形式<br />
Use locale-neutral data structures and values, or, where that is not possible, provide metadata about the locale used by data values.<br />
使用非地區性的資料結構和形式，否則需提供所使用資料形式的詮釋資料<br />
優點：R, C</li>
<li>Provide data in multiple formats<br />
提供多種格式<br />
Make data available in multiple formats when more than one format suits its intended or potential use.<br />
如果資料預期及潛在的應用有不只一種適合的格式，則都提供<br />
優點：R, P</li>
</ul>
</li>
<li>Data Vocabularies<br />
資料詞彙
<ul>
<li>Reuse vocabularies, preferably standardized ones<br />
盡量重複使用詞彙，並優先使用標準有定義的詞彙<br />
Use terms from shared vocabularies, preferably standardized ones, to encode data and metadata.<br />
在資料本體和詮釋資料中，盡量使用已經有人使用的詞彙，並優先使用標準有定義的詞彙<br />
優點：R, P, C, T, I</li>
<li>Choose the right formalization level<br />
選擇正確的數據尺度<br />
Opt for a level of formal semantics that fits both data and the most likely applications.<br />
為資料挑選一個適當的尺度，以符合資料本身的意義和它最可能的應用<br />
優點：R, C, I</li>
</ul>
</li>
<li>Data Access<br />
資料取得
<ul>
<li>Provide bulk download<br />
提供打包下載<br />
Enable consumers to retrieve the full dataset with a single request.<br />
讓使用者可以只用一個請求就取得全部的資料集<br />
優點：R, A</li>
<li>Provide Subsets for Large Datasets<br />
大資料集要單獨提供子集<br />
If your dataset is large, enable users and applications to readily work with useful subsets of your data.<br />
如果你的資料集很大，讓使用者可以針對他的應用只下載一部分的子集<br />
優點：R, L, A, P</li>
<li>Use content negotiation for serving data available in multiple formats<br />
使用內容協商機制來決定提供的資料格式<br />
Use content negotiation in addition to file extensions for serving data available in multiple formats.<br />
除了副檔名之外，還可以使用 HTTP 的內容協商機制來決定提供的資料格式<br />
優點：R, A</li>
<li>Provide real-time access<br />
提供及時的存取<br />
When data is produced in real time, make it available on the Web in real time or near real-time.<br />
如果資料是即時產生的，也提供可以取得即時資料的方法<br />
優點：R, A</li>
<li>Provide data up to date<br />
提供最新版的資料<br />
Make data available in an up-to-date manner, and make the update frequency explicit.<br />
總是提供到最新版本的資料，並且固定更新的頻率<br />
優點：R, A</li>
<li>Provide an explanation for data that is not available<br />
無法提供的資料要說明原因<br />
For data that is not available, provide an explanation about how the data can be accessed and who can access it.<br />
針對無法直接提供的資料，說明如何取得及誰可以取得<br />
優點：R, T</li>
<li>Make data available through an API<br />
讓資料可以透過 API 取得<br />
Offer an API to serve data if you have the resources to do so.<br />
如果有足夠的資源，提供 API 服務來供應資料<br />
優點：R, P, I, A</li>
<li>Use Web Standards as the foundation of APIs<br />
使用網路標準作為 API 的基礎<br />
When designing APIs, use an architectural style that is founded on the technologies of the Web itself.<br />
設計 API 服務時，使用網路基礎的技術作為架構核心<br />
優點：R, L, I, D, A, P</li>
<li>Provide complete documentation for your API<br />
提供完整的 API 文件<br />
Provide complete information on the Web about your API. Update documentation as you add features or make changes.<br />
在網路上提供完整的 API 文件，並且在 API 有更新時即時更新文件<br />
優點：R, T</li>
<li>Avoid Breaking Changes to Your API<br />
避免 API 有不向前相容的變動<br />
Avoid changes to your API that break client code, and communicate any changes in your API to your developers when evolution happens.<br />
避免重大的 API 更新造成應用端程式錯誤，更改 API 時都要跟開發人員溝通<br />
優點：T, I</li>
</ul>
</li>
<li>Data Preservation<br />
資料保存
<ul>
<li>Preserve identifiers<br />
保留識別符<br />
When removing data from the Web, preserve the identifier and provide information about the archived resource.<br />
當從網路上移除資料時，保留該資料的識別符，並且提供該資料歸檔保存的資訊<br />
優點：R, T</li>
<li>Assess dataset coverage<br />
評估資料集覆蓋率<br />
Assess the coverage of a dataset prior to its preservation.<br />
評估資料集的覆蓋率來做為歸檔保存時的參考<br />
優點：R, T</li>
</ul>
</li>
<li>Feedback<br />
回饋
<ul>
<li>Gather feedback from data consumers<br />
從資料使用者收集回饋意見<br />
Provide a readily discoverable means for consumers to offer feedback.<br />
提供一個容易發現的方式讓使用者提供意見回饋<br />
優點：R, C, T</li>
<li>Make feedback available<br />
公開回饋意見<br />
Make consumer feedback about datasets and distributions publicly available.<br />
公開使用者對資料集和發佈方式的回饋意見<br />
優點：R, T</li>
</ul>
</li>
<li>Data Enrichment<br />
加強資料
<ul>
<li>Enrich data by generating new data<br />
增加新資料來加強現有資料集<br />
Enrich your data by generating new data when doing so will enhance its value.<br />
當新資料可以提升資料集的價值時，就著手產生新資料<br />
優點：R, C, T, P</li>
<li>Provide Complementary Presentations<br />
提供補充的內容來展示資料<br />
Enrich data by presenting it in complementary, immediately informative ways, such as visualizations, tables, Web applications, or summaries.<br />
提供資料的各種用例，像是視覺化呈現、表格、網路應用程式或是摘要等來讓資料更多元<br />
優點：R, C, A, T</li>
</ul>
</li>
<li>Republication<br />
再散佈
<ul>
<li>Provide Feedback to the Original Publisher<br />
提供回饋意見給原發佈者<br />
Let the original publisher know when you are reusing their data. If you find an error or have suggestions or compliments, let them know.<br />
讓資料的原發佈者資料你有再利用他的資料，如果有發現任何錯誤或可以改進的地方，也讓他知道<br />
優點：R, I, T</li>
<li>Follow Licensing Terms<br />
遵照授權條款<br />
Find and follow the licensing requirements from the original publisher of the dataset.<br />
確認原始發佈資料集的授權條款，並遵守之<br />
優點：R, T</li>
<li>Cite the Original Publication<br />
標註原發佈者<br />
Acknowledge the source of your data in metadata. If you provide a user interface, include the citation visibly in the interface.<br />
在詮釋資料內標註資料來源，如果有建立使用者介面，也要在上面顯示資料來源<br />
優點：R, D, T</li>
</ul>
</li>
</ul>
<p>翻譯可能有問題，Patch Welcome。最後附上一些翻譯時參考的資料：</p>
<ul>
<li><a href="https://w3c-html-ig-zh.github.io/w3c-glossary/">https://w3c-html-ig-zh.github.io/w3c-glossary/</a></li>
<li><a href="http://terms.naer.edu.tw/">http://terms.naer.edu.tw/</a></li>
<li><a href="http://www.lac.org.tw/law/documents/02/06231.pdf">http://www.lac.org.tw/law/documents/02/06231.pdf</a></li>
</ul>
]]></description>
<link>https://blog.othree.net/log/2017/03/01/data-on-web-best-practice/</link>
<guid>https://blog.othree.net/log/2017/03/01/data-on-web-best-practice/</guid>
<category>web</category>
<pubDate>2017-03-01 00:02</pubDate>
</item>

<item>
<title>Safari 10 for Developer</title>
<description><![CDATA[<p>Safari 10 跟著 macOS 一起出來了，這次更新了不少東西（對於網頁開發者來說），Apple 也依舊放了一份<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html">文件</a>在他們的 Developer Library 裡面，以下列出我覺得比較有趣的：</p>

<h4>CSP 2.0</h4>

<p>CSP 2.0 和之前的版本相比，最主要是多了非常多可以控制的權限，也有幾個名稱有改掉，不過基本上格式是相容的。</p>

<h4>Shadow DOM</h4>

<p>Shadow DOM 1.0 標準，這也讓 Web Component 的理想又往前賣進一步了。</p>

<h4>ES 6</h4>

<p>號稱支援度 100%，看起來是依據 <a href="http://kangax.github.io/compat-table/es6/#safari10">ECMAScript compatable table</a> 的，不過在 module 的面前，還沒有真的 100% 的啊，另外主流瀏覽器其實支援度都蠻高了，之前 Edge 還放話說領先的，沒想到現在就已經被 Safari 10 和 Chrome 超過了，而 Chrome 看來也之差 tail call 而已，接下來應該又要開始效能比拼了吧。</p>

<h4>Inline and Auto Video Playback in iOS</h4>

<p>這也是等很久的功能，之前就有先開放靜音影片能直接在 iOS Safari 上自動播放，主要的考量是，gif 和 mp4 相比，還是 gif 比較吃資源啊。</p>

<h4>ES Internationalization</h4>

<p>ECMA-402 支援，這也是希望快點普及的東西啊，不然數字、日期什麼的搞本地化實在很麻煩。</p>

<h4>WOFF 2.0 Support</h4>

<p>令人意外的有點慢，不過還算很有誠意的把很新的 <a href="https://drafts.csswg.org/css-font-loading/">CSS Font Loading Module Level 3</a> 的 API 做好了。</p>

<h4>#RRGGBBAA</h4>

<p>新的 CSS color 格式，也是前陣子才 propose 出來而已，這樣以後就可以讓 CSS 裡的顏色格式統一點了。</p>

<h4>Right-to-Left Language Support</h4>

<p>主要是 RTL 頁面 scrollbar 的位置終於會換邊了。</p>

<h4>Media Query for Wide Color Gamut Support</h4>

<p>廣色域的 CSS media query，主要是因為最新的 iMac 和 iPhone 7 都有支援 P3 色域了。</p>

<h4>WebDriver Support</h4>

<p>主流瀏覽器最後一個支援的...</p>

<h4>Apple Pay for the Web</h4>

<p>這真的蠻兇狠的，不過 Google 也有在 Android 做類似的<a href="https://android.googleblog.com/2016/09/tap-pay-yes-android-pay-welcomes-chase.html">事</a>就是了。</p>

<p>大概就這些了，其實也列出超過一半的項目了，Safari 這種更新頻率其實比起其它幾家來說吃虧不少，不過還是一直有跟上最新進度，其實也蠻厲害的，更何況現在 Google 都把人拉到 Blink 去，有回到 Webkit 的貢獻似乎比例上不高。</p>
]]>
</description>
<link>https://blog.othree.net/log/2016/09/21/safari-10/</link>
<guid>https://blog.othree.net/log/2016/09/21/safari-10/</guid>
<category>web</category>
<pubDate>2016-09-21 23:57</pubDate>
</item>

<item>
<title>7 Bit Encoding and Email</title>
<description><![CDATA[<p>最近工作上比較常接觸到 email 的東西，然後比較認真的看了 HTML email 信件的內容，以前我以為都要用 base64 編碼來處理，可是用 base64 來處理 HTML email 我一直覺得很不合理，一來大小會變 1.33 倍，二來整個 HTML 原始碼傳送時會變的幾乎無法辨識，收信軟體還要先解碼一次才可以 parse HTML，感覺完全不需要多此一舉，總之就是覺得為什麼要做這麼愚蠢的事情，明明看起來 <a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 就沒這樣限制，所以我應該可以這樣寫：</p>

<pre><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>然後內文直接放 HTML 原始碼，可是不知道為什麼沒人這樣做，事實上也不 work；最近多看了一些郵件原始碼才發現其實還有個 Quoted-Printable encoding 也很常用，看起來比 Base64 的結果還要接近原始碼許多了，所以就研究了一下它到底是什麼格式。</p>

<p>Quoted-Printable encoding 的基本原理就是用 <code>=</code> 作為 escape 字元，然後可以把要轉換的字元轉成 <code>=字碼</code> 的形式，例如 Big5 中文的 <code>我</code> 就要轉成 <code>=A7=DA</code>，規範上要轉換的是除了可見（printable）<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a> 字元以外的字元都要轉，而 ASCII 是個 7bit 編碼，字碼只有從 0 到 127 而已，而 email 要用 Quoted-Printable encoding 的主要原因其實就是為了讓文件內的每個字元編碼都維持在 7bit 編碼範圍內，現在大家常用的編碼像是 UTF-8 和以前常用的 Big5 等都是 8bit 編碼，兩者差別就在於每個傳輸的 byte 中有沒有使用到第 8 個 bit，轉成二進位的時候，7bit 系統編碼不會用到最左（higher-order）邊的那個 bit。</p>

<p>為什麼需要用 7bit 的文字編碼呢？主因是計算機和電信網路早期很多系統是只支援 7bit 編碼的，SMTP 的<a href="https://tools.ietf.org/html/rfc821#page-44">規範</a>就直接要求 TCP 傳輸時，每個 byte 最左邊的 higher-order bit 要填 0：</p>

<blockquote>
  <p>The TCP connection supports the transmission of 8-bit bytes.
The SMTP data is 7-bit ASCII characters.  Each character is
transmitted as an 8-bit byte with the high-order bit cleared to
zero.</p>
</blockquote>

<p>當然這規範很落後時代，所以在 <a href="https://tools.ietf.org/html/rfc2045#section-6">MIME（Multipurpose Internet Mail Extensions）</a> 規範其實也有 <code>Content-Transfer-Encoding</code> 可以指定傳輸用的是什麼編碼：</p>

<pre><code>Content-Transfer-Encoding: 8bit
</code></pre>

<p>不過為了相容舊系統，還是很少真的這樣使用的信件在傳遞，因為要是傳到了 7bit 系統，小則亂碼、大則程式當機。不過這就帶出另外一個問題了，難道 7bit 系統只能傳輸 ASCII 字集嗎？因為我還蠻常看到日文的純文字郵件，就去找了一些來看看，結果發現到有的是用 <code>ISO-2022-JP</code>，而且是使用 7bit 的傳輸：</p>

<pre><code>Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit
</code></pre>

<p>信件內容的文字也都很正確，沒有亂碼：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27751195323/" title="iso-2022-jp by othree, on Flickr"><img src="https://farm8.staticflickr.com/7684/27751195323_a423fd4cb4_b.jpg" width="708" height="558" alt="iso-2022-jp" srcset="" /></a></p>

<p>於是就看一下 <a href="https://zh.wikipedia.org/wiki/ISO/IEC_2022">ISO-2022</a> 的介紹，發現原來是個很早就有的 7bit 編碼方法，後來根據這方法有訂出了 CN、JP、KR 等語言的編碼，不過比較通行的看來只有 ISO-2022-JP，然後我也找到 HTML email 用 ISO-2022-JP 的：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28366990615/" title="ISO-2022-JP by othree, on Flickr"><img src="https://farm9.staticflickr.com/8572/28366990615_bc76dcce70_b.jpg" width="708" height="558" alt="ISO-2022-JP" srcset="" /></a></p>

<p>看起來就像是我理想中的 HTML email 原始碼啊，所以問題的癥結其實是，大家為了相容於舊系統，所以都用 7bit 傳輸，要 7bit safe 的 encoding 選擇有限，除了比較通行的 ISO-2022-JP 可以給日文用、字元太少只能給英文用的 ASCII 之外，其它語言就只能用 Base64 encoding 和 Quoted-Printable encoding 了，所以事實上其它 7bit 編碼的內容，也是可以直接透過 SMTP 協定來傳輸的，只是要看收信端的軟體能不能支援解碼，像是已經不太有人用的 <a href="https://zh.wikipedia.org/zh-tw/UTF-7">UTF-7</a> 就是 7bit 的 unicode 編碼。</p>

<p>最後，就是假設我們已經不用擔心老舊系統的時候，其實只要這樣寫在 MIME header 裡就可以直接傳 UTF-8 的 HTML source，不用再經過任何編碼處理了：</p>

<pre><code>Content-Transfer-Encoding: 8bit
Content-Type: text/html; charset=utf-8
</code></pre>

<p>不過距離這一步不知道還有多遠就是了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/</link>
<guid>https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/</guid>
<category>web</category>
<pubDate>2016-07-19 13:28</pubDate>
</item>

<item>
<title>Web Push</title>
<description><![CDATA[<p>前兩天要研究一下 Chrome 接 GCM 的實做，發現到 Google 又出一個新的服務叫 Firebase，然後新的 cloud messaging 服務就叫 <a href="https://firebase.google.com/docs/cloud-messaging/">Firebase Cloud Messaging(FCM)</a>，隨便看了一下 Google 官方的文件，結果發現有提到另外一個正在制訂中的 <a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-07">Web Push Protocol</a>，照文件的說法，FCM 也只是個過渡時期的方案，最終目標還是用這個 Web Push Protocol，於是我就研究了一下他的設計，發現設計的還蠻漂亮的。</p>

<p>整個 Web Push Protocol 的基本架構如下圖：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28277091075/" title="Web Push Protocol by othree, on Flickr"><img src="https://farm8.staticflickr.com/7633/28277091075_ecdf54fc60_b.jpg" width="493" height="263" alt="Web Push Protocol" srcset="" /></a></p>

<p>User Agent(UA) 通常是行動端的應用程式、Application 則是自家服務的後台；整個流程首先是 UA 透過 HTTP/1.1 POST 去跟 Push Service 訂閱（第一條橫線 Subscribe），然後會拿到一個 subscription resource，可能長成：</p>

<pre><code>https://push.example.net/subscription/LBhhw0OohO-Wl4Oi971UG
</code></pre>

<p>另外還會拿到一個發訊息用的 push resource：</p>

<pre><code>https://push.example.net/push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV
</code></pre>

<p>可以注意到兩個 resource 後面的 token 是不一樣的，兩者之間的 mapping 就是 Push Service 來負責；然後 UA 拿到這兩個網址後，發訊息用的 push resource 要交給自家服務的後台，也就是圖上第三條橫線 Distribute Push Resource，另外一個 subscription resource 則是要自己使用，UA 用 HTTP/2 打 GET 到 subscription resource，然後 push service 會把連線保持住不關掉，這就是圖上的第二條橫線 Monitor；自家服務後台的要送訊息的時候，就打 POST 去 push resource，也就是第四條橫線，從 Application 到 Push Service 間的 Push Message，push service 收到這個訊息時，就利用 HTTP/2 的 Server Push 機制主動傳送訊息，最後這個動作就是第五條橫線的 Push Message 了。</p>

<p>就這樣很漂亮的用 HTTP/1.1 + HTTP/2 把一個基本的 Cloud Message Service 的協定建構起來，而除了這最基本的訊息傳遞外，這份文件還有定義像是訊息重要度、訊息回條、群組訊息等等的方法，設計都還蠻漂亮的，安全性的部分則是限制走 HTTPS over TLS，還有 operation 相關的說明，像是實際上要跑起這個服務，需要大量的 TCP connection 等等（因為都走 HTTP 了），有興趣的可以加減看一下。</p>

<p>補充：Firefox 目前實做的似乎就是這個協定更早版本的草案</p>
]]>
</description>
<link>https://blog.othree.net/log/2016/07/14/web-push/</link>
<guid>https://blog.othree.net/log/2016/07/14/web-push/</guid>
<category>web</category>
<pubDate>2016-07-14 12:40</pubDate>
</item>

<item>
<title>My First Patch to Firefox</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/20310084805/" title="zh download dialog by othree, on Flickr"><img src="https://farm1.staticflickr.com/261/20310084805_2c8ed51b8e_c.jpg" width="400" height="210" alt="zh download dialog" srcset="https://farm1.staticflickr.com/261/20310084805_2c8ed51b8e_c.jpg 768w" /></a></p>

<p>OSX 自從升級到 10.10 之後，繁體中文版 Firefox 就冒出了一個 bug，一堆使用到作業系統原生的視窗，像是下載圖片，開啟檔案等等的，都會變成簡體中文介面，這個問題在 Bugzilla 上的編號是 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1089363">1089363</a>，畫面看起來就像上面的圖一樣，這個問題的狀況，推測是 OSX 本來在這種系統對話框，會使用使用者現在設定的系統 locale，但是 10.10 改成應用程式正在運作的 locale，然後 Firefox 本來會用 locale <code>AB_CD</code> 中的 <code>AB</code> 段而已，所以 <code>zh_TW</code> 和 <code>zh_CN</code> 就都會變成 <code>zh</code>，然後 OSX 的 <code>zh</code> 又會變成簡體中文，結果就變成這樣了。</p>

<p>其實這個 bug 的解法， Steven Michaud 很早就提出了，就是把本來 locale 的 resource 目錄的名稱改成 <code>zh_TW</code>，大概 diff 如下：</p>

<pre><code> AB_CD = $(MOZ_UI_LOCALE)

-AB := $(firstword $(subst -, ,$(AB_CD)))
+ifeq (zh-TW,$(AB_CD))
+LPROJ_ROOT := $(subst -,_,$(AB_CD))
+else
+LPROJ_ROOT := $(firstword $(subst -, ,$(AB_CD)))
+endif
+LPROJ := Contents/Resources/$(LPROJ_ROOT).lproj</code></pre>

<p>其實不會很難，不過因為 Firefox 的程式碼變動很快，連 build script 也常常變動，那個 patch 檔出來的時候已經不能用了，然後又沒人處理就這樣一直拖下去，前陣子 Moztw 那邊又被提出來一次，剛好我為了弄 WebIDL 相關應用的時候有 build 過 Firefox，想說應該可以處理看看，就接下來嘗試了，build 本身蠻簡單的，就照著網路上的<a href="https://developer.mozilla.org/en-US/docs/Simple_Firefox_build">文件</a>就好，比較難的是要 build 成特定語系的，找很久才在 Moztw 討論區找到<a href="https://forum.moztw.org/viewtopic.php?f=18&amp;t=34806">答案</a>，要在 <code>.mozconfig</code> 裡面加上：</p>

<pre><code>ac_add_options --with-l10n-base=/d/lang
ac_add_options --enable-ui-locale=zh-TW
</code></pre>

<p>其中第一行設定的路徑要指定到你指定的位置，而且要絕對路徑，然後在該目錄 clone 翻譯的 repository 下來，可以在 <a href="http://hg.mozilla.org/l10n-central/">l10n-central</a> 那邊找自己的語系，以 <code>zh-TW</code> 來說：</p>

<pre><code>cd /d/lang
git clone http://hg.mozilla.org/l10n-central/zh-TW/
</code></pre>

<p>然後這樣就可以 build 中文版了，build 完執行就看到精美的黃底紅字 XML 解析錯誤視窗。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/19687462694/" title="Firefox Missing String by othree, on Flickr"><img src="https://farm1.staticflickr.com/382/19687462694_626110d91c_z.jpg" width="320" height="162" alt="Firefox Missing String" srcset="https://farm1.staticflickr.com/382/19687462694_626110d91c_z.jpg 768w" /></a></p>

<p>還好我有點經驗，知道 Firefox 的介面是 XUL 寫的，然後字串是用 XML entity 方式存在，所以很快就想到是翻譯問題，於是上去找了 l10n dashboard 看看<a href="https://l10n.mozilla.org/teams/zh-TW">繁體中文</a>的狀況，看的是 <strong>fx_central</strong> 這棵樹下的字串：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/20301676302/" title="Firefox l10n stat by othree, on Flickr"><img src="https://farm4.staticflickr.com/3682/20301676302_3c488073c1_b.jpg" width="991" height="738" alt="Firefox l10n stat" srcset="https://farm4.staticflickr.com/3682/20301676302_3c488073c1_b.jpg 1024w" /></a></p>

<p>可以看到目前有缺哪些字串，因為字串還沒穩定所以也還不會有翻譯，所以就需要手動進去把這些 entity 的定義補上，內容隨便填，然後重新 build 一次，結果就修好了！</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/19689109663/" title="nightly zh_TW download dialog by othree, on Flickr"><img src="https://farm1.staticflickr.com/517/19689109663_81ff6a8f9a_b.jpg" width="973" height="777" alt="nightly zh_TW download dialog" srcset="https://farm1.staticflickr.com/517/19689109663_81ff6a8f9a_b.jpg 1024w" /></a></p>

<p>然後就開始想辦法生 patch 檔案了，中間也有用過 <code>hg mq</code>，最後都固定改好，commit 後用 <code>hg export . &gt; fix.patch</code>，總之改好我就丟上 bugzilla 了，結果第一個 patch 只改到一個檔案，實際上應該有五個檔案要改，而且才隔一天，Makefile 就被別人改過了，只好重新找位置修改，重新生 patch，到最後一個 review 過，build 也過的 patch 中間還發生了不少事情，包括 Makefile 被別人又改動一次，用 <code>AB</code> or <code>LPROJ</code> 的命名問題，字串的變化造成假翻譯又要增加，還有 build 工具 mach 被人改壞，和推上去之後有 build 失敗的狀況等等，非常的一波三折。</p>

<p>其中 build 失敗是 b2g 的 build 失敗，原因是我有地方改錯，不過要測試也是要重新設定，參考的是 <a href="https://developer.mozilla.org/en-US/Firefox_OS/Building_the_Firefox_OS_simulator">Building the Firefox OS Simulator</a> 這份文件，把 <code>.mozconfig</code> 改成：</p>

<pre><code>. "$topsrcdir/b2g/config/mozconfigs/common"

mk_add_options MOZ_OBJDIR=../build
mk_add_options MOZ_MAKE_FLAGS="-j9 -s"

ac_add_options --enable-application=b2g
ac_add_options --disable-libjpeg-turbo
</code></pre>

<p>重新 build 看能不能過。</p>

<p>改完產生的 patch 檔上傳到 bugzilla 時，要勾選 Content Type 是 patch，然後 review flag 設定成 <code>?</code>，選一個 reviewer，通常會有 mentor 來跟你說選誰好，我的情形是 <a href="http://blog.timc.idv.tw/">timdream</a> 在幫忙，接著就等 reviewer review，他 review 過的話， review flag 就會變成 <code>+</code>，然後就會收到一封「Congratulations on having your first patch approved」的信件，說了一些後續可以做的事情，接著要做的就是讓 patch 真的進去 repository，可以在票的 keyword 加上 <code>checkin-needed</code>，就會有機器人自己來把你的 patch check in 進 mozilla-inbound 這個 repository，然後丟上機器人自動編譯和測試，例如這個我 B2G build 失敗的<a href="https://treeherder.mozilla.org/#/jobs?repo=mozilla-inbound&amp;revision=b1b8616162b4">例子</a>，都過了就會進 mozilla-central，之後才<a href="https://wiki.mozilla.org/Tree_Rules">照順序</a>進 mozilla-aurora、mozilla-beta、mozilla-release，現在進去 mozilla-central 的大概要等 Firefox 42 才會上線了，應該是和 OSX 10.11 同時吧。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/08/07/first-patch-to-firefox/</link>
<guid>https://blog.othree.net/log/2015/08/07/first-patch-to-firefox/</guid>
<category>web</category>
<pubDate>2015-08-07 09:06</pubDate>
</item>

<item>
<title>webappsec</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/mujitra/15191563939/" title="Safety first. by MIKI Yoshihito (´･ω･), on Flickr"><img src="https://farm3.staticflickr.com/2948/15191563939_80db3b1c3c_b.jpg" width="1024" height="576" alt="Safety first." srcset="https://farm3.staticflickr.com/2948/15191563939_80db3b1c3c_b.jpg 1024w, https://farm3.staticflickr.com/2948/15191563939_42b2305e22_h.jpg 1600w" /></a></p>

<p>這幾天才注意到 W3C 的 Web Application Security Working Group，簡稱為 webappsec，專門負責安全相關的規範制訂，是 <a href="http://www.w3.org/2011/webappsec/">2011</a> 年就成立的，算是很後知後覺吧，其實現在很多已經很廣為人知的 Web 安全機制都是出自他們之手，像是 <a href="https://developer.mozilla.org/zh-TW/docs/HTTP/Access_control_CORS">CORS</a> 和 <a href="http://devco.re/blog/2014/04/08/security-issues-of-http-headers-2-content-security-policy/">CSP</a>，然後他們現在也很跟的上潮流，把標準的制訂也移到 <a href="https://github.com/w3c/WebAppSec">Github</a> 上了，其實會發現這個 Github repo 是因為最近在看 fetch 的 spec，裡面多了蠻多內容，而且有不少引用到其它新標準的地方，然後看這看著就看到 webappsec 這邊，順便就看了一下，有幾個新草稿好像還蠻有趣的，想說可以介紹一下，不過這些東西大部分都還不能用就是了。</p>

<p>第一個是 <a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/">Secure Contexts</a>，這個新東西目的很簡單，就是判斷現在的連線狀況是否安全，以前的話，前端只能看是不是使用 https protocol 連線，不過 Secure Context 有比較多的判斷流程，例如用 SSL 就不會被當成是安全的，要 TLS 才會被認為是安全，如果不是 TLS 連線則還會判斷連到哪裡，看看白名單黑名單之類的機制。</p>

<p>第二個是 <a href="https://w3c.github.io/webappsec/specs/credentialmanagement/">Credential Management</a>，主要是為了因應現在瀏覽器很多都有記下使用者填的表單資料，包括登入的表單，而這等於是把使用者某個網站的帳號密碼都記錄下來，不過其實瀏覽器要做這些功能也是會遇到很多問題，像是他要怎麼判斷現在的表單是登入表單，哪些欄位是帳號密碼，或是網站用不一樣的機制，例如 XHR 來登入，這樣瀏覽器如果無法知道是什麼機制，就無法替這些特殊機制的網站的使用者提供方便的功能，所以 webappsec 就提出 Credential Management 這個功能讓網站開發者可以透過設計好的介面來告訴瀏覽器他們的網站是怎樣登入的，然後可以儲存帳號密碼在瀏覽器端，之後提供 API 給 JavaScript 呼叫出來送到 Server 端驗證，不過說是呼叫出來，其實 JavaScript 也看不到密碼明碼，而只能直接送出 login 的 request：</p>

<pre><code>navigator.credentials.get({ "password": true }).then(
  function(credential) {
    if (!credential) {
      // The user either doesn't have credentials for this site, or
      // refused to share them. Insert some code here to show a basic
      // login form (or, ideally, do nothing, since this API should
      // really be progressive enhancement on top of an existing form).
      return;
    }
    if (credential.type == "password") {
      credential.send("https://example.com/loginEndpoint")
        .then(function (response) {
          // Notify the user that signin succeeded! Do amazing, signed-in things!
        });
    } else {
      // See the Federated Sign-in example
    }
  }
);
</code></pre>

<p>這是從 spec 內複製出來的 sample code，一個重點是，JavaScript 程式碼其實碰不到你的密碼，只能直接把 credential send 出去，其它也還支援像是 Facebook 那種第三方登入的設計，以及把 credential 存進 store 等等機制。</p>

<p>第三個是 <a href="https://w3c.github.io/webappsec/specs/subresourceintegrity/">Subresource Integrity</a>：</p>

<pre><code>&lt;script src="https://analytics-r-us.example.com/v1.0/include.js"
        integrity="sha256-Rj/9XDU7F6pNSX8yBddiCIIS+XKDTtdq0//No0MH0AE="
        crossorigin="anonymous"&gt;&lt;/script&gt;
</code></pre>

<p>這是個看範例馬上就能理解幹什麼用的，就是對網頁要用到的其它 resource 檔案包括：js、css 等加上驗證檔案正確性的 hash，為的是避免有第三方的檔案內容被惡意攻擊者修改過。</p>

<p>第四個是 <a href="https://w3c.github.io/webappsec/specs/upgrade/">Upgrade Insecure Requests</a>，這是唯一目前已經可以用的，為的是解決 mixed content 的問題，也就是有的網站可能最近才改為 HTTPS 連線，但是網站內部用到的一些內容還是寫死 URL 用 HTTP，這時候瀏覽器就會跳出說網頁內容可能不安全，然而，這些使用 HTTP 的檔案其實可能用 HTTPS 連線也找的到，像是 Flickr、TED 等都有支援 HTTPS 連線，而 Upgrade 就是跟瀏覽器說如果這些內容找得到 HTTPS 的就用 HTTPS 的，而不是只看寫死的 URL，目前 Chrome 43 已經開始支援了，有個線上 <a href="https://googlechrome.github.io/samples/csp-upgrade-insecure-requests/">demo</a> 可以看，設定方法可以透過 CSP header 加上 <code>upgrade-insecure-requests</code> 或是寫到 meta 標籤裡面（demo 用的）</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;
</code></pre>

<p>其實這個標準我一開始以為是類似 HSTS，是對現在開的網址本身做判斷是不是有 HTTPS 可供選擇，有的話就改用 HTTPS 連線，仔細看之後才發現是用來處理 mixed content ，可是又看一看發現也有一部份比較新的草稿有講到這個功能，目前討論的版本是用 header：</p>

<pre><code>HTTPS: 1
</code></pre>

<p>很簡潔不過還沒瀏覽器支援就是了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/07/03/webappsec/</link>
<guid>https://blog.othree.net/log/2015/07/03/webappsec/</guid>
<category>web</category>
<pubDate>2015-07-03 23:13</pubDate>
</item>

<item>
<title>Aster 與 PostCSS</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17133620000/" title="台南 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7771/17133620000_64aac917c8_b.jpg" width="1024" height="683" alt="台南" srcset="https://farm8.staticflickr.com/7771/17133620000_64aac917c8_b.jpg 1024w, https://farm8.staticflickr.com/7771/17133620000_2536c112ef_h.jpg 1600w" /></a></p>

<p>前端為了 performance 需求，把網站推上 server 時會需要把 JavaScript、CSS 之類的文字檔案合併和最小化，如果開發時寫的是 CoffeeScript 或是 SASS 之類的還需要先轉成 JavaScript 和 CSS 這些主流格式，要做這些動作其實第一個想到的是可以用 Makefile，優點是常見、各平台都有，不過寫起來並不像這幾年流行的 build tool 那樣直覺，而前端領域流行的主要是 <a href="http://gruntjs.com/">Grunt</a> 和 <a href="http://gulpjs.com/">Gulp</a> 這兩個，兩者之中我個人是比較喜歡後起的 Gulp，不過前陣子意外發現一個看起來超正確的 build tool，叫 <a href="http://asterjs.github.io/aster/">aster</a>，是 Ingvar Stepanyan 做的，他在 Zurich 的 Frontend Conference 2014 的演講算是比較大規模的發佈：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/fF_jZ7ErwUY?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
]]><![CDATA[<p>Aster 這個名稱的來由是 AST，Aster 的特別之處就在於他所有的修改都是在 AST 上做修改：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17141309009/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7680/17141309009_fac4a51d86_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7680/17141309009_fac4a51d86_b.jpg 1024w, https://farm8.staticflickr.com/7680/17141309009_bbdc544510_h.jpg 1600w" /></a></p>

<p>相較於 Gulp：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17327152261/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7662/17327152261_6de37ae977_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7662/17327152261_6de37ae977_b.jpg 1024w, https://farm8.staticflickr.com/7662/17327152261_52b8bed2f1_h.jpg 1600w" /></a></p>

<p>和 Grunt：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17327152081/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7717/17327152081_7bd3f29f74_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7717/17327152081_7bd3f29f74_b.jpg 1024w, https://farm8.staticflickr.com/7717/17327152081_0d9d346ffc_h.jpg 1600w" /></a></p>

<p>很明顯的是正確許多的設計，理論上 parse 成 AST 之後，一口氣在 AST 階段把需要的變更做完，然後再用 code generator 產生成果的程式碼，應該省去很多來回轉換的工作，不論是效能還是程式碼處理的正確性都應該是最好的，不過這看似正確設計下的產品，卻沒什麼人用，我嘗試使用過程中還發了幾個 PR 回去，結果到現在都還沒有回應，有種是不是作者都已經放棄的疑問。</p>

<p>然後這兩天，又看到一個其實已經出來蠻久的 compile to CSS language，叫 <a href="https://github.com/postcss/postcss">PostCSS</a>，號稱比 SASS 之類的快上 3-30 倍，還可以做到一些 SASS/LESS 做不到功能，也有很多大企業採用，像是 Google、VK、Alibaba 之類的，應該就是目前最夯的 CSS 工具，然後我看介紹的投影片看到這張：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17301590026/" title="PostCSS by othree, on Flickr"><img src="https://farm8.staticflickr.com/7763/17301590026_184c69e66f_b.jpg" width="1024" height="638" alt="PostCSS" srcset="https://farm8.staticflickr.com/7763/17301590026_184c69e66f_b.jpg 1024w, https://farm8.staticflickr.com/7763/17301590026_3ebc26bdb7_h.jpg 1600w" /></a></p>

<p>覺得，這根本和 Aster 是一樣的想法，不過一個處理 JavaScript，做 ES6 to ES5、concat、minimize 甚至是細微的程式碼修改，另外一個處理 CSS，也是做類似的工作，為什麼結果發展的差距會這麼大？想了一陣子之後，我覺得大概狀況是，SASS、LESS 之類的工具目前還是會造成一些讓開發者痛苦的問題，像是 nesting rule 讓 selector 太長太複雜、mixin 和 include 的混淆等等，所以開發者還會一直嘗試不同的新工具，甚至自己開發來解決這些問題，而相對於 CSS，JavaScript 的相關工具比較沒這些問題，二來 JavaScript 的 AST 比 CSS 的 AST 要複雜許多，要參與工具的開發難度是高上許多，Aster 作者的功力還蠻強的，除了 AST 操作之外，他的整個流程控制還用上很先進的 <a href="https://rxjs.codeplex.com/">RxJS</a>，其實也算是增加了參與的難度吧，而我想就是這沒有強烈需求加上進入難度高兩點，結果讓 Aster 並不太受到人注意，沒什麼人參與，開發的完整度不夠，我實際用起來，就覺得目前還只是核心完整，但是真的要離實用到專案上還有些距離，加上不知道還有沒有要繼續發展下去，覺得實在很可惜。</p>
]]></description>
<link>https://blog.othree.net/log/2015/05/02/aster-postcss/</link>
<guid>https://blog.othree.net/log/2015/05/02/aster-postcss/</guid>
<category>web</category>
<pubDate>2015-05-02 11:35</pubDate>
</item>

<item>
<title>For the Entire Web</title>
<description><![CDATA[<p>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實本質上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 <a href="https://www.pandastrike.com/posts/20150311-react-bad-idea">React Is A Terrible Idea</a>，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。</p>

<p>再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和 Web Component 合作，還附上 ng-conf 的<a href="https://www.youtube.com/watch?v=g0TD0efcwVg">演講影片</a>，我到覺得他們也完全沒搞清楚作者的重點在哪裡；提到 Flipboard 的 <a href="https://github.com/flipboard/react-canvas">react-canvas</a> 那部分算是我認為最能表現出作者想要講什麼的，作者想說的重點是現在的網路環境有限制、有問題，但是遇到時不要用一些旁門左道的方法來處理，因為這些問題終究會被解決，而問題被解決時，你之前所花的時間和資源就等於是完全浪費掉，與其要浪費在走旁門左道，還不如把這些時間和資源用在從正確的地方解決這個問題，而最後受惠的不只是自己，還有所有網際網路的開發者、使用者，這是從一個很高等生命體的角度來看事情，就如同這篇文章的標題：「For the Entire Web」，要你犧牲自己的部分利益去成就整體網際網路的利益，當然這是有些理想化，很多商業公司可能要短時間就有產品出來，不太可能所有的開發在遇到問題時都停下來等瀏覽器或是標準齊備，但是對於不少的大型企業，我就覺得他們確實應該要好好正確的回饋網路環境來解決這些問題，像是文中提到 Facebook，還有接下來要說的 Google，不過他說 Facebook 是為了和 Google 競爭才開發 React 之類的論點我就不予評論了，太多臆測～</p>

<p>可能有人會說，有沒有這些資源的投入應該差距也不大吧，最近就剛好有另外一件事情可以佐證，<a href="http://news.dartlang.org/2015/03/dart-for-entire-web.html">Dart for the Entire Web</a> 這篇 Dart 官方的公告說到，Dart VM 將不會進入到 Chrome 裡面，也就是說要在瀏覽器上跑 Dart，將還是只有轉成 JavaScript 這個選項，這件事其實是蠻大的一件事，上一個在網頁裡面跑的另外一種語言是微軟的 VBScript，最大的問題不在於好不好寫，而是在於他被單一企業把持，不過後來結果大家也都知道，所以當 Google 推出 Dart 而且說以後 Chrome 會可以直接跑 Dart 的時候，我想大部分人都是都不看好的，甚至部分人是覺得 Google 怎麼做微軟做過的蠢事。而剛好在這個官方公告出來後幾天內，Brendan Eich 在 Hacker News 上回應一串討論<a href="https://news.ycombinator.com/item?id=9269355">回應</a>的蠻激動的，這串本來是在說 ECMAScript 新版本有很多東西根本是從 Dart 來的，Brendan Eich 則是反駁說很多東西在 Dart 出來前就已經在討論有 Proposal 了，然後到後來寫了一篇幾乎都在抱怨 Dart，還提到 V8 team reset 的事情，從這邊看起來，似乎是因為新的 V8 team 不打算作 Dart VM 進去，才有了 Dart 那篇公告；而 Brendan Eich 抱怨的重點，其實就是前面那段提到的，Google 花了超多人力資源去搞 Dart，而不是來幫忙改進既有的 ECMAScript，而這確實有實際的影響，他舉了一個例子，就是大數(<a href="http://wiki.ecmascript.org/doku.php?id=strawman:bignums">bignums</a>)的支援，Dart 有支援，在 ES 這邊目前有一點可能性會在 ES7(2016) 中出來，但這東西其實從 2010 就已經開始有討論了，如果有人來將這些討論規格化，並實做起來，那大數應該在現在的 ES6(2015) 就有了。</p>

<p>最後再回到 Terriable Idea 這篇文章，我雖然不完全認同他對 React 的看法，但是我認為他的重點沒錯，如果他拿 Dart 出來講可能就不會引出這麼多砲火吧（可是可能也比較沒人注意），其實 react-canvas 我覺得也是很有趣的實驗，不過做成正式產品上線就是另外一回事了，最大的問題，他為了終會被解決的次要問題（畫面不流暢）完全放棄了親和力的問題，而 Flipboard 這種內容為主的產品性質是不該放棄親和力的。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/03/28/for-the-entire-web/</link>
<guid>https://blog.othree.net/log/2015/03/28/for-the-entire-web/</guid>
<category>web</category>
<pubDate>2015-03-28 13:25</pubDate>
</item>

<item>
<title>在盲人之前的親和力</title>
<description><![CDATA[<p>不少人還會直接把網站的親和力（無障礙）問題和盲人朋友直接連在一起，覺得應該來解除迷思一下，盲人朋友確實是最直接會想到的，各種有身心障礙人士的族群當中，盲人朋友使用電腦上網的難度也是最高的，不過在你把眼睛矇起來體驗盲人如何操作電腦之前，有不少事情是可以先做的，隨便把腦袋裡馬上想的到的列了一下：</p>

<p>首先是網頁的文字內容易讀性，易讀性有分兩個面向，第一個面向大家比較清楚，就是文字排版、字形挑選、顏色對比等等視覺上的易讀程度，這部分做的好的話除了對老花眼、近視或是弱視的朋友有幫助外，一般人也會受惠；另一個面向則是文字內容好不好理解的程度，如果網站上的文字說明太難懂，那就應該要用更好理解的文字來重新講一遍，或是加上圖表輔助，或是乾脆減少資訊量，通常自己看的懂，不代表別人看的懂，所以如果是重要的說明（尤其是政府網站一些流程、辦理辦法之類的），建議都要找人看過，最簡單的是找家中長輩，因為網路上理解力較低的族群中，長輩們佔不少。</p>

<p>第二個是操作介面好不好操作，通常是 Web App 才有這需求，一樣有不同的面向，第一個是你的操作介面應該設計的容易理解，讓人看了也不會疑惑應該點哪裡，其中一個很重要的原則是不要破壞使用者的習慣，第二個面向是有些人可能無法好好的控制滑鼠（要模擬這個比模擬盲人的情境還要難），點擊不精確，所以永遠要保留鍵盤操作的選項，如果是使用原生的輸入元件來做操作介面的話，沒有亂做什麼奇怪的事情應該是都可以用鍵盤來控制，但是如果要自己設計一個嶄新的控制元件，那記得要好好利用 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA">WAI-ARIA</a> 來讓鍵盤可以順利的控制，像是 Google 的 Gmail 就有完整的鍵盤操作支援，這個應該是這篇文章當中做起來最辛苦的一項吧。</p>

<p>第三個是表單行為，要把表單作的好填，本身是一門很大的學問，不過在深入的思考設計表單的 usability 之前，有一些很基本的功能是應該具備的，其中特別想說的是錯誤訊息的處理，使用者送出表單後，如果後端的檢查沒過被打回來，應該要伴隨著能幫助使用者更新資料的錯誤訊息，並且正確的顯示在正確的位置，不然使用者不知道發生什麼事情，除了告訴使用者哪裡有錯之外，更進一步是讓使用者能把輸入資料改好，例如帳號名稱有格式限制的話，就要明確的說明有哪些限制，另外表單檢查不通過之後，記得也不要把使用者剛剛填的資料清空（實做這點還需要特別記得安全性問題）。</p>

<p>最後一個是文件結構，正確的使用 HTML 標籤，還可以輔以 WAI-ARIA 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">role</a> 屬性，這已經是講到爛的項目了，當然 single page application 算是特殊情形，不過只要你做的頁面還是接近傳統網頁有文字內容，有主要內容的話，把網頁的文件結構弄好還是有兩大好處的：一、SEO 的部分已經好了一大半了；二、所有輔具都可以根據你的文件結構快速的帶領使用者在文件中穿梭，不用多做什麼奇怪的導盲機制。要把這塊做好算是四點當中最簡單的，只要正確的依照語意使用 HTML 標籤，不夠的再看看 WAI-ARIA 有沒有可用的 role，不要亂用標籤，然後用檢視原始碼的功能看看好不好看，如果你能開始從 HTML 原始碼中感受到美感甚至有完美的感覺出來，相信你就在正確的方向上了。</p>

<p>其實以上四點都有一個特色，就是把這些地方做好，不只是身心障礙人士會受惠，文字易讀性就不用說了，操控介面如果支援鍵盤，有些正常人操作起來會更得心應手，表單的訊息也是不論是怎樣的使用者都很需要，而文件結構也是，弄得好的話，大家都好找到資料，站長應該也開心。所以其實在你想要為了提升親和力而去實際模擬身心障礙人士使用電腦的情境之前，是有很多東西是可以先做的，</p>

<p>相信還是有人會有興趣盲人朋友怎麼操控電腦的，曾經 HappyDesigner 有邀請有聲書協會的朋友來介紹，不過已經有點久了，我去年初剛好有機會在 Moztw Lab 遇到 Fancy 示範，當時有簡單的錄下來，有興趣的朋友可以看一下：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/fV2ufa2galY?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<p>至於要怎麼體驗盲人怎麼操作呢？如果你是用 OSX 的話，系統有內建 Voice Over，品質很好，可以直接使用，Windows 有好幾套商業軟體，至於免費的比較有名的是 <a href="http://www.nvaccess.org/">NVDA</a>，這套也是開源軟體，一開始可能需要先當明眼人練習操作，另外它講的話一開始可能會聽不太懂，聲音合成引擎和商業軟體比起來有差，多聽幾次慢慢就聽的出來再講什麼了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/01/31/accessibility-before-been-blind/</link>
<guid>https://blog.othree.net/log/2015/01/31/accessibility-before-been-blind/</guid>
<category>web</category>
<pubDate>2015-01-31 18:58</pubDate>
</item>


</channel>
</rss>