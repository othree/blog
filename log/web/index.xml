<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>c</b:listType>
			<b:listData listID="web">web</b:listData>
		</b:entriesMeta>

		<b:entry entryID="000876" baseName="safari-10">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-09-21</b:date>
				<b:time>23:57:08</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Safari 10 for Developer</b:title>
			<b:content>
				<b:summary>Safari 10 跟著 macOS 一起出來了，這次更新了不少東西（對於網頁開發者來說），Apple 也依舊放了一份文件在他們的 Developer Library 裡面，以下列出我覺得比較有趣的： CSP 2.0 CSP 2.0 和之前的版本相比，最主要是多了非常多可以控制的權限，也有幾個名稱有改掉，不過基本上格式是相容的。 Shadow DOM Shadow DOM 1.0 標準，這也讓 Web Component 的理想又往前賣進一步了。 ES 6 號稱支援度 100%，看起來是依據 ECMAScript compatable table 的，不過在 module 的面前，還沒有真的 100% 的啊，另外主流瀏覽器其實支援度都蠻高了，之前 Edge 還放話說領先的，沒想到現在就已經被 Safari 10 和...</b:summary>
				<b:mainContent><p>Safari 10 跟著 macOS 一起出來了，這次更新了不少東西（對於網頁開發者來說），Apple 也依舊放了一份<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html">文件</a>在他們的 Developer Library 裡面，以下列出我覺得比較有趣的：</p>

<h4>CSP 2.0</h4>

<p>CSP 2.0 和之前的版本相比，最主要是多了非常多可以控制的權限，也有幾個名稱有改掉，不過基本上格式是相容的。</p>

<h4>Shadow DOM</h4>

<p>Shadow DOM 1.0 標準，這也讓 Web Component 的理想又往前賣進一步了。</p>

<h4>ES 6</h4>

<p>號稱支援度 100%，看起來是依據 <a href="http://kangax.github.io/compat-table/es6/#safari10">ECMAScript compatable table</a> 的，不過在 module 的面前，還沒有真的 100% 的啊，另外主流瀏覽器其實支援度都蠻高了，之前 Edge 還放話說領先的，沒想到現在就已經被 Safari 10 和 Chrome 超過了，而 Chrome 看來也之差 tail call 而已，接下來應該又要開始效能比拼了吧。</p>

<h4>Inline and Auto Video Playback in iOS</h4>

<p>這也是等很久的功能，之前就有先開放靜音影片能直接在 iOS Safari 上自動播放，主要的考量是，gif 和 mp4 相比，還是 gif 比較吃資源啊。</p>

<h4>ES Internationalization</h4>

<p>ECMA-402 支援，這也是希望快點普及的東西啊，不然數字、日期什麼的搞本地化實在很麻煩。</p>

<h4>WOFF 2.0 Support</h4>

<p>令人意外的有點慢，不過還算很有誠意的把很新的 <a href="https://drafts.csswg.org/css-font-loading/">CSS Font Loading Module Level 3</a> 的 API 做好了。</p>

<h4>#RRGGBBAA</h4>

<p>新的 CSS color 格式，也是前陣子才 propose 出來而已，這樣以後就可以讓 CSS 裡的顏色格式統一點了。</p>

<h4>Right-to-Left Language Support</h4>

<p>主要是 RTL 頁面 scrollbar 的位置終於會換邊了。</p>

<h4>Media Query for Wide Color Gamut Support</h4>

<p>廣色域的 CSS media query，主要是因為最新的 iMac 和 iPhone 7 都有支援 P3 色域了。</p>

<h4>WebDriver Support</h4>

<p>主流瀏覽器最後一個支援的...</p>

<h4>Apple Pay for the Web</h4>

<p>這真的蠻兇狠的，不過 Google 也有在 Android 做類似的<a href="https://android.googleblog.com/2016/09/tap-pay-yes-android-pay-welcomes-chase.html">事</a>就是了。</p>

<p>大概就這些了，其實也列出超過一半的項目了，Safari 這種更新頻率其實比起其它幾家來說吃虧不少，不過還是一直有跟上最新進度，其實也蠻厲害的，更何況現在 Google 都把人拉到 Blink 去，有回到 Webkit 的貢獻似乎比例上不高。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000871" baseName="7bit-encoding-and-email">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-07-19</b:date>
				<b:time>13:28:23</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>7 Bit Encoding and Email</b:title>
			<b:content>
				<b:summary>最近工作上比較常接觸到 email 的東西，然後比較認真的看了 HTML email 信件的內容，以前我以為都要用 base64 編碼來處理，可是用 base64 來處理 HTML email 我一直覺得很不合理，一來大小會變 1.33 倍，二來整個 HTML 原始碼傳送時會變的幾乎無法辨識，收信軟體還要先解碼一次才可以 parse HTML，感覺完全不需要多此一舉，總之就是覺得為什麼要做這麼愚蠢的事情，明明看起來 MIME 就沒這樣限制，所以我應該可以這樣寫： Content-Type: text/html; charset=utf-8 然後內文直接放 HTML 原始碼，可是不知道為什麼沒人這樣做，事實上也不 work；最近多看了一些郵件原始碼才發現其實還有個 Quoted-Printable encoding 也很常用，看起來比 Base64 的結果還要接近原始碼許多了，所以就研究了一下它到底是什麼格式。 Quoted-Printable encoding 的基本原理就是用 = 作為 escape 字元，然後可以把要轉換的字元轉成...</b:summary>
				<b:mainContent><p>最近工作上比較常接觸到 email 的東西，然後比較認真的看了 HTML email 信件的內容，以前我以為都要用 base64 編碼來處理，可是用 base64 來處理 HTML email 我一直覺得很不合理，一來大小會變 1.33 倍，二來整個 HTML 原始碼傳送時會變的幾乎無法辨識，收信軟體還要先解碼一次才可以 parse HTML，感覺完全不需要多此一舉，總之就是覺得為什麼要做這麼愚蠢的事情，明明看起來 <a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 就沒這樣限制，所以我應該可以這樣寫：</p>

<pre><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>然後內文直接放 HTML 原始碼，可是不知道為什麼沒人這樣做，事實上也不 work；最近多看了一些郵件原始碼才發現其實還有個 Quoted-Printable encoding 也很常用，看起來比 Base64 的結果還要接近原始碼許多了，所以就研究了一下它到底是什麼格式。</p>

<p>Quoted-Printable encoding 的基本原理就是用 <code>=</code> 作為 escape 字元，然後可以把要轉換的字元轉成 <code>=字碼</code> 的形式，例如 Big5 中文的 <code>我</code> 就要轉成 <code>=A7=DA</code>，規範上要轉換的是除了可見（printable）<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a> 字元以外的字元都要轉，而 ASCII 是個 7bit 編碼，字碼只有從 0 到 127 而已，而 email 要用 Quoted-Printable encoding 的主要原因其實就是為了讓文件內的每個字元編碼都維持在 7bit 編碼範圍內，現在大家常用的編碼像是 UTF-8 和以前常用的 Big5 等都是 8bit 編碼，兩者差別就在於每個傳輸的 byte 中有沒有使用到第 8 個 bit，轉成二進位的時候，7bit 系統編碼不會用到最左（higher-order）邊的那個 bit。</p>

<p>為什麼需要用 7bit 的文字編碼呢？主因是計算機和電信網路早期很多系統是只支援 7bit 編碼的，SMTP 的<a href="https://tools.ietf.org/html/rfc821#page-44">規範</a>就直接要求 TCP 傳輸時，每個 byte 最左邊的 higher-order bit 要填 0：</p>

<blockquote>
  <p>The TCP connection supports the transmission of 8-bit bytes.
The SMTP data is 7-bit ASCII characters.  Each character is
transmitted as an 8-bit byte with the high-order bit cleared to
zero.</p>
</blockquote>

<p>當然這規範很落後時代，所以在 <a href="https://tools.ietf.org/html/rfc2045#section-6">MIME（Multipurpose Internet Mail Extensions）</a> 規範其實也有 <code>Content-Transfer-Encoding</code> 可以指定傳輸用的是什麼編碼：</p>

<pre><code>Content-Transfer-Encoding: 8bit
</code></pre>

<p>不過為了相容舊系統，還是很少真的這樣使用的信件在傳遞，因為要是傳到了 7bit 系統，小則亂碼、大則程式當機。不過這就帶出另外一個問題了，難道 7bit 系統只能傳輸 ASCII 字集嗎？因為我還蠻常看到日文的純文字郵件，就去找了一些來看看，結果發現到有的是用 <code>ISO-2022-JP</code>，而且是使用 7bit 的傳輸：</p>

<pre><code>Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit
</code></pre>

<p>信件內容的文字也都很正確，沒有亂碼：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27751195323/" title="iso-2022-jp by othree, on Flickr"><img src="https://farm8.staticflickr.com/7684/27751195323_a423fd4cb4_b.jpg" width="708" height="558" alt="iso-2022-jp" srcset="" /></a></p>

<p>於是就看一下 <a href="https://zh.wikipedia.org/wiki/ISO/IEC_2022">ISO-2022</a> 的介紹，發現原來是個很早就有的 7bit 編碼方法，後來根據這方法有訂出了 CN、JP、KR 等語言的編碼，不過比較通行的看來只有 ISO-2022-JP，然後我也找到 HTML email 用 ISO-2022-JP 的：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28366990615/" title="ISO-2022-JP by othree, on Flickr"><img src="https://farm9.staticflickr.com/8572/28366990615_bc76dcce70_b.jpg" width="708" height="558" alt="ISO-2022-JP" srcset="" /></a></p>

<p>看起來就像是我理想中的 HTML email 原始碼啊，所以問題的癥結其實是，大家為了相容於舊系統，所以都用 7bit 傳輸，要 7bit safe 的 encoding 選擇有限，除了比較通行的 ISO-2022-JP 可以給日文用、字元太少只能給英文用的 ASCII 之外，其它語言就只能用 Base64 encoding 和 Quoted-Printable encoding 了，所以事實上其它 7bit 編碼的內容，也是可以直接透過 SMTP 協定來傳輸的，只是要看收信端的軟體能不能支援解碼，像是已經不太有人用的 <a href="https://zh.wikipedia.org/zh-tw/UTF-7">UTF-7</a> 就是 7bit 的 unicode 編碼。</p>

<p>最後，就是假設我們已經不用擔心老舊系統的時候，其實只要這樣寫在 MIME header 裡就可以直接傳 UTF-8 的 HTML source，不用再經過任何編碼處理了：</p>

<pre><code>Content-Transfer-Encoding: 8bit
Content-Type: text/html; charset=utf-8
</code></pre>

<p>不過距離這一步不知道還有多遠就是了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000869" baseName="web-push">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-07-14</b:date>
				<b:time>12:40:19</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Web Push</b:title>
			<b:content>
				<b:summary>前兩天要研究一下 Chrome 接 GCM 的實做，發現到 Google 又出一個新的服務叫 Firebase，然後新的 cloud messaging 服務就叫 Firebase Cloud Messaging(FCM)，隨便看了一下 Google 官方的文件，結果發現有提到另外一個正在制訂中的 Web Push Protocol，照文件的說法，FCM 也只是個過渡時期的方案，最終目標還是用這個 Web Push Protocol，於是我就研究了一下他的設計，發現設計的還蠻漂亮的。 整個 Web Push Protocol 的基本架構如下圖： User Agent(UA) 通常是行動端的應用程式、Application 則是自家服務的後台；整個流程首先是 UA 透過 HTTP/1.1 POST 去跟 Push Service 訂閱（第一條橫線...</b:summary>
				<b:mainContent><p>前兩天要研究一下 Chrome 接 GCM 的實做，發現到 Google 又出一個新的服務叫 Firebase，然後新的 cloud messaging 服務就叫 <a href="https://firebase.google.com/docs/cloud-messaging/">Firebase Cloud Messaging(FCM)</a>，隨便看了一下 Google 官方的文件，結果發現有提到另外一個正在制訂中的 <a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-07">Web Push Protocol</a>，照文件的說法，FCM 也只是個過渡時期的方案，最終目標還是用這個 Web Push Protocol，於是我就研究了一下他的設計，發現設計的還蠻漂亮的。</p>

<p>整個 Web Push Protocol 的基本架構如下圖：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28277091075/" title="Web Push Protocol by othree, on Flickr"><img src="https://farm8.staticflickr.com/7633/28277091075_ecdf54fc60_b.jpg" width="493" height="263" alt="Web Push Protocol" srcset="" /></a></p>

<p>User Agent(UA) 通常是行動端的應用程式、Application 則是自家服務的後台；整個流程首先是 UA 透過 HTTP/1.1 POST 去跟 Push Service 訂閱（第一條橫線 Subscribe），然後會拿到一個 subscription resource，可能長成：</p>

<pre><code>https://push.example.net/subscription/LBhhw0OohO-Wl4Oi971UG
</code></pre>

<p>另外還會拿到一個發訊息用的 push resource：</p>

<pre><code>https://push.example.net/push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV
</code></pre>

<p>可以注意到兩個 resource 後面的 token 是不一樣的，兩者之間的 mapping 就是 Push Service 來負責；然後 UA 拿到這兩個網址後，發訊息用的 push resource 要交給自家服務的後台，也就是圖上第三條橫線 Distribute Push Resource，另外一個 subscription resource 則是要自己使用，UA 用 HTTP/2 打 GET 到 subscription resource，然後 push service 會把連線保持住不關掉，這就是圖上的第二條橫線 Monitor；自家服務後台的要送訊息的時候，就打 POST 去 push resource，也就是第四條橫線，從 Application 到 Push Service 間的 Push Message，push service 收到這個訊息時，就利用 HTTP/2 的 Server Push 機制主動傳送訊息，最後這個動作就是第五條橫線的 Push Message 了。</p>

<p>就這樣很漂亮的用 HTTP/1.1 + HTTP/2 把一個基本的 Cloud Message Service 的協定建構起來，而除了這最基本的訊息傳遞外，這份文件還有定義像是訊息重要度、訊息回條、群組訊息等等的方法，設計都還蠻漂亮的，安全性的部分則是限制走 HTTPS over TLS，還有 operation 相關的說明，像是實際上要跑起這個服務，需要大量的 TCP connection 等等（因為都走 HTTP 了），有興趣的可以加減看一下。</p>

<p>補充：Firefox 目前實做的似乎就是這個協定更早版本的草案</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000848" baseName="first-patch-to-firefox">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-08-07</b:date>
				<b:time>09:06:43</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>My First Patch to Firefox</b:title>
			<b:content>
				<b:summary> OSX 自從升級到 10.10 之後，繁體中文版 Firefox 就冒出了一個 bug，一堆使用到作業系統原生的視窗，像是下載圖片，開啟檔案等等的，都會變成簡體中文介面，這個問題在 Bugzilla 上的編號是 1089363，畫面看起來就像上面的圖一樣，這個問題的狀況，推測是 OSX 本來在這種系統對話框，會使用使用者現在設定的系統 locale，但是 10.10 改成應用程式正在運作的 locale，然後 Firefox 本來會用 locale AB_CD 中的 AB 段而已，所以 zh_TW 和 zh_CN 就都會變成 zh，然後 OSX 的 zh 又會變成簡體中文，結果就變成這樣了。 其實這個 bug 的解法， Steven Michaud 很早就提出了，就是把本來 locale...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/20310084805/" title="zh download dialog by othree, on Flickr"><img src="https://farm1.staticflickr.com/261/20310084805_2c8ed51b8e_c.jpg" width="400" height="210" alt="zh download dialog" srcset="https://farm1.staticflickr.com/261/20310084805_2c8ed51b8e_c.jpg 768w" /></a></p>

<p>OSX 自從升級到 10.10 之後，繁體中文版 Firefox 就冒出了一個 bug，一堆使用到作業系統原生的視窗，像是下載圖片，開啟檔案等等的，都會變成簡體中文介面，這個問題在 Bugzilla 上的編號是 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1089363">1089363</a>，畫面看起來就像上面的圖一樣，這個問題的狀況，推測是 OSX 本來在這種系統對話框，會使用使用者現在設定的系統 locale，但是 10.10 改成應用程式正在運作的 locale，然後 Firefox 本來會用 locale <code>AB_CD</code> 中的 <code>AB</code> 段而已，所以 <code>zh_TW</code> 和 <code>zh_CN</code> 就都會變成 <code>zh</code>，然後 OSX 的 <code>zh</code> 又會變成簡體中文，結果就變成這樣了。</p>

<p>其實這個 bug 的解法， Steven Michaud 很早就提出了，就是把本來 locale 的 resource 目錄的名稱改成 <code>zh_TW</code>，大概 diff 如下：</p>

<pre><code> AB_CD = $(MOZ_UI_LOCALE)

-AB := $(firstword $(subst -, ,$(AB_CD)))
+ifeq (zh-TW,$(AB_CD))
+LPROJ_ROOT := $(subst -,_,$(AB_CD))
+else
+LPROJ_ROOT := $(firstword $(subst -, ,$(AB_CD)))
+endif
+LPROJ := Contents/Resources/$(LPROJ_ROOT).lproj</code></pre>

<p>其實不會很難，不過因為 Firefox 的程式碼變動很快，連 build script 也常常變動，那個 patch 檔出來的時候已經不能用了，然後又沒人處理就這樣一直拖下去，前陣子 Moztw 那邊又被提出來一次，剛好我為了弄 WebIDL 相關應用的時候有 build 過 Firefox，想說應該可以處理看看，就接下來嘗試了，build 本身蠻簡單的，就照著網路上的<a href="https://developer.mozilla.org/en-US/docs/Simple_Firefox_build">文件</a>就好，比較難的是要 build 成特定語系的，找很久才在 Moztw 討論區找到<a href="https://forum.moztw.org/viewtopic.php?f=18&amp;t=34806">答案</a>，要在 <code>.mozconfig</code> 裡面加上：</p>

<pre><code>ac_add_options --with-l10n-base=/d/lang
ac_add_options --enable-ui-locale=zh-TW
</code></pre>

<p>其中第一行設定的路徑要指定到你指定的位置，而且要絕對路徑，然後在該目錄 clone 翻譯的 repository 下來，可以在 <a href="http://hg.mozilla.org/l10n-central/">l10n-central</a> 那邊找自己的語系，以 <code>zh-TW</code> 來說：</p>

<pre><code>cd /d/lang
git clone http://hg.mozilla.org/l10n-central/zh-TW/
</code></pre>

<p>然後這樣就可以 build 中文版了，build 完執行就看到精美的黃底紅字 XML 解析錯誤視窗。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/19687462694/" title="Firefox Missing String by othree, on Flickr"><img src="https://farm1.staticflickr.com/382/19687462694_626110d91c_z.jpg" width="320" height="162" alt="Firefox Missing String" srcset="https://farm1.staticflickr.com/382/19687462694_626110d91c_z.jpg 768w" /></a></p>

<p>還好我有點經驗，知道 Firefox 的介面是 XUL 寫的，然後字串是用 XML entity 方式存在，所以很快就想到是翻譯問題，於是上去找了 l10n dashboard 看看<a href="https://l10n.mozilla.org/teams/zh-TW">繁體中文</a>的狀況，看的是 <strong>fx_central</strong> 這棵樹下的字串：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/20301676302/" title="Firefox l10n stat by othree, on Flickr"><img src="https://farm4.staticflickr.com/3682/20301676302_3c488073c1_b.jpg" width="991" height="738" alt="Firefox l10n stat" srcset="https://farm4.staticflickr.com/3682/20301676302_3c488073c1_b.jpg 1024w" /></a></p>

<p>可以看到目前有缺哪些字串，因為字串還沒穩定所以也還不會有翻譯，所以就需要手動進去把這些 entity 的定義補上，內容隨便填，然後重新 build 一次，結果就修好了！</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/19689109663/" title="nightly zh_TW download dialog by othree, on Flickr"><img src="https://farm1.staticflickr.com/517/19689109663_81ff6a8f9a_b.jpg" width="973" height="777" alt="nightly zh_TW download dialog" srcset="https://farm1.staticflickr.com/517/19689109663_81ff6a8f9a_b.jpg 1024w" /></a></p>

<p>然後就開始想辦法生 patch 檔案了，中間也有用過 <code>hg mq</code>，最後都固定改好，commit 後用 <code>hg export . &gt; fix.patch</code>，總之改好我就丟上 bugzilla 了，結果第一個 patch 只改到一個檔案，實際上應該有五個檔案要改，而且才隔一天，Makefile 就被別人改過了，只好重新找位置修改，重新生 patch，到最後一個 review 過，build 也過的 patch 中間還發生了不少事情，包括 Makefile 被別人又改動一次，用 <code>AB</code> or <code>LPROJ</code> 的命名問題，字串的變化造成假翻譯又要增加，還有 build 工具 mach 被人改壞，和推上去之後有 build 失敗的狀況等等，非常的一波三折。</p>

<p>其中 build 失敗是 b2g 的 build 失敗，原因是我有地方改錯，不過要測試也是要重新設定，參考的是 <a href="https://developer.mozilla.org/en-US/Firefox_OS/Building_the_Firefox_OS_simulator">Building the Firefox OS Simulator</a> 這份文件，把 <code>.mozconfig</code> 改成：</p>

<pre><code>. "$topsrcdir/b2g/config/mozconfigs/common"

mk_add_options MOZ_OBJDIR=../build
mk_add_options MOZ_MAKE_FLAGS="-j9 -s"

ac_add_options --enable-application=b2g
ac_add_options --disable-libjpeg-turbo
</code></pre>

<p>重新 build 看能不能過。</p>

<p>改完產生的 patch 檔上傳到 bugzilla 時，要勾選 Content Type 是 patch，然後 review flag 設定成 <code>?</code>，選一個 reviewer，通常會有 mentor 來跟你說選誰好，我的情形是 <a href="http://blog.timc.idv.tw/">timdream</a> 在幫忙，接著就等 reviewer review，他 review 過的話， review flag 就會變成 <code>+</code>，然後就會收到一封「Congratulations on having your first patch approved」的信件，說了一些後續可以做的事情，接著要做的就是讓 patch 真的進去 repository，可以在票的 keyword 加上 <code>checkin-needed</code>，就會有機器人自己來把你的 patch check in 進 mozilla-inbound 這個 repository，然後丟上機器人自動編譯和測試，例如這個我 B2G build 失敗的<a href="https://treeherder.mozilla.org/#/jobs?repo=mozilla-inbound&amp;revision=b1b8616162b4">例子</a>，都過了就會進 mozilla-central，之後才<a href="https://wiki.mozilla.org/Tree_Rules">照順序</a>進 mozilla-aurora、mozilla-beta、mozilla-release，現在進去 mozilla-central 的大概要等 Firefox 42 才會上線了，應該是和 OSX 10.11 同時吧。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000846" baseName="webappsec">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-07-03</b:date>
				<b:time>23:13:21</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>webappsec</b:title>
			<b:content>
				<b:summary> 這幾天才注意到 W3C 的 Web Application Security Working Group，簡稱為 webappsec，專門負責安全相關的規範制訂，是 2011 年就成立的，算是很後知後覺吧，其實現在很多已經很廣為人知的 Web 安全機制都是出自他們之手，像是 CORS 和 CSP，然後他們現在也很跟的上潮流，把標準的制訂也移到 Github 上了，其實會發現這個 Github repo 是因為最近在看 fetch 的 spec，裡面多了蠻多內容，而且有不少引用到其它新標準的地方，然後看這看著就看到 webappsec 這邊，順便就看了一下，有幾個新草稿好像還蠻有趣的，想說可以介紹一下，不過這些東西大部分都還不能用就是了。 第一個是 Secure Contexts，這個新東西目的很簡單，就是判斷現在的連線狀況是否安全，以前的話，前端只能看是不是使用 https protocol 連線，不過 Secure Context 有比較多的判斷流程，例如用 SSL 就不會被當成是安全的，要 TLS 才會被認為是安全，如果不是...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/mujitra/15191563939/" title="Safety first. by MIKI Yoshihito (´･ω･), on Flickr"><img src="https://farm3.staticflickr.com/2948/15191563939_80db3b1c3c_b.jpg" width="1024" height="576" alt="Safety first." srcset="https://farm3.staticflickr.com/2948/15191563939_80db3b1c3c_b.jpg 1024w, https://farm3.staticflickr.com/2948/15191563939_42b2305e22_h.jpg 1600w" /></a></p>

<p>這幾天才注意到 W3C 的 Web Application Security Working Group，簡稱為 webappsec，專門負責安全相關的規範制訂，是 <a href="http://www.w3.org/2011/webappsec/">2011</a> 年就成立的，算是很後知後覺吧，其實現在很多已經很廣為人知的 Web 安全機制都是出自他們之手，像是 <a href="https://developer.mozilla.org/zh-TW/docs/HTTP/Access_control_CORS">CORS</a> 和 <a href="http://devco.re/blog/2014/04/08/security-issues-of-http-headers-2-content-security-policy/">CSP</a>，然後他們現在也很跟的上潮流，把標準的制訂也移到 <a href="https://github.com/w3c/WebAppSec">Github</a> 上了，其實會發現這個 Github repo 是因為最近在看 fetch 的 spec，裡面多了蠻多內容，而且有不少引用到其它新標準的地方，然後看這看著就看到 webappsec 這邊，順便就看了一下，有幾個新草稿好像還蠻有趣的，想說可以介紹一下，不過這些東西大部分都還不能用就是了。</p>

<p>第一個是 <a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/">Secure Contexts</a>，這個新東西目的很簡單，就是判斷現在的連線狀況是否安全，以前的話，前端只能看是不是使用 https protocol 連線，不過 Secure Context 有比較多的判斷流程，例如用 SSL 就不會被當成是安全的，要 TLS 才會被認為是安全，如果不是 TLS 連線則還會判斷連到哪裡，看看白名單黑名單之類的機制。</p>

<p>第二個是 <a href="https://w3c.github.io/webappsec/specs/credentialmanagement/">Credential Management</a>，主要是為了因應現在瀏覽器很多都有記下使用者填的表單資料，包括登入的表單，而這等於是把使用者某個網站的帳號密碼都記錄下來，不過其實瀏覽器要做這些功能也是會遇到很多問題，像是他要怎麼判斷現在的表單是登入表單，哪些欄位是帳號密碼，或是網站用不一樣的機制，例如 XHR 來登入，這樣瀏覽器如果無法知道是什麼機制，就無法替這些特殊機制的網站的使用者提供方便的功能，所以 webappsec 就提出 Credential Management 這個功能讓網站開發者可以透過設計好的介面來告訴瀏覽器他們的網站是怎樣登入的，然後可以儲存帳號密碼在瀏覽器端，之後提供 API 給 JavaScript 呼叫出來送到 Server 端驗證，不過說是呼叫出來，其實 JavaScript 也看不到密碼明碼，而只能直接送出 login 的 request：</p>

<pre><code>navigator.credentials.get({ "password": true }).then(
  function(credential) {
    if (!credential) {
      // The user either doesn't have credentials for this site, or
      // refused to share them. Insert some code here to show a basic
      // login form (or, ideally, do nothing, since this API should
      // really be progressive enhancement on top of an existing form).
      return;
    }
    if (credential.type == "password") {
      credential.send("https://example.com/loginEndpoint")
        .then(function (response) {
          // Notify the user that signin succeeded! Do amazing, signed-in things!
        });
    } else {
      // See the Federated Sign-in example
    }
  }
);
</code></pre>

<p>這是從 spec 內複製出來的 sample code，一個重點是，JavaScript 程式碼其實碰不到你的密碼，只能直接把 credential send 出去，其它也還支援像是 Facebook 那種第三方登入的設計，以及把 credential 存進 store 等等機制。</p>

<p>第三個是 <a href="https://w3c.github.io/webappsec/specs/subresourceintegrity/">Subresource Integrity</a>：</p>

<pre><code>&lt;script src="https://analytics-r-us.example.com/v1.0/include.js"
        integrity="sha256-Rj/9XDU7F6pNSX8yBddiCIIS+XKDTtdq0//No0MH0AE="
        crossorigin="anonymous"&gt;&lt;/script&gt;
</code></pre>

<p>這是個看範例馬上就能理解幹什麼用的，就是對網頁要用到的其它 resource 檔案包括：js、css 等加上驗證檔案正確性的 hash，為的是避免有第三方的檔案內容被惡意攻擊者修改過。</p>

<p>第四個是 <a href="https://w3c.github.io/webappsec/specs/upgrade/">Upgrade Insecure Requests</a>，這是唯一目前已經可以用的，為的是解決 mixed content 的問題，也就是有的網站可能最近才改為 HTTPS 連線，但是網站內部用到的一些內容還是寫死 URL 用 HTTP，這時候瀏覽器就會跳出說網頁內容可能不安全，然而，這些使用 HTTP 的檔案其實可能用 HTTPS 連線也找的到，像是 Flickr、TED 等都有支援 HTTPS 連線，而 Upgrade 就是跟瀏覽器說如果這些內容找得到 HTTPS 的就用 HTTPS 的，而不是只看寫死的 URL，目前 Chrome 43 已經開始支援了，有個線上 <a href="https://googlechrome.github.io/samples/csp-upgrade-insecure-requests/">demo</a> 可以看，設定方法可以透過 CSP header 加上 <code>upgrade-insecure-requests</code> 或是寫到 meta 標籤裡面（demo 用的）</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;
</code></pre>

<p>其實這個標準我一開始以為是類似 HSTS，是對現在開的網址本身做判斷是不是有 HTTPS 可供選擇，有的話就改用 HTTPS 連線，仔細看之後才發現是用來處理 mixed content ，可是又看一看發現也有一部份比較新的草稿有講到這個功能，目前討論的版本是用 header：</p>

<pre><code>HTTPS: 1
</code></pre>

<p>很簡潔不過還沒瀏覽器支援就是了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000842" baseName="aster-postcss">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-05-02</b:date>
				<b:time>11:35:38</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Aster 與 PostCSS</b:title>
			<b:content>
				<b:summary> 前端為了 performance 需求，把網站推上 server 時會需要把 JavaScript、CSS 之類的文字檔案合併和最小化，如果開發時寫的是 CoffeeScript 或是 SASS 之類的還需要先轉成 JavaScript 和 CSS 這些主流格式，要做這些動作其實第一個想到的是可以用 Makefile，優點是常見、各平台都有，不過寫起來並不像這幾年流行的 build tool 那樣直覺，而前端領域流行的主要是 Grunt 和 Gulp 這兩個，兩者之中我個人是比較喜歡後起的 Gulp，不過前陣子意外發現一個看起來超正確的 build tool，叫 aster，是 Ingvar Stepanyan 做的，他在 Zurich 的 Frontend Conference 2014 的演講算是比較大規模的發佈：...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17133620000/" title="台南 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7771/17133620000_64aac917c8_b.jpg" width="1024" height="683" alt="台南" srcset="https://farm8.staticflickr.com/7771/17133620000_64aac917c8_b.jpg 1024w, https://farm8.staticflickr.com/7771/17133620000_2536c112ef_h.jpg 1600w" /></a></p>

<p>前端為了 performance 需求，把網站推上 server 時會需要把 JavaScript、CSS 之類的文字檔案合併和最小化，如果開發時寫的是 CoffeeScript 或是 SASS 之類的還需要先轉成 JavaScript 和 CSS 這些主流格式，要做這些動作其實第一個想到的是可以用 Makefile，優點是常見、各平台都有，不過寫起來並不像這幾年流行的 build tool 那樣直覺，而前端領域流行的主要是 <a href="http://gruntjs.com/">Grunt</a> 和 <a href="http://gulpjs.com/">Gulp</a> 這兩個，兩者之中我個人是比較喜歡後起的 Gulp，不過前陣子意外發現一個看起來超正確的 build tool，叫 <a href="http://asterjs.github.io/aster/">aster</a>，是 Ingvar Stepanyan 做的，他在 Zurich 的 Frontend Conference 2014 的演講算是比較大規模的發佈：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/fF_jZ7ErwUY?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
</b:mainContent>
				<b:extendContent><p>Aster 這個名稱的來由是 AST，Aster 的特別之處就在於他所有的修改都是在 AST 上做修改：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17141309009/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7680/17141309009_fac4a51d86_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7680/17141309009_fac4a51d86_b.jpg 1024w, https://farm8.staticflickr.com/7680/17141309009_bbdc544510_h.jpg 1600w" /></a></p>

<p>相較於 Gulp：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17327152261/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7662/17327152261_6de37ae977_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7662/17327152261_6de37ae977_b.jpg 1024w, https://farm8.staticflickr.com/7662/17327152261_52b8bed2f1_h.jpg 1600w" /></a></p>

<p>和 Grunt：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17327152081/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7717/17327152081_7bd3f29f74_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7717/17327152081_7bd3f29f74_b.jpg 1024w, https://farm8.staticflickr.com/7717/17327152081_0d9d346ffc_h.jpg 1600w" /></a></p>

<p>很明顯的是正確許多的設計，理論上 parse 成 AST 之後，一口氣在 AST 階段把需要的變更做完，然後再用 code generator 產生成果的程式碼，應該省去很多來回轉換的工作，不論是效能還是程式碼處理的正確性都應該是最好的，不過這看似正確設計下的產品，卻沒什麼人用，我嘗試使用過程中還發了幾個 PR 回去，結果到現在都還沒有回應，有種是不是作者都已經放棄的疑問。</p>

<p>然後這兩天，又看到一個其實已經出來蠻久的 compile to CSS language，叫 <a href="https://github.com/postcss/postcss">PostCSS</a>，號稱比 SASS 之類的快上 3-30 倍，還可以做到一些 SASS/LESS 做不到功能，也有很多大企業採用，像是 Google、VK、Alibaba 之類的，應該就是目前最夯的 CSS 工具，然後我看介紹的投影片看到這張：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17301590026/" title="PostCSS by othree, on Flickr"><img src="https://farm8.staticflickr.com/7763/17301590026_184c69e66f_b.jpg" width="1024" height="638" alt="PostCSS" srcset="https://farm8.staticflickr.com/7763/17301590026_184c69e66f_b.jpg 1024w, https://farm8.staticflickr.com/7763/17301590026_3ebc26bdb7_h.jpg 1600w" /></a></p>

<p>覺得，這根本和 Aster 是一樣的想法，不過一個處理 JavaScript，做 ES6 to ES5、concat、minimize 甚至是細微的程式碼修改，另外一個處理 CSS，也是做類似的工作，為什麼結果發展的差距會這麼大？想了一陣子之後，我覺得大概狀況是，SASS、LESS 之類的工具目前還是會造成一些讓開發者痛苦的問題，像是 nesting rule 讓 selector 太長太複雜、mixin 和 include 的混淆等等，所以開發者還會一直嘗試不同的新工具，甚至自己開發來解決這些問題，而相對於 CSS，JavaScript 的相關工具比較沒這些問題，二來 JavaScript 的 AST 比 CSS 的 AST 要複雜許多，要參與工具的開發難度是高上許多，Aster 作者的功力還蠻強的，除了 AST 操作之外，他的整個流程控制還用上很先進的 <a href="https://rxjs.codeplex.com/">RxJS</a>，其實也算是增加了參與的難度吧，而我想就是這沒有強烈需求加上進入難度高兩點，結果讓 Aster 並不太受到人注意，沒什麼人參與，開發的完整度不夠，我實際用起來，就覺得目前還只是核心完整，但是真的要離實用到專案上還有些距離，加上不知道還有沒有要繼續發展下去，覺得實在很可惜。</p>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000837" baseName="for-the-entire-web">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-03-28</b:date>
				<b:time>13:25:25</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>For the Entire Web</b:title>
			<b:content>
				<b:summary>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實本質上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 React Is A Terrible Idea，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。 再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和...</b:summary>
				<b:mainContent><p>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實本質上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 <a href="https://www.pandastrike.com/posts/20150311-react-bad-idea">React Is A Terrible Idea</a>，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。</p>

<p>再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和 Web Component 合作，還附上 ng-conf 的<a href="https://www.youtube.com/watch?v=g0TD0efcwVg">演講影片</a>，我到覺得他們也完全沒搞清楚作者的重點在哪裡；提到 Flipboard 的 <a href="https://github.com/flipboard/react-canvas">react-canvas</a> 那部分算是我認為最能表現出作者想要講什麼的，作者想說的重點是現在的網路環境有限制、有問題，但是遇到時不要用一些旁門左道的方法來處理，因為這些問題終究會被解決，而問題被解決時，你之前所花的時間和資源就等於是完全浪費掉，與其要浪費在走旁門左道，還不如把這些時間和資源用在從正確的地方解決這個問題，而最後受惠的不只是自己，還有所有網際網路的開發者、使用者，這是從一個很高等生命體的角度來看事情，就如同這篇文章的標題：「For the Entire Web」，要你犧牲自己的部分利益去成就整體網際網路的利益，當然這是有些理想化，很多商業公司可能要短時間就有產品出來，不太可能所有的開發在遇到問題時都停下來等瀏覽器或是標準齊備，但是對於不少的大型企業，我就覺得他們確實應該要好好正確的回饋網路環境來解決這些問題，像是文中提到 Facebook，還有接下來要說的 Google，不過他說 Facebook 是為了和 Google 競爭才開發 React 之類的論點我就不予評論了，太多臆測～</p>

<p>可能有人會說，有沒有這些資源的投入應該差距也不大吧，最近就剛好有另外一件事情可以佐證，<a href="http://news.dartlang.org/2015/03/dart-for-entire-web.html">Dart for the Entire Web</a> 這篇 Dart 官方的公告說到，Dart VM 將不會進入到 Chrome 裡面，也就是說要在瀏覽器上跑 Dart，將還是只有轉成 JavaScript 這個選項，這件事其實是蠻大的一件事，上一個在網頁裡面跑的另外一種語言是微軟的 VBScript，最大的問題不在於好不好寫，而是在於他被單一企業把持，不過後來結果大家也都知道，所以當 Google 推出 Dart 而且說以後 Chrome 會可以直接跑 Dart 的時候，我想大部分人都是都不看好的，甚至部分人是覺得 Google 怎麼做微軟做過的蠢事。而剛好在這個官方公告出來後幾天內，Brendan Eich 在 Hacker News 上回應一串討論<a href="https://news.ycombinator.com/item?id=9269355">回應</a>的蠻激動的，這串本來是在說 ECMAScript 新版本有很多東西根本是從 Dart 來的，Brendan Eich 則是反駁說很多東西在 Dart 出來前就已經在討論有 Proposal 了，然後到後來寫了一篇幾乎都在抱怨 Dart，還提到 V8 team reset 的事情，從這邊看起來，似乎是因為新的 V8 team 不打算作 Dart VM 進去，才有了 Dart 那篇公告；而 Brendan Eich 抱怨的重點，其實就是前面那段提到的，Google 花了超多人力資源去搞 Dart，而不是來幫忙改進既有的 ECMAScript，而這確實有實際的影響，他舉了一個例子，就是大數(<a href="http://wiki.ecmascript.org/doku.php?id=strawman:bignums">bignums</a>)的支援，Dart 有支援，在 ES 這邊目前有一點可能性會在 ES7(2016) 中出來，但這東西其實從 2010 就已經開始有討論了，如果有人來將這些討論規格化，並實做起來，那大數應該在現在的 ES6(2015) 就有了。</p>

<p>最後再回到 Terriable Idea 這篇文章，我雖然不完全認同他對 React 的看法，但是我認為他的重點沒錯，如果他拿 Dart 出來講可能就不會引出這麼多砲火吧（可是可能也比較沒人注意），其實 react-canvas 我覺得也是很有趣的實驗，不過做成正式產品上線就是另外一回事了，最大的問題，他為了終會被解決的次要問題（畫面不流暢）完全放棄了親和力的問題，而 Flipboard 這種內容為主的產品性質是不該放棄親和力的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000831" baseName="accessibility-before-been-blind">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-01-31</b:date>
				<b:time>18:58:52</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>在盲人之前的親和力</b:title>
			<b:content>
				<b:summary>不少人還會直接把網站的親和力（無障礙）問題和盲人朋友直接連在一起，覺得應該來解除迷思一下，盲人朋友確實是最直接會想到的，各種有身心障礙人士的族群當中，盲人朋友使用電腦上網的難度也是最高的，不過在你把眼睛矇起來體驗盲人如何操作電腦之前，有不少事情是可以先做的，隨便把腦袋裡馬上想的到的列了一下： 首先是網頁的文字內容易讀性，易讀性有分兩個面向，第一個面向大家比較清楚，就是文字排版、字形挑選、顏色對比等等視覺上的易讀程度，這部分做的好的話除了對老花眼、近視或是弱視的朋友有幫助外，一般人也會受惠；另一個面向則是文字內容好不好理解的程度，如果網站上的文字說明太難懂，那就應該要用更好理解的文字來重新講一遍，或是加上圖表輔助，或是乾脆減少資訊量，通常自己看的懂，不代表別人看的懂，所以如果是重要的說明（尤其是政府網站一些流程、辦理辦法之類的），建議都要找人看過，最簡單的是找家中長輩，因為網路上理解力較低的族群中，長輩們佔不少。 第二個是操作介面好不好操作，通常是 Web App 才有這需求，一樣有不同的面向，第一個是你的操作介面應該設計的容易理解，讓人看了也不會疑惑應該點哪裡，其中一個很重要的原則是不要破壞使用者的習慣，第二個面向是有些人可能無法好好的控制滑鼠（要模擬這個比模擬盲人的情境還要難），點擊不精確，所以永遠要保留鍵盤操作的選項，如果是使用原生的輸入元件來做操作介面的話，沒有亂做什麼奇怪的事情應該是都可以用鍵盤來控制，但是如果要自己設計一個嶄新的控制元件，那記得要好好利用 WAI-ARIA 來讓鍵盤可以順利的控制，像是 Google 的 Gmail 就有完整的鍵盤操作支援，這個應該是這篇文章當中做起來最辛苦的一項吧。 第三個是表單行為，要把表單作的好填，本身是一門很大的學問，不過在深入的思考設計表單的 usability 之前，有一些很基本的功能是應該具備的，其中特別想說的是錯誤訊息的處理，使用者送出表單後，如果後端的檢查沒過被打回來，應該要伴隨著能幫助使用者更新資料的錯誤訊息，並且正確的顯示在正確的位置，不然使用者不知道發生什麼事情，除了告訴使用者哪裡有錯之外，更進一步是讓使用者能把輸入資料改好，例如帳號名稱有格式限制的話，就要明確的說明有哪些限制，另外表單檢查不通過之後，記得也不要把使用者剛剛填的資料清空（實做這點還需要特別記得安全性問題）。 最後一個是文件結構，正確的使用 HTML 標籤，還可以輔以 WAI-ARIA 的 role 屬性，這已經是講到爛的項目了，當然 single page application 算是特殊情形，不過只要你做的頁面還是接近傳統網頁有文字內容，有主要內容的話，把網頁的文件結構弄好還是有兩大好處的：一、SEO 的部分已經好了一大半了；二、所有輔具都可以根據你的文件結構快速的帶領使用者在文件中穿梭，不用多做什麼奇怪的導盲機制。要把這塊做好算是四點當中最簡單的，只要正確的依照語意使用 HTML 標籤，不夠的再看看 WAI-ARIA 有沒有可用的 role，不要亂用標籤，然後用檢視原始碼的功能看看好不好看，如果你能開始從 HTML 原始碼中感受到美感甚至有完美的感覺出來，相信你就在正確的方向上了。 其實以上四點都有一個特色，就是把這些地方做好，不只是身心障礙人士會受惠，文字易讀性就不用說了，操控介面如果支援鍵盤，有些正常人操作起來會更得心應手，表單的訊息也是不論是怎樣的使用者都很需要，而文件結構也是，弄得好的話，大家都好找到資料，站長應該也開心。所以其實在你想要為了提升親和力而去實際模擬身心障礙人士使用電腦的情境之前，是有很多東西是可以先做的， 相信還是有人會有興趣盲人朋友怎麼操控電腦的，曾經 HappyDesigner 有邀請有聲書協會的朋友來介紹，不過已經有點久了，我去年初剛好有機會在 Moztw Lab...</b:summary>
				<b:mainContent><p>不少人還會直接把網站的親和力（無障礙）問題和盲人朋友直接連在一起，覺得應該來解除迷思一下，盲人朋友確實是最直接會想到的，各種有身心障礙人士的族群當中，盲人朋友使用電腦上網的難度也是最高的，不過在你把眼睛矇起來體驗盲人如何操作電腦之前，有不少事情是可以先做的，隨便把腦袋裡馬上想的到的列了一下：</p>

<p>首先是網頁的文字內容易讀性，易讀性有分兩個面向，第一個面向大家比較清楚，就是文字排版、字形挑選、顏色對比等等視覺上的易讀程度，這部分做的好的話除了對老花眼、近視或是弱視的朋友有幫助外，一般人也會受惠；另一個面向則是文字內容好不好理解的程度，如果網站上的文字說明太難懂，那就應該要用更好理解的文字來重新講一遍，或是加上圖表輔助，或是乾脆減少資訊量，通常自己看的懂，不代表別人看的懂，所以如果是重要的說明（尤其是政府網站一些流程、辦理辦法之類的），建議都要找人看過，最簡單的是找家中長輩，因為網路上理解力較低的族群中，長輩們佔不少。</p>

<p>第二個是操作介面好不好操作，通常是 Web App 才有這需求，一樣有不同的面向，第一個是你的操作介面應該設計的容易理解，讓人看了也不會疑惑應該點哪裡，其中一個很重要的原則是不要破壞使用者的習慣，第二個面向是有些人可能無法好好的控制滑鼠（要模擬這個比模擬盲人的情境還要難），點擊不精確，所以永遠要保留鍵盤操作的選項，如果是使用原生的輸入元件來做操作介面的話，沒有亂做什麼奇怪的事情應該是都可以用鍵盤來控制，但是如果要自己設計一個嶄新的控制元件，那記得要好好利用 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA">WAI-ARIA</a> 來讓鍵盤可以順利的控制，像是 Google 的 Gmail 就有完整的鍵盤操作支援，這個應該是這篇文章當中做起來最辛苦的一項吧。</p>

<p>第三個是表單行為，要把表單作的好填，本身是一門很大的學問，不過在深入的思考設計表單的 usability 之前，有一些很基本的功能是應該具備的，其中特別想說的是錯誤訊息的處理，使用者送出表單後，如果後端的檢查沒過被打回來，應該要伴隨著能幫助使用者更新資料的錯誤訊息，並且正確的顯示在正確的位置，不然使用者不知道發生什麼事情，除了告訴使用者哪裡有錯之外，更進一步是讓使用者能把輸入資料改好，例如帳號名稱有格式限制的話，就要明確的說明有哪些限制，另外表單檢查不通過之後，記得也不要把使用者剛剛填的資料清空（實做這點還需要特別記得安全性問題）。</p>

<p>最後一個是文件結構，正確的使用 HTML 標籤，還可以輔以 WAI-ARIA 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">role</a> 屬性，這已經是講到爛的項目了，當然 single page application 算是特殊情形，不過只要你做的頁面還是接近傳統網頁有文字內容，有主要內容的話，把網頁的文件結構弄好還是有兩大好處的：一、SEO 的部分已經好了一大半了；二、所有輔具都可以根據你的文件結構快速的帶領使用者在文件中穿梭，不用多做什麼奇怪的導盲機制。要把這塊做好算是四點當中最簡單的，只要正確的依照語意使用 HTML 標籤，不夠的再看看 WAI-ARIA 有沒有可用的 role，不要亂用標籤，然後用檢視原始碼的功能看看好不好看，如果你能開始從 HTML 原始碼中感受到美感甚至有完美的感覺出來，相信你就在正確的方向上了。</p>

<p>其實以上四點都有一個特色，就是把這些地方做好，不只是身心障礙人士會受惠，文字易讀性就不用說了，操控介面如果支援鍵盤，有些正常人操作起來會更得心應手，表單的訊息也是不論是怎樣的使用者都很需要，而文件結構也是，弄得好的話，大家都好找到資料，站長應該也開心。所以其實在你想要為了提升親和力而去實際模擬身心障礙人士使用電腦的情境之前，是有很多東西是可以先做的，</p>

<p>相信還是有人會有興趣盲人朋友怎麼操控電腦的，曾經 HappyDesigner 有邀請有聲書協會的朋友來介紹，不過已經有點久了，我去年初剛好有機會在 Moztw Lab 遇到 Fancy 示範，當時有簡單的錄下來，有興趣的朋友可以看一下：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/fV2ufa2galY?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<p>至於要怎麼體驗盲人怎麼操作呢？如果你是用 OSX 的話，系統有內建 Voice Over，品質很好，可以直接使用，Windows 有好幾套商業軟體，至於免費的比較有名的是 <a href="http://www.nvaccess.org/">NVDA</a>，這套也是開源軟體，一開始可能需要先當明眼人練習操作，另外它講的話一開始可能會聽不太懂，聲音合成引擎和商業軟體比起來有差，多聽幾次慢慢就聽的出來再講什麼了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000826" baseName="android-l-webview-fullscreen-api">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-01-05</b:date>
				<b:time>21:20:32</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Android L WebView Fullscreen API</b:title>
			<b:content>
				<b:summary>今天遇到一個問題是，本來好好的全螢幕影片播放功能，到了 Android L 的 Facebook App 裡的 webview 瀏覽器就壞掉了，而且透過開發工具看沒有錯誤訊息出來，查了一陣子終於發現，最新的 webview 改成使用 Chrome 核心後，有些 API 雖然 Chrome 有支援，但是在 WebView 裡面是沒開啟的。 其實我本來已經有用 feature detection 的寫法了，不過這個情形實際上，requestFullscreen 是找的到，可以執行，也不會有錯誤的，只是就是什麼事情都不會發生，後來才 發現 是要用 document.fullscreenEnabled 來做判斷，這個東西我之前一直覺得在手機上都用不到的東西（桌面瀏覽器通常會先問使用者是否願意讓網頁進入全螢幕），沒想到會在這邊派上用場啊。...</b:summary>
				<b:mainContent><p>今天遇到一個問題是，本來好好的全螢幕影片播放功能，到了 Android L 的 Facebook App 裡的 webview 瀏覽器就壞掉了，而且透過開發工具看沒有錯誤訊息出來，查了一陣子終於發現，最新的 webview 改成使用 Chrome 核心後，有些 API 雖然 Chrome 有支援，但是在 WebView 裡面是<a href="https://developer.chrome.com/multidevice/webview/overview#does_the_new_webview_have_feature_parity_with_chrome_for_android_">沒開啟</a>的。</p>

<p>其實我本來已經有用 feature detection 的寫法了，不過這個情形實際上，<code>requestFullscreen</code> 是找的到，可以執行，也不會有錯誤的，只是就是什麼事情都不會發生，後來才 <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode#Other_information">發現</a> 是要用 <code>document.fullscreenEnabled</code> 來做判斷，這個東西我之前一直覺得在手機上都用不到的東西（桌面瀏覽器通常會先問使用者是否願意讓網頁進入全螢幕），沒想到會在這邊派上用場啊。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000815" baseName="ie-video">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-10-24</b:date>
				<b:time>12:01:15</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>IE video 標籤記憶體問題</b:title>
			<b:content>
				<b:summary>最近遇到一個 IE 會 crash 的問題，找很久才發現是記憶體問題，然後因為那頁有用到大量的 &lt;video&gt; 標籤，所以就直接鎖定目標，結果發現果然 video 就是問題元兇，測試到 IE 11 還是同樣行為。 目前發現的問題有兩層，第一層問題是如果 IE 在遇到 video 沒有設定 poster 時，會自動初始化整個 video 元件，去把影片抓下來，只為了產生 poster 圖片，第二層問題，就是這個初始化 video 元件的動作，會吃掉很多的記憶體，即使我的影片只有五百多kb，IE 還是一個 video 就吃掉數十 mb 的記憶體，即使這些 video 都沒有播放，甚至還用 CSS 藏起來了，然後因為一個頁面上有很多的影片輪流播放，所以把記憶體吃光後就當掉了。 要解決這個問題，一開始是想說設定正確的 poster 圖片就好了，確實解決了第一層的問題，但是因為影片還是會輪撥，遲早會把記憶體吃光，所以試了幾個方法想要避免這種情形，像是把 dom node detach...</b:summary>
				<b:mainContent><p>最近遇到一個 IE 會 crash 的問題，找很久才發現是記憶體問題，然後因為那頁有用到大量的 <code>&lt;video&gt;</code> 標籤，所以就直接鎖定目標，結果發現果然 video 就是問題元兇，測試到 IE 11 還是同樣行為。</p>

<p>目前發現的問題有兩層，第一層問題是如果 IE 在遇到 video 沒有設定 poster 時，會自動初始化整個 video 元件，去把影片抓下來，只為了產生 poster 圖片，第二層問題，就是這個初始化 video 元件的動作，會吃掉很多的記憶體，即使我的影片只有五百多kb，IE 還是一個 video 就吃掉數十 mb 的記憶體，即使這些 video 都沒有播放，甚至還用 CSS 藏起來了，然後因為一個頁面上有很多的影片輪流播放，所以把記憶體吃光後就當掉了。</p>

<p>要解決這個問題，一開始是想說設定正確的 poster 圖片就好了，確實解決了第一層的問題，但是因為影片還是會輪撥，遲早會把記憶體吃光，所以試了幾個方法想要避免這種情形，像是把 dom node detach 甚至砍掉之類的，不過都沒有效果，吃掉的記憶體不會還回來，最後只好讓 IE 不做輪撥了。</p>

<p>這個問題我看 stackoverflow 好像也沒有，看來在單一頁面上放很多 video 的使用情形真是很少見啊。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
