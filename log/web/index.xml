<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>c</b:listType>
			<b:listData listID="web">web</b:listData>
		</b:entriesMeta>

		<b:entry entryID="000846" baseName="webappsec">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-07-03</b:date>
				<b:time>23:13:21</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>webappsec</b:title>
			<b:content>
				<b:summary> 這幾天才注意到 W3C 的 Web Application Security Working Group，簡稱為 webappsec，專門負責安全相關的規範制訂，是 2011 年就成立的，算是很後知後覺吧，其實現在很多已經很廣為人知的 Web 安全機制都是出自他們之手，像是 CORS 和 CSP，然後他們現在也很跟的上潮流，把標準的制訂也移到 Github 上了，其實會發現這個 Github repo 是因為最近在看 fetch 的 spec，裡面多了蠻多內容，而且有不少引用到其它新標準的地方，然後看這看著就看到 webappsec 這邊，順便就看了一下，有幾個新草稿好像還蠻有趣的，想說可以介紹一下，不過這些東西大部分都還不能用就是了。 第一個是 Secure Contexts，這個新東西目的很簡單，就是判斷現在的連線狀況是否安全，以前的話，前端只能看是不是使用 https protocol 連線，不過 Secure Context 有比較多的判斷流程，例如用 SSL 就不會被當成是安全的，要 TLS 才會被認為是安全，如果不是...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/mujitra/15191563939/" title="Safety first. by MIKI Yoshihito (´･ω･), on Flickr"><img src="https://farm3.staticflickr.com/2948/15191563939_80db3b1c3c_b.jpg" width="1024" height="576" alt="Safety first." srcset="https://farm3.staticflickr.com/2948/15191563939_80db3b1c3c.jpg 768w, https://farm3.staticflickr.com/2948/15191563939_771f265d3a_k.jpg 2x" /></a></p>

<p>這幾天才注意到 W3C 的 Web Application Security Working Group，簡稱為 webappsec，專門負責安全相關的規範制訂，是 <a href="http://www.w3.org/2011/webappsec/">2011</a> 年就成立的，算是很後知後覺吧，其實現在很多已經很廣為人知的 Web 安全機制都是出自他們之手，像是 <a href="https://developer.mozilla.org/zh-TW/docs/HTTP/Access_control_CORS">CORS</a> 和 <a href="http://devco.re/blog/2014/04/08/security-issues-of-http-headers-2-content-security-policy/">CSP</a>，然後他們現在也很跟的上潮流，把標準的制訂也移到 <a href="https://github.com/w3c/WebAppSec">Github</a> 上了，其實會發現這個 Github repo 是因為最近在看 fetch 的 spec，裡面多了蠻多內容，而且有不少引用到其它新標準的地方，然後看這看著就看到 webappsec 這邊，順便就看了一下，有幾個新草稿好像還蠻有趣的，想說可以介紹一下，不過這些東西大部分都還不能用就是了。</p>

<p>第一個是 <a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/">Secure Contexts</a>，這個新東西目的很簡單，就是判斷現在的連線狀況是否安全，以前的話，前端只能看是不是使用 https protocol 連線，不過 Secure Context 有比較多的判斷流程，例如用 SSL 就不會被當成是安全的，要 TLS 才會被認為是安全，如果不是 TLS 連線則還會判斷連到哪裡，看看白名單黑名單之類的機制。</p>

<p>第二個是 <a href="https://w3c.github.io/webappsec/specs/credentialmanagement/">Credential Management</a>，主要是為了因應現在瀏覽器很多都有記下使用者填的表單資料，包括登入的表單，而這等於是把使用者某個網站的帳號密碼都記錄下來，不過其實瀏覽器要做這些功能也是會遇到很多問題，像是他要怎麼判斷現在的表單是登入表單，哪些欄位是帳號密碼，或是網站用不一樣的機制，例如 XHR 來登入，這樣瀏覽器如果無法知道是什麼機制，就無法替這些特殊機制的網站的使用者提供方便的功能，所以 webappsec 就提出 Credential Management 這個功能讓網站開發者可以透過設計好的介面來告訴瀏覽器他們的網站是怎樣登入的，然後可以儲存帳號密碼在瀏覽器端，之後提供 API 給 JavaScript 呼叫出來送到 Server 端驗證，不過說是呼叫出來，其實 JavaScript 也看不到密碼明碼，而只能直接送出 login 的 request：</p>

<pre><code>navigator.credentials.get({ "password": true }).then(
  function(credential) {
    if (!credential) {
      // The user either doesn't have credentials for this site, or
      // refused to share them. Insert some code here to show a basic
      // login form (or, ideally, do nothing, since this API should
      // really be progressive enhancement on top of an existing form).
      return;
    }
    if (credential.type == "password") {
      credential.send("https://example.com/loginEndpoint")
        .then(function (response) {
          // Notify the user that signin succeeded! Do amazing, signed-in things!
        });
    } else {
      // See the Federated Sign-in example
    }
  }
);
</code></pre>

<p>這是從 spec 內複製出來的 sample code，一個重點是，JavaScript 程式碼其實碰不到你的密碼，只能直接把 credential send 出去，其它也還支援像是 Facebook 那種第三方登入的設計，以及把 credential 存進 store 等等機制。</p>

<p>第三個是 <a href="https://w3c.github.io/webappsec/specs/subresourceintegrity/">Subresource Integrity</a>：</p>

<pre><code>&lt;script src="https://analytics-r-us.example.com/v1.0/include.js"
        integrity="sha256-Rj/9XDU7F6pNSX8yBddiCIIS+XKDTtdq0//No0MH0AE="
        crossorigin="anonymous"&gt;&lt;/script&gt;
</code></pre>

<p>這是個看範例馬上就能理解幹什麼用的，就是對網頁要用到的其它 resource 檔案包括：js、css 等加上驗證檔案正確性的 hash，為的是避免有第三方的檔案內容被惡意攻擊者修改過。</p>

<p>第四個是 <a href="https://w3c.github.io/webappsec/specs/upgrade/">Upgrade Insecure Requests</a>，這是唯一目前已經可以用的，為的是解決 mixed content 的問題，也就是有的網站可能最近才改為 HTTPS 連線，但是網站內部用到的一些內容還是寫死 URL 用 HTTP，這時候瀏覽器就會跳出說網頁內容可能不安全，然而，這些使用 HTTP 的檔案其實可能用 HTTPS 連線也找的到，像是 Flickr、TED 等都有支援 HTTPS 連線，而 Upgrade 就是跟瀏覽器說如果這些內容找得到 HTTPS 的就用 HTTPS 的，而不是指看寫死的 URL，目前 Chrome 43 已經開始支援了，有個線上 <a href="https://googlechrome.github.io/samples/csp-upgrade-insecure-requests/">demo</a> 可以看，設定方法可以透過 CSP header 加上 <code>upgrade-insecure-requests</code> 或是寫到 meta 標籤裡面（demo 用的）</p>

<pre><code>&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;
</code></pre>

<p>其實這個標準我一開始以為是類似 HSTS，是對現在開的網址本身做判斷是不是有 HTTPS 可供選擇，有的話就改用 HTTPS 連線，仔細看之後才發現是用來處理 mixed content ，可是又看一看發現也有一部份比較新的草稿有講到這個功能，目前討論的版本是用 header：</p>

<pre><code>HTTPS: 1
</code></pre>

<p>很簡潔不過還沒瀏覽器支援就是了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000842" baseName="aster-postcss">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-05-02</b:date>
				<b:time>11:35:38</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Aster 與 PostCSS</b:title>
			<b:content>
				<b:summary> 前端為了 performance 需求，把網站推上 server 時會需要把 JavaScript、CSS 之類的文字檔案合併和最小化，如果開發時寫的是 CoffeeScript 或是 SASS 之類的還需要先轉成 JavaScript 和 CSS 這些主流格式，要做這些動作其實第一個想到的是可以用 Makefile，優點是常見、各平台都有，不過寫起來並不像這幾年流行的 build tool 那樣直覺，而前端領域流行的主要是 Grunt 和 Gulp 這兩個，兩者之中我個人是比較喜歡後起的 Gulp，不過前陣子意外發現一個看起來超正確的 build tool，叫 aster，是 Ingvar Stepanyan 做的，他在 Zurich 的 Frontend Conference 2014 的演講算是比較大規模的發佈：...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17133620000/" title="台南 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7771/17133620000_64aac917c8_b.jpg" width="1024" height="683" alt="台南" srcset="https://farm8.staticflickr.com/7771/17133620000_64aac917c8.jpg 768w, https://farm8.staticflickr.com/7771/17133620000_3c43ee797f_k.jpg 2x" /></a></p>

<p>前端為了 performance 需求，把網站推上 server 時會需要把 JavaScript、CSS 之類的文字檔案合併和最小化，如果開發時寫的是 CoffeeScript 或是 SASS 之類的還需要先轉成 JavaScript 和 CSS 這些主流格式，要做這些動作其實第一個想到的是可以用 Makefile，優點是常見、各平台都有，不過寫起來並不像這幾年流行的 build tool 那樣直覺，而前端領域流行的主要是 <a href="http://gruntjs.com/">Grunt</a> 和 <a href="http://gulpjs.com/">Gulp</a> 這兩個，兩者之中我個人是比較喜歡後起的 Gulp，不過前陣子意外發現一個看起來超正確的 build tool，叫 <a href="http://asterjs.github.io/aster/">aster</a>，是 Ingvar Stepanyan 做的，他在 Zurich 的 Frontend Conference 2014 的演講算是比較大規模的發佈：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/fF_jZ7ErwUY?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
</b:mainContent>
				<b:extendContent><p>Aster 這個名稱的來由是 AST，Aster 的特別之處就在於他所有的修改都是在 AST 上做修改：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17141309009/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7680/17141309009_fac4a51d86_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7680/17141309009_fac4a51d86.jpg 768w, https://farm8.staticflickr.com/7680/17141309009_9f903156ca_k.jpg 2x" /></a></p>

<p>相較於 Gulp：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17327152261/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7662/17327152261_6de37ae977_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7662/17327152261_6de37ae977.jpg 768w, https://farm8.staticflickr.com/7662/17327152261_ac75e48905_k.jpg 2x" /></a></p>

<p>和 Grunt：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17327152081/" title="Aster by othree, on Flickr"><img src="https://farm8.staticflickr.com/7717/17327152081_7bd3f29f74_b.jpg" width="1024" height="640" alt="Aster" srcset="https://farm8.staticflickr.com/7717/17327152081_7bd3f29f74.jpg 768w, https://farm8.staticflickr.com/7717/17327152081_04e77878ff_k.jpg 2x" /></a></p>

<p>很明顯的是正確許多的設計，理論上 parse 成 AST 之後，一口氣在 AST 階段把需要的變更做完，然後再用 code generator 產生成果的程式碼，應該省去很多來回轉換的工作，不論是效能還是程式碼處理的正確性都應該是最好的，不過這看似正確設計下的產品，卻沒什麼人用，我嘗試使用過程中還發了幾個 PR 回去，結果到現在都還沒有回應，有種是不是作者都已經放棄的疑問。</p>

<p>然後這兩天，又看到一個其實已經出來蠻久的 compile to CSS language，叫 <a href="https://github.com/postcss/postcss">PostCSS</a>，號稱比 SASS 之類的快上 3-30 倍，還可以做到一些 SASS/LESS 做不到功能，也有很多大企業採用，像是 Google、VK、Alibaba 之類的，應該就是目前最夯的 CSS 工具，然後我看介紹的投影片看到這張：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/17301590026/" title="PostCSS by othree, on Flickr"><img src="https://farm8.staticflickr.com/7763/17301590026_184c69e66f_b.jpg" width="1024" height="638" alt="PostCSS" srcset="https://farm8.staticflickr.com/7763/17301590026_184c69e66f.jpg 768w" /></a></p>

<p>覺得，這根本和 Aster 是一樣的想法，不過一個處理 JavaScript，做 ES6 to ES5、concat、minimize 甚至是細微的程式碼修改，另外一個處理 CSS，也是做類似的工作，為什麼結果發展的差距會這麼大？想了一陣子之後，我覺得大概狀況是，SASS、LESS 之類的工具目前還是會造成一些讓開發者痛苦的問題，像是 nesting rule 讓 selector 太長太複雜、mixin 和 include 的混淆等等，所以開發者還會一直嘗試不同的新工具，甚至自己開發來解決這些問題，而相對於 CSS，JavaScript 的相關工具比較沒這些問題，二來 JavaScript 的 AST 比 CSS 的 AST 要複雜許多，要參與工具的開發難度是高上許多，Aster 作者的功力還蠻強的，除了 AST 操作之外，他的整個流程控制還用上很先進的 <a href="https://rxjs.codeplex.com/">RxJS</a>，其實也算是增加了參與的難度吧，而我想就是這沒有強烈需求加上進入難度高兩點，結果讓 Aster 並不太受到人注意，沒什麼人參與，開發的完整度不夠，我實際用起來，就覺得目前還只是核心完整，但是真的要離實用到專案上還有些距離，加上不知道還有沒有要繼續發展下去，覺得實在很可惜。</p>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000837" baseName="for-the-entire-web">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-03-28</b:date>
				<b:time>13:25:25</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>For the Entire Web</b:title>
			<b:content>
				<b:summary>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實本質上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 React Is A Terrible Idea，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。 再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和...</b:summary>
				<b:mainContent><p>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實本質上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 <a href="https://www.pandastrike.com/posts/20150311-react-bad-idea">React Is A Terrible Idea</a>，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。</p>

<p>再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和 Web Component 合作，還附上 ng-conf 的<a href="https://www.youtube.com/watch?v=g0TD0efcwVg">演講影片</a>，我到覺得他們也完全沒搞清楚作者的重點在哪裡；提到 Flipboard 的 <a href="https://github.com/flipboard/react-canvas">react-canvas</a> 那部分算是我認為最能表現出作者想要講什麼的，作者想說的重點是現在的網路環境有限制、有問題，但是遇到時不要用一些旁門左道的方法來處理，因為這些問題終究會被解決，而問題被解決時，你之前所花的時間和資源就等於是完全浪費掉，與其要浪費在走旁門左道，還不如把這些時間和資源用在從正確的地方解決這個問題，而最後受惠的不只是自己，還有所有網際網路的開發者、使用者，這是從一個很高等生命體的角度來看事情，就如同這篇文章的標題：「For the Entire Web」，要你犧牲自己的部分利益去成就整體網際網路的利益，當然這是有些理想化，很多商業公司可能要短時間就有產品出來，不太可能所有的開發在遇到問題時都停下來等瀏覽器或是標準齊備，但是對於不少的大型企業，我就覺得他們確實應該要好好正確的回饋網路環境來解決這些問題，像是文中提到 Facebook，還有接下來要說的 Google，不過他說 Facebook 是為了和 Google 競爭才開發 React 之類的論點我就不予評論了，太多臆測～</p>

<p>可能有人會說，有沒有這些資源的投入應該差距也不大吧，最近就剛好有另外一件事情可以佐證，<a href="http://news.dartlang.org/2015/03/dart-for-entire-web.html">Dart for the Entire Web</a> 這篇 Dart 官方的公告說到，Dart VM 將不會進入到 Chrome 裡面，也就是說要在瀏覽器上跑 Dart，將還是只有轉成 JavaScript 這個選項，這件事其實是蠻大的一件事，上一個在網頁裡面跑的另外一種語言是微軟的 VBScript，最大的問題不在於好不好寫，而是在於他被單一企業把持，不過後來結果大家也都知道，所以當 Google 推出 Dart 而且說以後 Chrome 會可以直接跑 Dart 的時候，我想大部分人都是都不看好的，甚至部分人是覺得 Google 怎麼做微軟做過的蠢事。而剛好在這個官方公告出來後幾天內，Brendan Eich 在 Hacker News 上回應一串討論<a href="https://news.ycombinator.com/item?id=9269355">回應</a>的蠻激動的，這串本來是在說 ECMAScript 新版本有很多東西根本是從 Dart 來的，Brendan Eich 則是反駁說很多東西在 Dart 出來前就已經在討論有 Proposal 了，然後到後來寫了一篇幾乎都在抱怨 Dart，還提到 V8 team reset 的事情，從這邊看起來，似乎是因為新的 V8 team 不打算作 Dart VM 進去，才有了 Dart 那篇公告；而 Brendan Eich 抱怨的重點，其實就是前面那段提到的，Google 花了超多人力資源去搞 Dart，而不是來幫忙改進既有的 ECMAScript，而這確實有實際的影響，他舉了一個例子，就是大數(<a href="http://wiki.ecmascript.org/doku.php?id=strawman:bignums">bignums</a>)的支援，Dart 有支援，在 ES 這邊目前有一點可能性會在 ES7(2016) 中出來，但這東西其實從 2010 就已經開始有討論了，如果有人來將這些討論規格化，並實做起來，那大數應該在現在的 ES6(2015) 就有了。</p>

<p>最後再回到 Terriable Idea 這篇文章，我雖然不完全認同他對 React 的看法，但是我認為他的重點沒錯，如果他拿 Dart 出來講可能就不會引出這麼多砲火吧（可是可能也比較沒人注意），其實 react-canvas 我覺得也是很有趣的實驗，不過做成正式產品上線就是另外一回事了，最大的問題，他為了終會被解決的次要問題（畫面不流暢）完全放棄了親和力的問題，而 Flipboard 這種內容為主的產品性質是不該放棄親和力的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000831" baseName="accessibility-before-been-blind">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-01-31</b:date>
				<b:time>18:58:52</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>在盲人之前的親和力</b:title>
			<b:content>
				<b:summary>不少人還會直接把網站的親和力（無障礙）問題和盲人朋友直接連在一起，覺得應該來解除迷思一下，盲人朋友確實是最直接會想到的，各種有身心障礙人士的族群當中，盲人朋友使用電腦上網的難度也是最高的，不過在你把眼睛矇起來體驗盲人如何操作電腦之前，有不少事情是可以先做的，隨便把腦袋裡馬上想的到的列了一下： 首先是網頁的文字內容易讀性，易讀性有分兩個面向，第一個面向大家比較清楚，就是文字排版、字形挑選、顏色對比等等視覺上的易讀程度，這部分做的好的話除了對老花眼、近視或是弱視的朋友有幫助外，一般人也會受惠；另一個面向則是文字內容好不好理解的程度，如果網站上的文字說明太難懂，那就應該要用更好理解的文字來重新講一遍，或是加上圖表輔助，或是乾脆減少資訊量，通常自己看的懂，不代表別人看的懂，所以如果是重要的說明（尤其是政府網站一些流程、辦理辦法之類的），建議都要找人看過，最簡單的是找家中長輩，因為網路上理解力較低的族群中，長輩們佔不少。 第二個是操作介面好不好操作，通常是 Web App 才有這需求，一樣有不同的面向，第一個是你的操作介面應該設計的容易理解，讓人看了也不會疑惑應該點哪裡，其中一個很重要的原則是不要破壞使用者的習慣，第二個面向是有些人可能無法好好的控制滑鼠（要模擬這個比模擬盲人的情境還要難），點擊不精確，所以永遠要保留鍵盤操作的選項，如果是使用原生的輸入元件來做操作介面的話，沒有亂做什麼奇怪的事情應該是都可以用鍵盤來控制，但是如果要自己設計一個嶄新的控制元件，那記得要好好利用 WAI-ARIA 來讓鍵盤可以順利的控制，像是 Google 的 Gmail 就有完整的鍵盤操作支援，這個應該是這篇文章當中做起來最辛苦的一項吧。 第三個是表單行為，要把表單作的好填，本身是一門很大的學問，不過在深入的思考設計表單的 usability 之前，有一些很基本的功能是應該具備的，其中特別想說的是錯誤訊息的處理，使用者送出表單後，如果後端的檢查沒過被打回來，應該要伴隨著能幫助使用者更新資料的錯誤訊息，並且正確的顯示在正確的位置，不然使用者不知道發生什麼事情，除了告訴使用者哪裡有錯之外，更進一步是讓使用者能把輸入資料改好，例如帳號名稱有格式限制的話，就要明確的說明有哪些限制，另外表單檢查不通過之後，記得也不要把使用者剛剛填的資料清空（實做這點還需要特別記得安全性問題）。 最後一個是文件結構，正確的使用 HTML 標籤，還可以輔以 WAI-ARIA 的 role 屬性，這已經是講到爛的項目了，當然 single page application 算是特殊情形，不過只要你做的頁面還是接近傳統網頁有文字內容，有主要內容的話，把網頁的文件結構弄好還是有兩大好處的：一、SEO 的部分已經好了一大半了；二、所有輔具都可以根據你的文件結構快速的帶領使用者在文件中穿梭，不用多做什麼奇怪的導盲機制。要把這塊做好算是四點當中最簡單的，只要正確的依照語意使用 HTML 標籤，不夠的再看看 WAI-ARIA 有沒有可用的 role，不要亂用標籤，然後用檢視原始碼的功能看看好不好看，如果你能開始從 HTML 原始碼中感受到美感甚至有完美的感覺出來，相信你就在正確的方向上了。 其實以上四點都有一個特色，就是把這些地方做好，不只是身心障礙人士會受惠，文字易讀性就不用說了，操控介面如果支援鍵盤，有些正常人操作起來會更得心應手，表單的訊息也是不論是怎樣的使用者都很需要，而文件結構也是，弄得好的話，大家都好找到資料，站長應該也開心。所以其實在你想要為了提升親和力而去實際模擬身心障礙人士使用電腦的情境之前，是有很多東西是可以先做的， 相信還是有人會有興趣盲人朋友怎麼操控電腦的，曾經 HappyDesigner 有邀請有聲書協會的朋友來介紹，不過已經有點久了，我去年初剛好有機會在 Moztw Lab...</b:summary>
				<b:mainContent><p>不少人還會直接把網站的親和力（無障礙）問題和盲人朋友直接連在一起，覺得應該來解除迷思一下，盲人朋友確實是最直接會想到的，各種有身心障礙人士的族群當中，盲人朋友使用電腦上網的難度也是最高的，不過在你把眼睛矇起來體驗盲人如何操作電腦之前，有不少事情是可以先做的，隨便把腦袋裡馬上想的到的列了一下：</p>

<p>首先是網頁的文字內容易讀性，易讀性有分兩個面向，第一個面向大家比較清楚，就是文字排版、字形挑選、顏色對比等等視覺上的易讀程度，這部分做的好的話除了對老花眼、近視或是弱視的朋友有幫助外，一般人也會受惠；另一個面向則是文字內容好不好理解的程度，如果網站上的文字說明太難懂，那就應該要用更好理解的文字來重新講一遍，或是加上圖表輔助，或是乾脆減少資訊量，通常自己看的懂，不代表別人看的懂，所以如果是重要的說明（尤其是政府網站一些流程、辦理辦法之類的），建議都要找人看過，最簡單的是找家中長輩，因為網路上理解力較低的族群中，長輩們佔不少。</p>

<p>第二個是操作介面好不好操作，通常是 Web App 才有這需求，一樣有不同的面向，第一個是你的操作介面應該設計的容易理解，讓人看了也不會疑惑應該點哪裡，其中一個很重要的原則是不要破壞使用者的習慣，第二個面向是有些人可能無法好好的控制滑鼠（要模擬這個比模擬盲人的情境還要難），點擊不精確，所以永遠要保留鍵盤操作的選項，如果是使用原生的輸入元件來做操作介面的話，沒有亂做什麼奇怪的事情應該是都可以用鍵盤來控制，但是如果要自己設計一個嶄新的控制元件，那記得要好好利用 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA">WAI-ARIA</a> 來讓鍵盤可以順利的控制，像是 Google 的 Gmail 就有完整的鍵盤操作支援，這個應該是這篇文章當中做起來最辛苦的一項吧。</p>

<p>第三個是表單行為，要把表單作的好填，本身是一門很大的學問，不過在深入的思考設計表單的 usability 之前，有一些很基本的功能是應該具備的，其中特別想說的是錯誤訊息的處理，使用者送出表單後，如果後端的檢查沒過被打回來，應該要伴隨著能幫助使用者更新資料的錯誤訊息，並且正確的顯示在正確的位置，不然使用者不知道發生什麼事情，除了告訴使用者哪裡有錯之外，更進一步是讓使用者能把輸入資料改好，例如帳號名稱有格式限制的話，就要明確的說明有哪些限制，另外表單檢查不通過之後，記得也不要把使用者剛剛填的資料清空（實做這點還需要特別記得安全性問題）。</p>

<p>最後一個是文件結構，正確的使用 HTML 標籤，還可以輔以 WAI-ARIA 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques">role</a> 屬性，這已經是講到爛的項目了，當然 single page application 算是特殊情形，不過只要你做的頁面還是接近傳統網頁有文字內容，有主要內容的話，把網頁的文件結構弄好還是有兩大好處的：一、SEO 的部分已經好了一大半了；二、所有輔具都可以根據你的文件結構快速的帶領使用者在文件中穿梭，不用多做什麼奇怪的導盲機制。要把這塊做好算是四點當中最簡單的，只要正確的依照語意使用 HTML 標籤，不夠的再看看 WAI-ARIA 有沒有可用的 role，不要亂用標籤，然後用檢視原始碼的功能看看好不好看，如果你能開始從 HTML 原始碼中感受到美感甚至有完美的感覺出來，相信你就在正確的方向上了。</p>

<p>其實以上四點都有一個特色，就是把這些地方做好，不只是身心障礙人士會受惠，文字易讀性就不用說了，操控介面如果支援鍵盤，有些正常人操作起來會更得心應手，表單的訊息也是不論是怎樣的使用者都很需要，而文件結構也是，弄得好的話，大家都好找到資料，站長應該也開心。所以其實在你想要為了提升親和力而去實際模擬身心障礙人士使用電腦的情境之前，是有很多東西是可以先做的，</p>

<p>相信還是有人會有興趣盲人朋友怎麼操控電腦的，曾經 HappyDesigner 有邀請有聲書協會的朋友來介紹，不過已經有點久了，我去年初剛好有機會在 Moztw Lab 遇到 Fancy 示範，當時有簡單的錄下來，有興趣的朋友可以看一下：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/fV2ufa2galY?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<p>至於要怎麼體驗盲人怎麼操作呢？如果你是用 OSX 的話，系統有內建 Voice Over，品質很好，可以直接使用，Windows 有好幾套商業軟體，至於免費的比較有名的是 <a href="http://www.nvaccess.org/">NVDA</a>，這套也是開源軟體，一開始可能需要先當明眼人練習操作，另外它講的話一開始可能會聽不太懂，聲音合成引擎和商業軟體比起來有差，多聽幾次慢慢就聽的出來再講什麼了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000826" baseName="android-l-webview-fullscreen-api">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-01-05</b:date>
				<b:time>21:20:32</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Android L WebView Fullscreen API</b:title>
			<b:content>
				<b:summary>今天遇到一個問題是，本來好好的全螢幕影片播放功能，到了 Android L 的 Facebook App 裡的 webview 瀏覽器就壞掉了，而且透過開發工具看沒有錯誤訊息出來，查了一陣子終於發現，最新的 webview 改成使用 Chrome 核心後，有些 API 雖然 Chrome 有支援，但是在 WebView 裡面是沒開啟的。 其實我本來已經有用 feature detection 的寫法了，不過這個情形實際上，requestFullscreen 是找的到，可以執行，也不會有錯誤的，只是就是什麼事情都不會發生，後來才 發現 是要用 document.fullscreenEnabled 來做判斷，這個東西我之前一直覺得在手機上都用不到的東西（桌面瀏覽器通常會先問使用者是否願意讓網頁進入全螢幕），沒想到會在這邊派上用場啊。...</b:summary>
				<b:mainContent><p>今天遇到一個問題是，本來好好的全螢幕影片播放功能，到了 Android L 的 Facebook App 裡的 webview 瀏覽器就壞掉了，而且透過開發工具看沒有錯誤訊息出來，查了一陣子終於發現，最新的 webview 改成使用 Chrome 核心後，有些 API 雖然 Chrome 有支援，但是在 WebView 裡面是<a href="https://developer.chrome.com/multidevice/webview/overview#does_the_new_webview_have_feature_parity_with_chrome_for_android_">沒開啟</a>的。</p>

<p>其實我本來已經有用 feature detection 的寫法了，不過這個情形實際上，<code>requestFullscreen</code> 是找的到，可以執行，也不會有錯誤的，只是就是什麼事情都不會發生，後來才 <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode#Other_information">發現</a> 是要用 <code>document.fullscreenEnabled</code> 來做判斷，這個東西我之前一直覺得在手機上都用不到的東西（桌面瀏覽器通常會先問使用者是否願意讓網頁進入全螢幕），沒想到會在這邊派上用場啊。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000815" baseName="ie-video">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-10-24</b:date>
				<b:time>12:01:15</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>IE video 標籤記憶體問題</b:title>
			<b:content>
				<b:summary>最近遇到一個 IE 會 crash 的問題，找很久才發現是記憶體問題，然後因為那頁有用到大量的 &lt;video&gt; 標籤，所以就直接鎖定目標，結果發現果然 video 就是問題元兇，測試到 IE 11 還是同樣行為。 目前發現的問題有兩層，第一層問題是如果 IE 在遇到 video 沒有設定 poster 時，會自動初始化整個 video 元件，去把影片抓下來，只為了產生 poster 圖片，第二層問題，就是這個初始化 video 元件的動作，會吃掉很多的記憶體，即使我的影片只有五百多kb，IE 還是一個 video 就吃掉數十 mb 的記憶體，即使這些 video 都沒有播放，甚至還用 CSS 藏起來了，然後因為一個頁面上有很多的影片輪流播放，所以把記憶體吃光後就當掉了。 要解決這個問題，一開始是想說設定正確的 poster 圖片就好了，確實解決了第一層的問題，但是因為影片還是會輪撥，遲早會把記憶體吃光，所以試了幾個方法想要避免這種情形，像是把 dom node detach...</b:summary>
				<b:mainContent><p>最近遇到一個 IE 會 crash 的問題，找很久才發現是記憶體問題，然後因為那頁有用到大量的 <code>&lt;video&gt;</code> 標籤，所以就直接鎖定目標，結果發現果然 video 就是問題元兇，測試到 IE 11 還是同樣行為。</p>

<p>目前發現的問題有兩層，第一層問題是如果 IE 在遇到 video 沒有設定 poster 時，會自動初始化整個 video 元件，去把影片抓下來，只為了產生 poster 圖片，第二層問題，就是這個初始化 video 元件的動作，會吃掉很多的記憶體，即使我的影片只有五百多kb，IE 還是一個 video 就吃掉數十 mb 的記憶體，即使這些 video 都沒有播放，甚至還用 CSS 藏起來了，然後因為一個頁面上有很多的影片輪流播放，所以把記憶體吃光後就當掉了。</p>

<p>要解決這個問題，一開始是想說設定正確的 poster 圖片就好了，確實解決了第一層的問題，但是因為影片還是會輪撥，遲早會把記憶體吃光，所以試了幾個方法想要避免這種情形，像是把 dom node detach 甚至砍掉之類的，不過都沒有效果，吃掉的記憶體不會還回來，最後只好讓 IE 不做輪撥了。</p>

<p>這個問題我看 stackoverflow 好像也沒有，看來在單一頁面上放很多 video 的使用情形真是很少見啊。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000810" baseName="commonmark">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-09-07</b:date>
				<b:time>00:16:44</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>CommonMark</b:title>
			<b:content>
				<b:summary> 一年前提過的 Markdown 標準化計畫沒想到真的有成果了，現在叫 CommonMark，不過其實前兩天還叫 Standard Flavored Markdown，只是因為 Markdown 的作者 John Gruber 不爽這個名字會造成混淆，所以 Jeff Atwood 只好很不爽的改名成 CommonMark，有興趣的可以看看他們的 spec，其實與其說是 spec，我覺得根本就是 Test Suite，裡面主要的不同點是列出很多以前不知道該怎麼 parse 的語法，統一訂出應該轉成怎樣的 HTML，算是個讓各家自己實做的引擎可以依據的規範，而且這次 release 除了 spec 外還同時提供了用 C 和 JavaScript 然後照著 CommonMark 實做的兩個 Markdown 引擎，我想 JavaScript 的版本應該很快就會有人拿去用了吧，另外就是 GitHub 應該會有人弄...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/14970705848/" title="Markdown by othree, on Flickr"><img src="https://farm4.staticflickr.com/3920/14970705848_5aba006fc2_m.jpg" width="208" height="128" alt="Markdown"   /></a></p>

<p>一年前提過的 Markdown 標準化計畫沒想到真的有<a href="http://blog.codinghorror.com/standard-flavored-markdown/">成果</a>了，現在叫 <a href="http://commonmark.org/">CommonMark</a>，不過其實前兩天還叫 <a href="http://standardmarkdown.com/">Standard Flavored Markdown</a>，只是因為 Markdown 的作者 John Gruber 不爽這個名字<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">會造成混淆</a>，所以 Jeff Atwood 只好很不爽的改名成 CommonMark，有興趣的可以看看他們的 <a href="http://jgm.github.io/stmd/spec.html">spec</a>，其實與其說是 spec，我覺得根本就是 Test Suite，裡面主要的不同點是列出很多以前不知道該怎麼 parse 的語法，統一訂出應該轉成怎樣的 HTML，算是個讓各家自己實做的引擎可以依據的規範，而且這次 release 除了 spec 外還同時提供了用 C 和 JavaScript 然後照著 CommonMark 實做的兩個 <a href="https://github.com/jgm/stmd">Markdown 引擎</a>，我想 JavaScript 的版本應該很快就會有人拿去用了吧，另外就是 GitHub 應該會有人弄 Ruby 的版本才是。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000805" baseName="mozjpeg-2">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-07-18</b:date>
				<b:time>11:33:16</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>mozjpeg 2.0</b:title>
			<b:content>
				<b:summary>昨天 Adobe 和 Google 聯手發表了思源黑體，算是亞洲資訊圈的一件大事，結果就把另外一個消息壓下去了，其實昨天 Mozilla 發表了 mozjpeg 2.0，這個專案的目標是在保持相容於市場上現有的 jpeg decoder 之下，想辦法讓 jpeg 檔案能夠更小，第一輪的成果發表是就是昨天的 2.0 了，結果而言平均可以讓 jpeg 圖片品質不變差的情況下減少 5% 的大小，看到這個 5% 數據讓我想到 Google 曾經推出相容於 gzip, deflate 的 Zopfli，不過 mozjpeg 應該是不用花到 100 倍的壓縮時間啦，目前 Facebook 還有贊助這個計畫的下一輪發展，也就是 3.0 的開發。mozjpeg 目前是以 c lib 的形式釋出，可惜還沒有看到有命令列工具支援，希望能帶動一波圖片最佳化工具的更新潮啊。...</b:summary>
				<b:mainContent><p>昨天 Adobe 和 Google 聯手發表了<a href="http://blog.typekit.com/alternate/source-han-sans-cht/">思源黑體</a>，算是亞洲資訊圈的一件大事，結果就把另外一個消息壓下去了，其實昨天 Mozilla 發表了 <a href="https://blog.mozilla.org/blog/2014/07/15/improving-jpeg-image-encoding/">mozjpeg 2.0</a>，這個專案的目標是在保持相容於市場上現有的 jpeg decoder 之下，想辦法讓 jpeg 檔案能夠更小，第一輪的成果發表是就是昨天的 2.0 了，結果而言平均可以讓 jpeg 圖片品質不變差的情況下減少 5% 的大小，看到這個 5% 數據讓我想到 Google 曾經推出相容於 gzip, deflate 的 <a href="http://blog.gslin.org/archives/2013/03/01/3228/google-%E7%99%BC%E8%A1%A8%E8%88%87-zlibdeflate-%E7%9B%B8%E5%AE%B9%E7%9A%84%E5%A3%93%E7%B8%AE%E7%A8%8B%E5%BC%8F%EF%BC%8C%E5%86%8D%E5%B0%8F-5/">Zopfli</a>，不過 mozjpeg 應該是不用花到 100 倍的壓縮時間啦，目前 Facebook 還有贊助這個計畫的下一輪發展，也就是 3.0 的開發。mozjpeg 目前是以 c lib 的形式釋出，可惜還沒有看到有命令列工具支援，希望能帶動一波圖片最佳化工具的更新潮啊。</p>

<p>其實 Mozilla 在去年還有發表了一篇對於目前市場上破壞性壓縮圖片格式的<a href="https://people.mozilla.org/~josh/lossy_compressed_image_study_october_2013/">品質比較</a>，比較了 JPEG、JPEG XR、WebP 和 HEVC-MSP，結果表現不離預期，最好的是 HEVC-MSP4，這是 H.265 Profile 的靜態圖片格式，算是比較項目中最新的格式了，表現最好好像不意外，不過其實高壓縮比相對的來說解壓縮需要的運算資源就會多，所以 Mozilla 才不會完全往新技術走，而開了這個 branch，顧到的前提下相容度，盡量的減少網路傳輸，這個計畫目前看來是還會繼續發展，不知道接下來還能夠提升多少壓縮比，還蠻令人期待的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000800" baseName="chrome-emulator">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-06-26</b:date>
				<b:time>11:55:24</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Chrome 開發工具的新模擬器</b:title>
			<b:content>
				<b:summary> Chrome 開發工具有個新的模擬器，介面改不少，其中最大的特點是多了網路模擬的功能，可以模擬網路速度了，目前在 Chrome Canary 已經可以用，可惜還沒有自定義選項的功能，不過我想到 Chrome 前應該會有～...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/14486840456/" title="Chrome Emulator by othree, on Flickr"><img src="//farm4.staticflickr.com/3857/14486840456_74dce49944_b.jpg" width="857" height="850" alt="Chrome Emulator" srcset="//farm4.staticflickr.com/3857/14486840456_74dce49944.jpg 768w, //farm4.staticflickr.com/3857/14486840456_74dce49944_b.jpg 768w 2x" /></a></p>

<p>Chrome 開發工具有個新的模擬器，介面改不少，其中最大的特點是多了網路模擬的功能，可以模擬網路速度了，目前在 Chrome Canary 已經可以用，可惜還沒有自定義選項的功能，不過我想到 Chrome 前應該會有～</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000793" baseName="web-component-at-osdc">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-04-12</b:date>
				<b:time>23:07:20</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Web Component at OSDC</b:title>
			<b:content>
				<b:summary>/*A_A*/ 這次 OSDC 講的投影片，另外有兩個地方要補充一下，第一個是我的 Github 上的範例，因為用到 HTML Import 的關係，有安全性限制，一定要開個 HTTP Server，不然會出錯誤，然後我有用 gulp 設定好了，理論上裝好 gulp 就可以在 localhost 把開發用的 HTTP Server 開起來，然後現在的 Chrome Canary 無法跑，還不知道原因，所以請用 Chrome Stable。 第二個是現在的參考資料，很大部份都是參考 HTML5 Rocks 的文章，可以參考我之前介紹 Web Component 的文章最下面，這些文章的內容其實一直有在根據實做更新，所以會發現和 Spec Draft 定義不一樣。...</b:summary>
				<b:mainContent><script async="async" class="speakerdeck-embed" data-id="7b33cc90a36601311a734eb53c3a6292" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/*A_A*/</script>

<p>這次 OSDC 講的投影片，另外有兩個地方要補充一下，第一個是我的 Github 上的<a href="https://github.com/othree/web-component-test">範例</a>，因為用到 HTML Import 的關係，有安全性限制，一定要開個 HTTP Server，不然會出錯誤，然後我有用 gulp 設定好了，理論上裝好 gulp 就可以在 localhost 把開發用的 HTTP Server 開起來，然後現在的 Chrome Canary 無法跑，還不知道原因，所以請用 Chrome Stable。</p>

<p>第二個是現在的參考資料，很大部份都是參考 HTML5 Rocks 的文章，可以參考我之前介紹 <a href="https://blog.othree.net/log/2013/11/27/web-component/">Web Component</a> 的文章最下面，這些文章的內容其實一直有在根據實做更新，所以會發現和 Spec Draft 定義不一樣。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
