<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>O3noBLOG - script</title>
<link>https://blog.othree.net//log/ script/</link>
<description></description>
<copyright>Copyright 2015</copyright>
<lastBuildDate>2015-08-21 00:38</lastBuildDate>
<generator>http://www.movabletype.org/?v=4.381</generator>
<docs>http://blogs.law.harvard.edu/tech/rss</docs> 


<item>
<title>React 入門</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/13990963771/" title="京都嵐山 by othree, on Flickr"><img src="https://farm6.staticflickr.com/5237/13990963771_028f39af66_b.jpg" width="1024" height="683" alt="京都嵐山" srcset="https://farm6.staticflickr.com/5237/13990963771_028f39af66.jpg 768w, https://farm6.staticflickr.com/5237/13990963771_221cae9d50_k.jpg 2x" /></a></p>

<p>其實這篇想寫一陣子了，不過拖太久本來想放掉，是後來又看到 TonyQ 在說他的經驗，就覺得還是寫一下，搞不好可以幫到人(?)，然後其實我對 React 沒深入研究，目前也只寫過一次，也沒做到複雜的　App，所以這篇純粹是我的觀察啦。</p>

<p>先講結論，寫過目前一般 Web App 的人，要來寫 <a href="http://facebook.github.io/react/">React</a> 大概都要一些撞牆期吧，我的狀況是要寫 React + <a href="http://facebook.github.io/flux/">Flux</a> 架構的 Web App，但是一開始對 Flux 的介紹沒認真看，在一知半解的狀態下就開始做了，結果就一直出現些靈異現象，大部分是覺得應該要更新畫面了但是沒有，追到後來大概就兩個原因：</p>

<ul>
<li><p>亂用 props 和 state，總之就是 React 只會在 state 變化的時候更新畫面，props 變化的時候不會（其實設計上是 immutable 的），而用 props 的時機基本上是父層 component 要設定資料給子 component 的時候才會用，至於父層收到不同的資料給子 component 時，同樣是改 props，為什麼畫面就會更新了，事實上是因為父層 component 更新的時候，才有機會改動到子 component 的 prop，而因為有重新 render，子 component 的內容也會一起更新，也才更新了畫面。</p></li>
<li><p>想要只更新子 component，這個問題就是沒把 flux 的設計弄清楚，Flux 的 store 其實有點代表所有的資料的意思，而不管是什麼動作，都要把整包的 store 資料更新回去，根 component 會綁事件在 store 的更新事件上，發現 store 資料有更新就開始重新 render component，然後跟著它的子 component 就會因為 prop 更新而跟著更新。</p></li>
</ul>

<p>當然 store 是可以有多個的，重點在於每次更新都要整個 store 的資料重新給根 component，不能從 store 裡面某一層開始送，然後想要只更新某個子 component，這樣結果就很容易發生靈異事件，當然 React 可以不用 Flux 架構，不過我覺得那條路走起來更困難，所以還是乖乖使用 Flux 架構，其實我後來做的結構很簡單，action 就只是一個事件，store 就是 POJSO 而已，沒用到一些市面上的 Flux framework。</p>

<p>最後一點要提的就是每次都整包 store 更新，可能就會有人想到效能問題，當然 React 本身效能不錯，不過資料量要是超大，可能還是會有出現狀況，我想這也是為什麼 Facebook 要發展 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a> 的原因，其實我仔細瞭解後，發現 Immutable 配合 Flux 架構真的是超適合的，而且他在大量資料更新的時候，可以保持蠻不錯的效能，因為只有 reference 的變化，而不是真的重新產生整包資料，沒變化的資料都是本來就已經在記憶體裡面的，整體的資源消耗少很多。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/08/21/react-intro/</link>
<guid>https://blog.othree.net/log/2015/08/21/react-intro/</guid>
<category>script</category>
<pubDate>2015-08-21 00:38</pubDate>
</item>

<item>
<title>fetch is the new XHR</title>
<description><![CDATA[<p>這次 COSCUP 講的是新的 Web API: fetch，其實這個東西要用只要看 HTML5 Rocks 那篇文章就好了，只是我在使用和做 fetch-er 的時候發覺很多的細節和問題（投影片裡面的 facts），有一些不跟最新進度也不知道狀況是怎樣，連 Stack Overflow 上也沒有，可能有人遇到但是不知道，所以就和我的 fetch-er 專案一起投稿。</p>

<p>和 fetch-er 專案一起投稿的另一個考量是，在 COSCUP 和 OSDC 分享這麼多次，年初我突然才發現我的講題和 Open Source 的關連度實在太低（嚴格說來我在那時才認真意識到 open source 和社群的差異），只有 2013 的 COSCUP 是講我在 Vim Plugin 開發上的歷程，其他有一場有介紹到 underscore，之外就大部分是在介紹 Web 的新東西，所以認真的覺得今年要投和 Open Source 相關的東西，而不是只是 Web 相關的而已。</p>

<script async="async" class="speakerdeck-embed" data-id="8f42a7c5ffad4c9cab284637e0bddbc2" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]>
</description>
<link>https://blog.othree.net/log/2015/08/17/fetch-is-the-new-xhr/</link>
<guid>https://blog.othree.net/log/2015/08/17/fetch-is-the-new-xhr/</guid>
<category>script</category>
<pubDate>2015-08-17 18:28</pubDate>
</item>

<item>
<title>Electron 入門</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/20249299982/" title="electron by othree, on Flickr"><img src="https://farm1.staticflickr.com/312/20249299982_763c6a25a6_b.jpg" width="1024" height="683" alt="electron" srcset="https://farm1.staticflickr.com/312/20249299982_763c6a25a6.jpg 768w" /></a></p>

<p>前陣子花了些時間用 <a href="http://electron.atom.io/docs/v0.30.0/tutorial/quick-start/">Electron</a> 寫了個桌面應用程式，覺得有些資訊應該記錄一下，其實我覺得 Electron 的文件弄得超爛的，非常沒有 Github 的水準，Github 當初能夠起來，我認為一個很大的原因就是文件做的很好，而且在頁面上都會提供相對應操作的說明文件，不只讓網站的易用性提昇很多，連帶的也推廣了 Git 的使用，算是相輔相成起來的，不過 Electron 剛推出的時候，我就覺得，這是有文件嗎？甚至讓我有個印像是，我們雖然推出 Electron 但是沒很想讓你們用，所以文件隨便寫寫。</p>

<p>為什麼這樣說，拿現在最新版 0.3.0 來說，其實這應該只是自動產生的<a href="http://electron.atom.io/docs/v0.30.0/">文件</a>，整頁的第一篇文章是 <a href="http://electron.atom.io/docs/v0.30.0/tutorial/application-distribution/">Application distribution</a>，這真的沒有哪裡搞錯嗎？而且這份文件還很爛，有關鍵的地方沒說，之後會講。總之，要開始寫 Electron App 應該要看的是 <a href="http://electron.atom.io/docs/v0.30.0/tutorial/quick-start/">Quick Start</a> 才對，這份文件用了一個很簡單的範例讓你開始可以跑 Electron App，只要會寫網頁，從這邊就可以開始做 Electron App，但是一個應用程式哪有這麼單純，只靠 Web 端的技術一定是有不足的，例如我要做的程式就需要讀取 key 去登入 SSH 然後做事情，這登入 SSH 然後做事的部分用的是 node 的 code，不能跑在瀏覽器環境，在 Electron 的架構下，瀏覽器環境稱為 renderer，而另外一邊用來起始 renderer process 的則稱為 main process，要登入 SSH 的 code 就要寫在 main process 這邊，那兩邊要怎麼溝通呢？Electron 提供了 IPC 模組來用。</p>

<p>IPC 模組應該是稱為 Inter Process Communication 吧，我覺得這在 Electron App 開發當中應該是超重要的一部份，結果在 Quick Start 那篇文章中竟然沒有範例介紹，只有簡單的一句話說如果兩邊要溝通要用這個（或是另外一個 remote 模組），而且點過去也只有 <a href="http://electron.atom.io/docs/v0.30.0/api/ipc-renderer/">API 文件</a>，沒有範例，後來出的 remote 模組的<a href="http://electron.atom.io/docs/v0.30.0/api/ipc-renderer/">文件</a>才有範例說明，總之這樣弄來弄去還是有解決兩邊的溝通問題，所以下一個遇到的，就是我要怎麼讓使用者選檔案了。</p>

<p>因為 Electron 是跨平台的，我的程式設計是用 private key 去登入遠端的機器做事情，Linux 或 OSX 都可以假設 key 的位置，但是 Windows 不行，所以我就要提供可以讓使用者選檔案的功能，這部分文件也是沒有好好的連結，你看完 Quick Start，看一遍文件目錄，其實都看不出來到底要怎麼做到這件事，事實上它被稱為 <a href="http://electron.atom.io/docs/v0.30.0/api/dialog/">dialog</a>，這不把整份 API 文件翻完真的不知道是放在這名字下面。</p>

<p>然後，Electron 的 renderer process 端雖然和瀏覽器環境幾乎一樣，不過還是有些差異，一部份是 Chrome 引擎的問題，例如最近的 <code>fetch</code>，在 renderer process 會受到 CORS 限制，但是 XHR 不會，這是因為 fetch 還沒有檢查 Chrome 的 safety flag，所以如果要用 fetch API 接 ES6 Promise 的話，就要用 Github 的 polyfill，自己把檢查的程式碼拿掉，另外一個類似的問題是，如果要在 renderer process 中，引入第三方的 library，有兩種用法，一個是用新出現的 <code>require</code> 來引入 npm module，或是像一般網頁一樣，直接用 <code>&lt;script&gt;</code> 標籤引入 js 檔案，但是就會發生一個問題，因為 jQuery 會判斷現在的環境，然後來決定要不要 expose <code>$</code> 變數到 global scope 下，剛好，Electron 的環境下，雖然是要當成瀏覽器環境，但是又多了 <code>require</code> 可以用，結果就是被誤判成在 Node 環境，想當成一般網頁環境用 jQuery 就會找不到 <code>$</code>，結果也是要自己去修改檢查部分的程式碼。</p>

<p>最後，把程式功能弄得差不多了，要打包給其他人時，發現竟然無從下手，本文開頭提到的 Application distribution 這份文件說的很簡單，就是把某個目錄換掉就好了，可是真的到了這一步才意識到，是換掉哪裡的目錄？結果只好上網找別人弄好的打包工具，這邊我用的是 <a href="https://www.npmjs.com/package/electron-packager">electron-packager</a>，研究一下才發現，原來是要抓 Github 上 <a href="https://github.com/atom/electron/releases">release</a> 那的檔案下來處理，整個過程其實還蠻不愉快的，因為根本不是難懂，而是文件作不好造成一堆時間浪費啊。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/08/03/electron-intro/</link>
<guid>https://blog.othree.net/log/2015/08/03/electron-intro/</guid>
<category>script</category>
<pubDate>2015-08-03 21:27</pubDate>
</item>

<item>
<title>GHCJS</title>
<description><![CDATA[<p>最近幾天把 GHCJS 研究了一遍，一開始的需求是因為開始用 <a href="http://pandoc.org/">pandoc</a>，然後想要用 JS 提供即時的預覽，因為 Pandoc 是 Haskell 寫的，所以看下來自然是看到 <a href="https://github.com/ghcjs/ghcjs">GHCJS</a> 了，其實網路上以經有人成功的把 Pandoc 轉成 JS 了，叫做 <a href="http://markup.rocks/">markup.rocks</a>，我後來也是基於他在 github 上公開的這些程式碼來研究。</p>

<p>要安裝 GHCJS 有點麻煩，以 OSX 為例，要先去<a href="https://www.haskell.org/ghc/download_ghc_7_8_3#macosx_x86_64">下載</a> GHC 的 binary distribution 壓縮檔（ghc-7.8.3-x86_64-apple-darwin.tar.xz），解壓縮後，進目錄執行：</p>

<pre><code>./cofigure
make install
</code></pre>

<p>安裝完 GHC 後要更新 <code>cabal</code> 這個套件管理工具：</p>

<pre><code>cabal install cabal-install
</code></pre>

<p>然後這樣會把 cabal 裝到自己 home 目錄下面，所以還要更新一下 $PATH：</p>

<pre><code>PATH=$HOME/Library/Haskell/bin:$PATH
</code></pre>

<p>接下來才是安裝 GHCJS：</p>

<pre><code>git clone https://github.com/ghcjs/ghcjs-prim.git
git clone https://github.com/ghcjs/ghcjs.git
cabal install ./ghcjs ./ghcjs-prim
</code></pre>

<p>要用 GHCJS 之前，還要安裝一下環境的基本套件：</p>

<pre><code>ghcjs-boot --dev
</code></pre>

<p>如果一切順利的話就可以開始把 Haskell 程式轉成 JS 了，不過事情當然沒這麼簡單，首先 GHCJS 的套件和 GHC 的套件在本地是分開的，要裝給 GHCJS 環境的話，要加上 <code>--ghcjs</code> 的選項，例如：</p>

<pre><code>cabal install --ghcjs pandoc
</code></pre>

<p>這樣裝的套件才能夠讓 GHCJS 轉譯時使用，然後第二個問題就是上面這個指令其實裝不起來，因為 Pandoc 和 GHCJS 不相容，markup.rocks 的作者 Ozan Sener 其實有 fork 一份 Pandoc 針對這個問題作 <a href="https://github.com/osener/pandoc">patch</a>，所以安裝改成下面的指令：</p>

<pre><code>git clone git@github.com:osener/pandoc.git
cabal install --ghcjs ./pandoc
</code></pre>

<p>不過還是會有些問題，基本上就看缺什麼用 cabal 裝一下，然後有些錯誤要簡單修改一下程式碼，詳情不是很重要，因為接下來馬上有第三個問題，就是這樣裝起來後，會發現要成功的轉 markup.rocks 還是有問題，其中 reflex-dom 一直裝不起來，這個套件主要是拿來做網頁介面的，所以我把 <a href="https://github.com/osener/markup.rocks/blob/master/src/Main.hs">Main.hs</a> 內只和 pandoc 相關的抽出來，想建立一個只有 pandoc 單純一點的 Haskell 程式，然後一番努力後，終於成功了，這時同時出現兩個問題，第一個是產出的檔案超大，有 20MB 左右，markup.rocks 線上 demo 放的是有過 closure-compiler 的也還有 2.2MB，而另外一個問題，是我找不到程式可以讓我抓到輸出入的位置（嚴格來說有找到但是無法用），後來又查了些資料才發現，GHCJS 目前還沒辦法把 Haskell library 單獨轉譯然後開 API 出來，一定是一個完整的 Haskell 應用程式，然後編譯出來的 JS 就是執行這個程式，沒有外面插手的餘地，換句話說，就是所有事情都要用 Haskell 完成，然後用 GHCJS 編譯成一個獨立的 JavaScript 應用程式，GHCJS 的 <a href="https://github.com/ghcjs/ghcjs/issues/194">Issue 194</a> 就是在講這個問題，看起來離有結果還有些距離。</p>

<p>總之結論是，目前 GHCJS 還不到真的可拿來做應用的程度，最後遇到的兩個問題算是比較大的，就是輸出檔案太大和只能把整個應用程式轉譯成 JS 這兩個問題，不過事情總是要有開始，希望未來有一天這兩個問題能解決，就能夠把 Haskell 的一些工具轉到 JS 上了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/06/18/ghcjs/</link>
<guid>https://blog.othree.net/log/2015/06/18/ghcjs/</guid>
<category>script</category>
<pubDate>2015-06-18 00:08</pubDate>
</item>

<item>
<title>TypeScript, AtScript, ES Decorator</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16813714825/" title="AtScript by othree, on Flickr"><img src="https://farm8.staticflickr.com/7639/16813714825_e15ff55b8b_b.jpg" width="1024" height="573" alt="AtScript" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7639/16813714825_e15ff55b8b.jpg 1x, https://farm8.staticflickr.com/7639/16813714825_e15ff55b8b_b.jpg 2x"  /></a></p>

<p>前陣子花了些時間研究了 TypeScript 和一些相關的發展，包括了 Google Angular Team 的 AtScript 和推進 ES 標準的部分，會開始感興趣深入研究主要是因為 <a href="http://blogs.msdn.com/b/typescript/archive/2015/03/05/angular-2-0-built-on-typescript.aspx">Angular 2 說改用 TypeScript 寫</a>，好奇為什麼會有這樣的發展才下去搜尋資料的，這篇文章算是記錄用的，不過其實離寫好已經一陣子了，因為剛好遇到 Modern Web Conf，想說拿這題目去分享，就讓文章晚點上線了，後來投影片還有補充些內容，這篇文章就沒再更新了，所以兩邊會有些差異就是～</p>

<p>ECMAScript 標準一直以來都是動態型別的，雖然資料有不同的型別，但是變數本身是沒限制型別的，而在 ECMAScript 發展的過程中，靜態型別第一次出現是在已經被廢棄的 ECMAScript 4 裡，網路上還可以找到一些<a href="http://www.ecmascript.org/es4/spec/overview.pdf">資料</a>，可以看看當時設計的語法，和現在常看到的 <code>:type</code> 的寫法很接近，後來這個設計也在 ActionScript 3 中被使用，微軟現在的 TypeScript 也是用這種寫法。那加入靜態型別的特性會有什麼好處呢，我認為有兩個主要的優點，第一個是可以讓程式碼更可靠，減少一些 bug 發生的機會，對於大型專案來說，多了這個限制的差距是蠻大的，另外一個優點則是 JS Engine 更好最佳化，以前也有提過現在的 V8 引擎就已經會判斷變數的型別會不會有變化來做最佳化了。</p>

<p>或許是因為微軟對於大型專案開發的關注比較多吧，他們於 2012 年推出了 <a href="http://www.typescriptlang.org/">TypeScript</a>，為 JavaScript 加入了靜態型別，用的語法很簡潔：</p>

<pre><code>var i:int;
var message:string;
</code></pre>

<p>另外還提供了當時沒有的 class 和之前提過的<a href="https://blog.othree.net/log/2014/12/04/typescript-definition/">定義檔</a>等東西，TypeScript 一開始是基於 ECMAScript 5 設計的，不過在 ECMAScript 6 差不多定案後，微軟也開始著手把 ES5 based 改成 ES6 based，像是 class 就會改用 ES6 原生的，而 TypeScript 所提供的靜態型別檢查功能其實是靜態分析而已，也就是只有在把 .ts 檔案編譯成 .js 檔案時會做檢查，而由於 JavaScript 還沒有 type 的特性，所以這些型別的資訊其實在編譯過後都會被拿掉。目前除了 AngularJS 2 改用 TypeScript 之外，還有像 <a href="https://eng.asana.com/2014/11/asana-switching-typescript/">Asana</a> 和 Mozilla 的 <a href="https://github.com/mozilla/shumway">Shumway</a> 都是用 TypeScript。</p>

<p>Google Angular Team 似乎對此還不夠滿足，因此他們開始發展 <a href="http://www.atscript.org/">AtScript</a>，在 TypeScript 上再加入 annotation 的功能，名稱的 At 代表的是 <code>@</code> 這個符號，因為這個符號是很多語言寫 annotation 用的符號，自然 AtScript 也是用這個符號來標記 Annotation：</p>

<pre><code>@Component({selector: 'foo'})
class MyComponent {
  @Inject()
  constructor(server:Server) {}
}
</code></pre>

<p>Annotation 簡單翻起來也是註解，不過他和 comment 不一樣，不是給人看，而是要給 compiler 和 JS engine 看的，而且實際上也會影響程式的一些運作，annotation 應該是一種完全沒有也不影響程式執行的 metadata，不過細分下去應該可以分為兩類，第一種是 Java 的 annotation，以 metadata 為主，像是物件的角色、物件間關係等，另外一種則是 decorator annotation，可以讓函數加上各種不同特性，其實就是 decorator pattern 的簡易語法，看到一些範例當中，最讓我覺得厲害的就是 memorize 了吧，如果程式引擎支援，加上一行 memorize 的 annotation 就可以讓那個函數自動有 memorize 特性，如果使用不支援此特性的引擎來執行程式，函數的輸出也不會有錯，就是沒有 memorize 的效果，效率會比較差，Python 中就有 <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">lru_cache</a> 這個 decorator 可以做到這樣的效果（Python 的 decorator 語法是提供 syntax sugar，不過寫法和其它語言的 annotation 很像）:</p>

<pre><code>@lru_cache(maxsize=None)
def fib(n):
    if n &lt; 2:
        return n
    return fib(n-1) + fib(n-2)
</code></pre>

<p>AtScript 一個很重要的原則是這些附加的資訊，都要在 runtime 可以使用，所以就不像 TypeScript 那樣只是把不支援的東西拿掉而已，像上面費氏數列的程式碼如果改用 AtScript 寫會變成：</p>

<pre><code>@lru_cache()
function fib(n) {
  if (n &lt; 2) { return n; }
  return fib(n - 1) + fib(n - 2);
}
</code></pre>

<p>然後用 AtScript compiler 編譯過後會多上一段程式碼做類似下面的事情：</p>

<pre><code>fib.annotations = [
  new lru_cache(),
];
</code></pre>

<p>這個 <code>annotations</code> 屬性在 runtime 時就是可以取用的資訊，目前 AtScript 的 annotation  就是比較偏重於 metadata 而不是 decorator，所以這些資料並不會直接讓函數有不同特性，而 AtScript 另外一個新東西 introspection 也是和 runtime 有關，是 TypeScript 所沒有的 runtime 時的型別檢查，JavaScript 要怎樣做執行階段的型別檢查呢？沒錯，基本上就是土法煉鋼，不過 AtScript 是引入一個 rtts（run time type assertion） 的 library 來做這件事，目前主要也是用 Angular Team 維護的 <a href="http://angular.github.io/assert/">assert.js</a>，本來的 fib 再改寫一下：</p>

<pre><code>function fib(n:number):number {
    if (n &lt; 2) { return n; }
    return fib(n - 1) + fib(n - 2);
}
</code></pre>

<p>然後編譯過後大概會變成：</p>

<pre><code>function fib(n) {
  assert.argumentTypes(n, number);
  if (n &lt; 2) {
    return assert.returnType((n), number);
  }
  return assert.returnType((fib(n - 1) + fib(n - 2)), number);
}
</code></pre>

<p>可以看到不管是在函數開頭還是要回傳之前，都會多了用 assert.js 做型別檢查的程式碼，當然，多做的這些型別檢查是會造成效能影響的，所以 AtScript 把 runtime 的型別檢查分成兩個階段，開發階段和成品階段，成品階段，要上線的時候，就輸出不包含型別檢查的 js 程式碼，這樣就不會影響效能。AtScript 其實目前沒有自己的編譯器，而是使用 Google 的 <a href="https://github.com/google/traceur-compiler">Traceur</a>，Traceur 基本上是個 ES6 to ES5 compiler，不過實際上他還多一些非 ES6 標準的語法支援，包括了前面提到的 Type、Annotation，不過使用時要加些參數：</p>

<pre><code>traceur --annotations true --type-assertions --types true fib.ats --out fib.js
</code></pre>

<p>在 <a href="http://ngeurope.org/">ng-europe</a> 研討會，就有一場關於 AtScript 的演講：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/lGdnh8QSPPk?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<p>裡面除了基本的介紹，為什麼會發展 AtScript 之外，還有很重要的未來發展，Angular Team 是有打算把 Type、Annotation 等等特性推回 ECMAScript 未來的標準之中的。在 ECMAScript 標準的發展上，其實早在之前就有一些變數型別相關的功能在討論，包括了 <a href="http://wiki.ecmascript.org/doku.php?id=strawman:types">type</a>、<a href="http://wiki.ecmascript.org/doku.php?id=strawman:guards">guard</a>，不過都沒有進到目前的 ECMAScript 6(2015)，目前 AtScript 和 TypeScript 兩者正在逐漸互相同步，也有共同合作，而且 AtScript 還沒有嚴謹的 spec 文件，所以會看到官方發佈說 AngularJS 2 用 TypeScript 開發，而不是用 AtScript，目前看到 TC39 討論裡面，除了 type 之外，幫其它新東西提出 proposal 的，很令人意外，竟然是 Yehuda Katz，可以看到去年四月的<a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-10.md#decorators-for-es7">會議記錄</a>就有他提出 decorator 特性的討論，另外 TypeScript 的 <a href="https://github.com/Microsoft/TypeScript/issues/1557#issuecomment-77709527">Issue 1557</a> 是關於在 TypeScript 中加入 AtScript 的 annotation 支援，Yehuda Katz 也有提到他正在整理相關資料，幾週後會在 TC39 會議提出，在他的 github 帳號上也可以找到相關的<a href="https://github.com/wycats/javascript-decorators">資訊</a>，我個人對 Yehuda Katz 評價很高，不過實在是想不太到為什麼會是他跑出來推動這部分的發展，不過總之 Yehuda Katz 打算提出的是比現在 metadata 為主更進一步的 annotation，也就是包含像 Python decorator 特性的 annotation，如果真的順利成案，其實也不知道是好是壞，好的是一些程式碼可以更簡潔，壞的是 JavaScript 語法越來越多，入門要學的東西也變多很多。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/05/18/typescript-atscript-es-decorator/</link>
<guid>https://blog.othree.net/log/2015/05/18/typescript-atscript-es-decorator/</guid>
<category>script</category>
<pubDate>2015-05-18 18:24</pubDate>
</item>

<item>
<title>TypeScript 過去、現在、未來</title>
<description><![CDATA[<p>今年 Modern Web Conf 的投影片喔，其實整份演講最重要的點就是 type 看來就是會進入 ECMAScript 了。</p>

<script async="async" class="speakerdeck-embed" data-id="b551e3b068aa4babb798c5e61c799b19" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]>
</description>
<link>https://blog.othree.net/log/2015/05/16/typescript-future-and-past/</link>
<guid>https://blog.othree.net/log/2015/05/16/typescript-future-and-past/</guid>
<category>script</category>
<pubDate>2015-05-16 15:03</pubDate>
</item>

<item>
<title>React.js Conf</title>
<description><![CDATA[<p>今年的 React.js Conf 雖然是單一 library 的研討會，不過議程的水準卻是蠻高的，而且蠻多內容並不是只限於 React.js，加上也是對於前端領域一些比較新的概念，所以我覺得是這兩年最讓人感到印象深刻的一場研討會了吧，下面介紹幾場我覺得收穫比較多的講題：</p>

<h4>React Native</h4>

<p>React Native 是 React.js 最近最重大的發展，把本來抽出來的 DOM 底層換成 native app 的操作，原來寫 JavaScript 的開發者就可以直接用寫 React.js App 的方式來做原生介面的 Mobile App，發表時讓很多人眼睛一亮，沒想到會把 React.js 的 Virtual DOM 這樣用，而表現出來的效果也很讓人滿意，因為是用原生的控制元件，也不會有額外的親和力問題，加上現有的很多 JavaScript Library 都可以用，也不會有太多東西要自己從頭開始，<a href="https://cordova.apache.org/">Apache Cordova</a> 的 plugin 也都可以使用，最近也正式對外<a href="https://facebook.github.io/react-native/">公開</a>了，有興趣的可以試試看。</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/KVZ-P-ZI6W4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<h4>CSP</h4>

<p>之前我也有介紹過的 <a href="https://blog.othree.net/log/2015/02/14/csp/">CSP</a>，在 React.js Conf 也有講者介紹，雖然我覺得現在用 <a href="https://github.com/ubolonton/js-csp">js-csp</a> 來做 Channel 溝通還不是很好用，不過應該 async function 可以用之後會比較普遍吧，就算之後沒真的派上用場，要是轉行寫 Go 也會用的上才是。</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/W2DgDNQZOwo" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<h4>Immutable</h4>

<p>Immutable Data 已經聽說很久了，不過這場演講算是讓我第一次真的能有些體會到底優點在哪，雖然 Facebook 有 JavaScript 的 <a href="http://facebook.github.io/immutable-js/">Immutable library</a> ，不過這場主要是在介紹資料結構的特性，而不是在介紹自家 library，如果對他們底層如何實做的話還可以看看 Polymatheia 的 <a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">Understanding Clojure's Persistent Vectors</a> 系列文章，單純要實做 Immutable Data 並不難，不過要考慮到不對效能產生影響其實還要考慮蠻多細節的，我後來也嘗試實做了一個 <a href="https://github.com/othree/immutable-quadtree-js">Immutable Quad Tree</a>，做的過程中則更實際的體會到所謂的只要簡單的 <code>==</code> 比對就可以知道資料是否相同的好處。另外還要補充一點，Immutable Data 可能在下一版的 ES7(2016) 也會有，總之又是個先學起來不吃虧的。</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/I7IdS-PbEgI" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>

<h4>AST</h4>

<p>這場演講是在講修改 Abstract Syntax Tree 來做一些程式碼的修改，算是把 AST 的應用講得很淺顯易懂的一場演講，還順便介紹到很多相關的工具，像是 <a href="https://github.com/estools">estools</a>，其實一個程式語言的 spec 通常只有定到語法的部分，後面 compiler 要產生什麼樣子的 AST 是他們自己決定的，不過通常會有個主流的格式，而目前 JavaScript 領域則是 Mozilla SpiderMonkey 的 AST 格式為主，不過其實因為應用太多，也有人在做標準化的工作，叫 <a href="https://github.com/estree/estree">estree</a>。</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/OZGgVxFxSIs" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
]]>
</description>
<link>https://blog.othree.net/log/2015/04/25/reactjs-conf/</link>
<guid>https://blog.othree.net/log/2015/04/25/reactjs-conf/</guid>
<category>script</category>
<pubDate>2015-04-25 15:41</pubDate>
</item>

<item>
<title>Loader</title>
<description><![CDATA[<p>Loader 是 ECMAScript 定義要來處理 module import/export 等等事情的底層介面，ES6 的 module 我一直都很好奇，到底要怎麼去找 import 進來模組的原始碼，會好奇這點是因為如果是網頁環境，所有其它模組的原始碼一定是在遠端的 server 上，要拿到勢必是一個 request，然後還要等下載，總之就是非同步的流程，以前在 ES5 的話，要做非同步控制大概就是要做成 callback 的形式，所以會有像 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> 那樣的設計出來，加上 module 名稱和檔案名稱可能又有差別，像是差個副檔名之類的，而 ES6 提供了原生的 import/export 語法來定義 module，所以我就很好奇它的底層要怎樣設計才能標準化。</p>
]]><![CDATA[<p>Addy Osmani 有建立一個 Loader 的 polyfill 給 ES5 環境使用 Loader API，就叫做 <a href="https://github.com/ModuleLoader/es6-module-loader">ES6 Module Loader Polyfill</a>，這個 polyfill 內部實做是照當初 ES6 draft 來寫的，其實還蠻複雜，不過把讀取一個 module 的事情拆分一下，可以分成以下幾個步驟：</p>

<ol>
<li>Normalize：根據給的名稱取得實際的 module name</li>
<li>Locate：根據實際的 module name 取得 module 的位置</li>
<li>Fetch：根據 module 位置去取得檔案內容</li>
<li>Translate：如果有需要對檔案內容作任何修改，就在這裡處理</li>
<li>Instaniate：最後是根據檔案內容（程式碼），判斷有哪些相依模組和知道如何初始化這個模組</li>
</ol>

<p>以上幾個步驟是屬於 Loader 可自訂化的部分，到 instaniate 完成後，Loader 就繼續去讀其它相依的模組，相依模組都準備好之後，就可以使用模組的的程式碼，正式的把模組建立起來，ES spec 細部還定義了很多實做細節，像是非同步的操作都是用 Promise 來做流程控制，還有 Loader 也有個 module 的 registry 可以來保存已經讀好的模組，就不用一直重新建立，另外還有一些內部溝通的資料結構，像 instaniate 步驟要回傳一個物件，裡面有兩個屬性分別是 <code>deps</code> 和 <code>execute</code>， <code>deps</code> 是相依模組名稱的陣列， <code>execute</code> 則是該模組本身的初始化函數，參數的數量要剛好和相依模組數量一樣，回傳的則是 Module 物件等等。</p>

<p>其實目前的 ES6 spec draft 已經把 Loader 拿掉了，TC39 決定把他獨立出來，目前是 WHATWG 接手<a href="https://github.com/whatwg/loader">繼續</a>，最新的版本已經改很大了，看起來感覺有簡化不少，不過上面的五個步驟基本上還是存在，我一開始看到這五個步驟加上說可以自訂還沒什麼感覺，只是覺得奇怪為什麼細節沒寫，沒錯，這五個步驟在 spec draft 都只有介紹目的，不像其它的操作有詳細的寫出 method 內的流程，關鍵的地方就在於 JavaScript 已經不是單純只是在瀏覽器上跑的語言了，把這部分抽象化就是為了讓它可以同時在瀏覽器環境和單機環境下都可以實做，根據不同的 JS 環境去實做相對應的步驟細節，像是 <code>fetch</code> 在瀏覽器下就是真的用 fetch 去拉檔案，但是在 node 下就變成讀檔案，而在 ES6 Module Loader Polyfill 下，就有實做一組瀏覽器環境下的操作，不過這組操作的實做未來也不會真的進到瀏覽器內，最大的問題在於第五個步驟的 instaniate。</p>

<p>Instaniate 這個步驟是要實做 ES6 module 一個很關鍵的部分，關鍵之處在於要把 module 的 dependency 找出來，在 ES6 module 裡面，有一個限制是每個 module 都必須要獨立一個檔案，所以不能一個檔案定義兩個 module，然後假設瀏覽器已經支援 ES6 module 了，只要 parse 程式碼成 AST 找出裡面的 <code>import</code> 就可以把 dependency 列出來。不過現在是 polyfill，瀏覽器也還不支援 <code>import</code>，所以要實做 instaniate 自然需要能處理這個問題，ES6 Module Loader Polyfill 的作法是使用 transpiler，目前支援 <a href="https://github.com/google/traceur-compiler">Traceur</a> 和 <a href="https://babeljs.io/">Babel</a>，把本來用 <code>import</code> 、 <code>export</code> 寫的模組轉成用類似的 AMD 模組定義的型式，而這邊用的型式是 <a href="https://github.com/systemjs/systemjs">systemjs</a> 裡面提供的 <a href="https://github.com/systemjs/systemjs/blob/master/lib/extension-register.js">System.register</a>，這個方法本身並不是 ES spec 裡面定義的，比較像是為了處理這尷尬時間點所設計的替代方案。</p>

<p>本來我是想看看，是不是能夠只靠 Loader 就把 ES6 的 module 機制在現在的瀏覽器上建立起來，結果發現只靠 ES6 Module Loader Polyfill 是辦不到的，Loader API 並沒有定義模組的語法，如果用 ES6 的語法來定義模組還需要 transpiler 來從程式碼中分析出 module dependency，不過我不太想要把整包 transpiler 也放到 translate 裡面用，雖然可以自己寫一個什麼事情都不做的 translate function，但是要解決 dependency 的話還是會需要像 <code>System.register</code> 的幫助，總之到這邊，可以發現一個重點是，Loader 不管 module 定義的方法，雖然假想情境下是用 ES6 module 語法，每個檔案代表一個 module，然後用 <code>import</code> 和 <code>export</code> 來定義相依模組和提供的 method，不過其實 Loader 也是可以處理 AMD、<a href="http://www.commonjs.org/specs/modules/1.0/">CommonJS</a> 甚至是 <a href="https://nodejs.org/api/modules.html">NodeJS</a> 型式的模組定義，只是要有人去實做這部分的 translate 和 instantiate 的部分，而 SystemJS最新版（0.16）就是這樣一個專案，它號稱是 universal module loader，支援 AMD、CommonJS、NodeJS 和 ES6 的模組定義，然後在最新的版本，改成使用 ES6 Module Loader Polyfill 的機制來做 module 的讀取、相依性的判斷和模組初始化，雖然有些地方沒有真的照之前的 spec 來實做。</p>

<p>另外一個之前不太清楚的問題也藉此搞清楚了，ES6 module 有限制一個檔案定義一個 module，而現在的 web application 常常為了效能問題，都把多個檔案合併成一個檔案，這時就不能用 ES6 module 了，當然也可以用像現在 SystemJS 的作法來處理，不過其實再過一兩年 HTTP/2 普及後，也不需要這樣搞了，會變成只需要 minimize，這部分倒是還可以接受。</p>

<p>ES6 裡面的 Loader 本身其實是一個 constructor，放在另外一個 ES6 提供的新東西 <code>Reflect</code> 下面，而用 <code>Reflect.Loader</code> 建立 Loader instance 時可以順便給他一些參數，像是前面提到的讀模組的五個步驟的實做，或是領域（realm），而 <code>System</code> 物件則是該 JS 環境下的預設的 Loader，理論上如果是瀏覽器環境，它就會知道怎樣去 fetch 遠端的程式碼回來，如果是 NodeJS 就會改用 file system 讀檔案，而且也知道要把模組放到那個 realm（理論上不同 frame 就是不同 realm），這樣大部分的使用都可以用 <code>System</code> 就好了，只有很少數的情形需要自己建立 Loader。其實上面說的 Loader API 不知道為什麼是移到 WHATWG 之後，幾乎是重新開始編寫，完整度欠佳，有些章節還是空的，另外也沒有定義 <code>System</code> 或是其它的新的替代方案，所以現在想要看看到底 Loader 內部怎麼做的話，要看舊版的 spec，可以去抓 2014 年 8 月的 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#august_24_2014_draft_rev_27">ES6 draft rev 27</a> 然後看看 CH 26, 15，對照 ES6 Module Loader Polyfill 的程式碼可能比好懂。</p>
]]></description>
<link>https://blog.othree.net/log/2015/04/05/loader/</link>
<guid>https://blog.othree.net/log/2015/04/05/loader/</guid>
<category>script</category>
<pubDate>2015-04-05 14:50</pubDate>
</item>

<item>
<title>ECMAScript 6 Final Draft Approved</title>
<description><![CDATA[<blockquote class="twitter-tweet" lang="zh-tw"><p>Ecma-TC39 just approved the final ES6 draft. It now goes to the Ecma General Assembly for approval in June</p>- Allen Wirfs-Brock (@awbjs) <a href="https://twitter.com/awbjs/status/580321916403216384">2015 3月 24日</a></blockquote>

<p>剛剛看到說 ECMAScript 2015(ES6) 定稿了，最後一版草稿是 RC4（還沒 release），接下來會是 ECMA 認證流程的樣子，不過繼續下一版的討論也不會中斷，順便要說一下他們最後 approve 的地方是在 H.R. Giger 博物館的酒吧，超酷的，這是畫異形那位大師的博物館。</p>

<blockquote class="twitter-tweet" lang="zh-tw"><p>Celebrated w/<a href="https://twitter.com/rebeccawb">@rebeccawb</a>  TC39 approval of ES6, at H.R. Giger Museum in Gruyère <a href="http://t.co/uEKzfozxX2">pic.twitter.com/uEKzfozxX2</a></p>- Allen Wirfs-Brock (@awbjs) <a href="https://twitter.com/awbjs/status/582239060539904000">2015 3月 29日</a></blockquote>

<script async="async" src="//platform.twitter.com/widgets.js" charset="utf-8"><!-- --></script>
]]>
</description>
<link>https://blog.othree.net/log/2015/03/30/ecmascript-6-final-draft/</link>
<guid>https://blog.othree.net/log/2015/03/30/ecmascript-6-final-draft/</guid>
<category>script</category>
<pubDate>2015-03-30 18:34</pubDate>
</item>

<item>
<title>CSP</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16440158642/" title="CSP by othree, on Flickr"><img src="https://farm9.staticflickr.com/8598/16440158642_62042f3837_b.jpg" width="791" height="1024" alt="CSP" srcset="https://farm9.staticflickr.com/8598/16440158642_62042f3837.jpg 768w, https://farm9.staticflickr.com/8598/16440158642_62042f3837_b.jpg 2x" /></a></p>

<p>Communicating Sequential Processes，簡稱 CSP，和 Content Security Policy 不一樣，是用來處理非同步執行序之間溝通的一個數學模型，我最早是在 Addy Osmani 的 <a href="https://medium.com/@addyosmani/javascript-application-architecture-on-the-road-to-2015-d8125811101b">JavaScript Application Architecture On The Road To 2015</a> 這篇文章裡面看到的，花了蠻多時間試著去瞭解，最近終於覺得懂一點皮毛可以紀錄一下了。</p>
]]><![CDATA[<p>CSP 其實不是新東西，是 <a href="http://en.wikipedia.org/wiki/Tony_Hoare">C. A. R. Hoare</a> 在 1978 年就發表的<a href="http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf">論文</a>(PDF)，1985 還出了整本書來介紹，而且<a href="http://www.usingcsp.com/cspbook.pdf">全文 PDF</a> 都有在網路上，可是這本書實在太理論了，看了一點點就看不下去，只好找其它資源，發現還真的蠻少的，但是確有找到一些近幾年的實做，像是 Go 的 routine 間用 channel 溝通，或是 Clojure 的 core.async，當然 Addy Osmani 那篇也有提到 JavaScript 的部分。</p>

<p>根據我目前淺薄的理解，CSP 就是用 channel 的非同步溝通機制，channel 怎麼用呢，顧名思義，就是一個傳遞訊息用的頻道，不過我覺得用管線可以更精確的描述它，而且這是一個單向的管線，一邊只能傳訊息進去，一邊只能拿訊息出來，可以達成非同步的溝通最主要在於拿訊息這邊，當你在其中一個 process 中說你要跟某個 channel 拿一個訊息出來時，如果那個 channel 裡面沒有東西，則這邊的 process 就會停下來等到那個 channel 有訊息出現，這個等待的機制不同語言有各自的方法實做。</p>

<p>先來看看 Go 的範例吧，因為實在是比 JavaScript 的直覺多了：</p>

<pre><code>package main
import "fmt"

func main() {
    messages := make(chan string, 1)

    messages &lt;- "ping"

    msg := &lt;-messages
    fmt.Println(msg)
}
</code></pre>

<p>這段程式碼是基於 Go by Example 說明 channel 的<a href="https://gobyexample.com/channels">範例</a>，程式碼很好理解，<code>messages := make(chan string, 1)</code>這行用 make 產生一個 channel 指派給 messages 這個變數，<code>messages &lt;- "ping"</code> 表示把 "ping" 這個字串丟進去 message 這個 channel 裡面，然後 <code>msg := &lt;-messages</code> 表示從 message channel 裡面抓訊息出來，丟到 msg 這個變數，<code>:=</code> 是指派同時宣告變數的運算子，<code>&lt;-</code> 則是用來描述操作中訊息傳遞方向用的運算子，當它是箭頭就很好理解，在 Go 裡面稱為 <a href="https://golang.org/ref/spec#Receive_operator">receive operator</a>。</p>

<p>在第一個例子當中，因為是先送資料進去 channel 才拿出來，所以還不太有感覺，接下來看第二個例子，一樣是 Go by Example 的，這段是 <a href="https://gobyexample.com/channel-synchronization">Channel Synchronization</a> 的範例：</p>

<pre><code>package main

import "fmt"
import "time"

func worker(done chan bool) {
    fmt.Print("working...")
    time.Sleep(time.Second)
    fmt.Println("done")

    done &lt;- true
}

func main() {

    done := make(chan bool, 1)
    go worker(done)

    &lt;-done
}
</code></pre>

<p>這個範例稍微複雜一點，<code>done := make(chan bool, 1)</code> 先產生一個 done channel，然後用 <code>go worker(done)</code> 產生一個 concurrent routine，跑的是 worker 這個 function，內容在 main 的上面，基本上就是 sleep 一下然後傳訊息回 done channel，然後 main 最後的 <code>&lt;-done</code> 就是從 done channel 拿訊息出來，先不管平行出去的 routine，通常的程式跑到這行結束，整個程式就結束關閉了，不過，就是這個不過，正常情況下，有 <code>&lt;-channel</code> 的話，該 routine 程式執行到這邊就會暫停下來，直到有從 channel 裡面拿到訊息才會繼續跑下去（或是裡面已經有訊息，直接拿到就繼續往下）。</p>

<p>Go 的 channel 還有一些細節可以參考 <a href="http://guzalexander.com/2013/12/06/golang-channels-tutorial.html">Golang channels tutorial</a> 這篇文章，其實就是一個可以跨 routine 的傳遞資料的管道，資料可以一直傳，沒有限制數量，不過還有一些相關的細節，像是 sync channel，還有 channel 的 buffer 等等。</p>

<p>綜合以上的兩個範例，可以歸納出來，要支援 CSP 有兩個必要條件，第一個是可以做得出 channel 物件的機制，可以放資料進去，可以拿資料出來，是先進先出機制，這部分其實不是問題，問題是第二個條件，程式碼要能跑一跑停下來等訊息然後又繼續跑下去，這可不是用 <code>while (1)</code> 可以處理的狀況，用 recursive function call 效能也不太好，以前的 JavaScript 是無法良好的達成第二個條件的，直到 ES6 的 async function 出現。</p>

<p>ES6 async function 之前有<a href="https://blog.othree.net/log/2014/05/24/es6-iterable/">文章</a>介紹過，這邊就不再說明，不過總之就是執行到 <code>yield</code> 後，這個 function call 就會先停下來，把值傳出，直到下次再次執行該 function 才會繼續往下執行，這樣停下來的機制，正好可以利用來作為 CSP 等訊息的機制，不過利用 <code>yield</code> 的話有一個限制，就是一定要在 async function 裡面才可以利用 channel，不像 Go 由於是建在語言裡面的，main thread 也可以跟 channel 溝通。</p>

<p>雖然說可以利用 async function 可以做出 CSP 的架構出來，不過要只用 async function 來寫出像 Go 那樣簡短的程式碼實在是很困難，中間還有很多機制需要補起來，所以就開始有 library 實做，目前最有名的是 <a href="https://github.com/ubolonton/js-csp">js-csp</a>，Facebook 最近的 React.js Conf 其中一場議程介紹 CSP 時也是用 js-csp 做範例，錄影在這，作為入門 CSP 我覺得是蠻不錯的一場演講：</p>

<iframe width="853" height="480" src="https://www.youtube.com/embed/W2DgDNQZOwo?list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>js-csp 裡面其實做了很多事情，目前看起來像是參考 Go 來設計，例如這樣的 Go <a href="http://talks.golang.org/2013/advconc.slide#6">程式碼</a>：</p>

<pre><code>package main
import "fmt"
import "time"

type Ball struct{ hits int }

func player(name string, table chan *Ball) {
    for {
        ball := &lt;-table
        ball.hits++
        fmt.Println(name, ball.hits)
        time.Sleep(100 * time.Millisecond)
        table &lt;- ball
    }
}

func main() {
    table := make(chan *Ball)
    go player("ping", table)
    go player("pong", table)

    table &lt;- new(Ball) // game on; toss the ball
    time.Sleep(1 * time.Second)
    &lt;-table // game over; grab the ball
}
</code></pre>

<p>改成用 js-csp 寫的話就變成：</p>

<pre><code>function* player(name, table) {
  while (true) {
    var ball = yield csp.take(table);
    if (ball === csp.CLOSED) {
      console.log(name + ": table's gone");
      return;
    }
    ball.hits += 1;
    console.log(name + " " + ball.hits);
    yield csp.timeout(100);
    yield csp.put(table, ball);
  }
}

csp.go(function* () {
  var table = csp.chan();

  csp.go(player, ["ping", table]);
  csp.go(player, ["pong", table]);

  yield csp.put(table, {hits: 0});
  yield csp.timeout(1000);
  table.close();
});
</code></pre>

<p>用 <code>csp.chan</code> 產生 channel，用 <code>yield csp.take</code> 代替從 channel 取訊息，用 <code>yield csp.put</code> 代替送訊息到 channel，然後最重要的是用 <code>csp.go</code> 來代替從 Go 裡面用 <code>go</code> 產生 routine 的操作，然後不說可能沒人注意到，js-csp 把 routine(<a href="https://github.com/ubolonton/js-csp/blob/master/src/impl/process.js">process</a>)、<a href="https://github.com/ubolonton/js-csp/blob/master/src/impl/dispatch.js">ticker</a> 等比較底層的基礎建設都做起來了，也就是如此才能讓程式碼和 Go 的看起來這麼接近。</p>

<p>js-csp 基本上就是仿照 Go 的的語法來設計，只是常常需要 yield，語法還是不如 Go 來的簡潔，至於何種情境比較適合使用 CSP 呢，以 channel 的特性來說，目前看起來是常常會發生的 event 比較適合，像是常常被拿出來講的 mousemove 事件，另外就是有要分 thread 做平行運算的話也不錯，不過目前看起來是無法接上 WebWorker，主要是因為 <code>postMessage</code> 無法傳遞物件 instance 過去，而是會<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm">複製</a>一份；另外因為 channel 可以關起來，所以要用來實做 Promise 也不是不行，不過就沒什麼必要如此搞就是。</p>

<p>講到做事件的處理，應該會有人注意到實做上的細節問題，就是要怎麼讓多個 process 去讀取同一個 channel 呢，一般而言，channel 的訊息是只能讀取一次的，就是說雖然你可以多個 process 等同一個 channel 的訊息，但是只會有一個 process 會真的拿到新的訊息，而實務上，一個事件綁了多個 handler 的情形非常常見，照 channel 的機制，應該是不能用下去的，不然就要自己管裡 handler，又多繞了一圈，事實上，CSP 模型是有一些<a href="https://github.com/ubolonton/js-csp/blob/master/src/csp.operations.js">運算</a>可以用的，像要處理多個 handler 的問題，就可以用 <code>mult</code>，可以把一個 channel 轉成<a href="http://rupsshankar.tumblr.com/post/66648884392/demystifying-core-asyncs-tap-and-mult">一對多</a>，其它還有多對一的 share resource、Clojure 的 onto <a href="http://www.slideshare.net/borgesleonardo/clojure-reducers-cljsyd-aug-2012?ref=http://www.leonardoborges.com/writings/presentations/">等等</a>，應該是想的到的情形都已經有數學模型或是不同語言的實做可以處理了，不過 js-csp 在這部分還在開發中，像是 mult 就還在 beta 階段，其實還不太能真的用，作者有說現在的介面可能會改，也因此還沒寫到文件裡面。</p>

<p>最後想要記錄一下 Clojure 所提出的 transducer，transducer 的目的是讓 reduce 的操作可以用 compose 來組合，什麼是 reduce  操作呢，其實包括像 map、filter 都可以算是，但是這些操作以前是無法用 function composition 來做組合的，直到有了 transducer，又加上 transducer 把處理資料的型別也 decouple 出去了，所以 channel message 也可以利用。有兩篇文章可以參考，第一篇文章是 <a href="http://phuu.net/2014/08/31/csp-and-transducers.html">CSP and transducers in JavaScript</a>，這篇講得非常清楚，他是從無到有把 transducer 建構起來，我是第二次認真看這篇文章才理解的，另外一篇文章是 <a href="http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data">Transducers.js: A JavaScript Library for Transformation of Data</a>，是 Transducer.js 的作者寫的，從不太一樣的角度來看 Transducer 這個設計，有機會再來分享詳細一點。</p>

<p>這篇文章其實也不算是介紹或教學 CSP on JavaScript，比較是記錄一些我花時間想辦法理解的問題，包括為什麼現在才有人用 JavaScript 實做 CSP，實際上怎麼實做，目前適用的地方，還有整理了對 transducer 的理解，如果單純是想理解 CSP，除了前面提到的文章之外，還有幾篇文章可以參考 <a href="https://swannodette.github.io/2013/08/24/es6-generators-and-csp/">ES6 Generators Deliver Go Style Concurrency</a>、<a href="http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript">Taming the Asynchronous Beast with CSP Channels in JavaScript</a>。</p>
]]></description>
<link>https://blog.othree.net/log/2015/02/14/csp/</link>
<guid>https://blog.othree.net/log/2015/02/14/csp/</guid>
<category>script</category>
<pubDate>2015-02-14 15:26</pubDate>
</item>

<item>
<title>fetch 二三事</title>
<description><![CDATA[<p>之前介紹過 fetch 之後過了一段時間，有發現幾個目前 spec 上的一些細節要來分享一下。首先是上一篇文章說到的重複 header 的問題，詳細看下去後，發現 fetch 收的 header 參數有兩種，一個是 key value pair 的原生物件，另外一種是 Headers 物件，這個物件是 fetch spec 裡面新定義的：</p>

<pre><code>var h = new Headers();
h.append('X-Custom-Header', '1');
h.append('X-Custom-Header', '2');
h.append('X-Custom-Header', '3');
</code></pre>

<p>就可以像這樣用 <code>append</code> 重複加上同樣名稱的 Header，其實丟原生的物件進去，也會在內部被轉成這個 Header 物件。</p>

<p>第二個要說的是關於回應 status code 在 400 到 600 之間時，Promise 物件是 resolve 不是 reject，理由是 Error 和 Exception 不一樣，不過有人開 Issue 在討論，會不會有改變還不知道，倒是如果現在用 github polyfill 想要處理這個問題的話，除了可以自己處理之外，也有人寫了 <a href="https://github.com/matthew-andrews/fetchres">fetchres</a> 這個，wrapper 可以把 fetch 的一些行為弄得更接近大部分開發者的直覺，目前提供的功能除了這個之外，還有一個是如果回傳的 type 是 JSON，但是內容的 JSON 語法有錯，那也會被丟到 reject 那邊去。</p>
]]>
</description>
<link>https://blog.othree.net/log/2015/01/16/more-fetch/</link>
<guid>https://blog.othree.net/log/2015/01/16/more-fetch/</guid>
<category>script</category>
<pubDate>2015-01-16 12:31</pubDate>
</item>

<item>
<title>關於 TypeScript</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15756461070/" title="type-error by othree, on Flickr"><img src="https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca_b.jpg" width="1024" height="261" alt="type-error" srcset="https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca.jpg 768w, https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca_b.jpg 2x" /></a></p>

<p>這幾年各種 compile to JavaScript language 盛行，大部分都是朝向讓程式碼更好寫的方向來前進，微軟在 2012 年也推出了 <a href="http://www.typescriptlang.org/">TypeScript</a> 這個 compile to JavaScript language，不過他的方向卻不一樣，TypeScript 是一個 JavaScript 的 superset，意思就是所有的 JavaScript 都是合法的 TypeScript，而 TypeScript 多了一些語法，加入了一些新功能，不過這些新的語法完全都不用也是可以正常的寫程式，給 TypeScript compiler 編譯。</p>

<p>TypeScript 顧名思義，它著重的在資料型別這個部分，JavaScript 是 weak type （弱型別）的語言，寫起來算是很方便，不過這個特性卻也是一些問題的來源，首先最常見到的是因為資料型態不嚴謹而造成的 bug，第二個常被提出來的就是為了實做 weak type 而造成的 performance 下降，因此一直有一些聲音在對抗弱型別這個特性，第一個是 Douglas Crockford 先出聲的，不過一開始是從程式碼的嚴謹和可靠性來說的，因為他當時主力在 <a href="http://www.jslint.com/">JSLint</a> 上，所以對於可靠的程式碼的要求比較高，JSLint 一度還把這項檢查放入，後來接著 Google V8 引擎也對沒有改變型別的變數作了最佳化，然後有 TypeScript，接著未來的 ES7 也可能會加入型別宣告的語法進來，這部分似乎是 Douglas 參與推動的，然後 Google 也打算推出 <a href="https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/mobilebasic?pli=1&amp;viewopt=127">AtScript</a> 的樣子，AtScript 是 TypeScript 的 superset，更進一步增加了型別相關的特性進來。</p>

<p>TypeScript 是一個介於中間的語言，當然為了支援  JavaScript 不能直接把整個環境都改成強型別的，所以 TypeScript 的作法是讓形別的宣告變為可省略的，如果沒有宣告型別，則一切和以前一樣，如果你的變數有宣告型別，那個變數才會是強型別，在編譯的時候，如果把不同型別的值給它，就會跑出警告訊息，像是 JSLint 一樣。TypeScript 的型別宣告語法中，一些比較簡單的可以和程式碼一起寫：</p>

<pre><code>var str:string;
</code></pre>

<p>可是稍微複雜一點，和物件有關係的話，就要獨立寫一段宣告的程式碼了：</p>

<pre><code>interface HotkeysProvider {
    template: string;
    includeCheatSheet: boolean;
    get(combo: string): ng.hotkeys.Hotkey;
    toggleCheatSheet(): void;
}
</code></pre>

<p>這段宣告其實是完全獨立於程式碼的邏輯本身，全部砍掉程式也可以運作，本身不牽涉到任何邏輯，所以可以完全獨立出去，在 TypeScript 中稱為 type definition（型別定義） ，常用的副檔名是 <code>.d.ts</code>，感覺上很像是 C 語言的 header file，其實我對於 TypeScript 本身的發展是不太樂觀的，覺得他的佔有率永遠不會起來，但是它的型別定義這塊我到覺得是大有可為，主因是目前沒有比較在業界有使用的到型別定義的語言，寫標準所用的 <a href="http://www.w3.org/TR/WebIDL/#idl">WebIDL</a> 普極度實在很低，相關的工具開發和支援實在很少，反而 .d.ts 檔知道的人比較多，編譯器也都有了，而且多虧 TypeScript 有開放原碼，事實上也有其它專案有借助 TypeScript 定義檔，像是我在用的 <a href="http://ternjs.net/">TernJS</a> 這個 JavaScript 自動補完工具，就有提供一個 <a href="https://github.com/marijnh/tern/blob/master/bin/from_ts">from_ts 工具</a> 可以把 .d.ts 檔轉成它可以讀的定義檔案，加上有 <a href="http://definitelytyped.org/">DefinitelyType</a> 專案，各種不同 JavaScript Library 的定義檔都已經有了，所以 TernJS 就可以利用這些資源，提供各種 Library 的自動補完支援了，不過前提是使用者要知道有這些東西，官方文件其實沒有把這塊講得這麼連貫。</p>

<p>除了 TernJS 的應用外，我相信這些定義檔還可以讓編輯器或是 IDE 可以提供更多的輔助功能，像是或許可以拿來產生編輯器用的 syntax 定義檔，在編寫程式時直接提出警告等等，其實現在想的到的這些功能微軟的 Visuall Studio 應該都有了，不過有個公定格式做中介還是比較方便第三方應用，雖然目前好像只有看到 TernJS 的第三方應用，有些可惜，而且微軟的 Compiler 常常偷改，TernJS 提供的 <code>from_ts</code> 是需要使用到一些 compiler 內部的 function 才能用的，而從我接觸 TernJS 以來，微軟至少已經改過兩次改很大造成 <code>from_ts</code>完全不能用的情形。</p>

<p>總之微軟的 TypeScript 我覺得使用人數也不會有什麼大變化，但是定義檔 <code>.d.ts</code> 的部分倒是比較可以期待，變成半個 JS 用的標準介面定義文件格式，競爭對手的話應該是 WebIDL 吧，不過 WebIDL 比較不親切，也不太有人去實做和推廣他的應用，ES7 的型別暗示其實是只是針對那五個基本型別為主，沒有像 WebIDL 和 TypeScript 那樣完整。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/12/04/typescript-definition/</link>
<guid>https://blog.othree.net/log/2014/12/04/typescript-definition/</guid>
<category>script</category>
<pubDate>2014-12-04 23:06</pubDate>
</item>

<item>
<title>前端工程師都應該知道的 fetch</title>
<description><![CDATA[<p>之前介紹 ES6 Promise 的時候就有提到一些過去的標準應該也可以更新到來支援 Promise，沒想到就看到 WHATWG 的 <a href="https://fetch.spec.whatwg.org/">fetch</a> 了，fetch 就是個 <a href="https://developer.mozilla.org/zh-TW/docs/DOM/XMLHttpRequest">XMLHttpRequest</a>（XHR）的 替代品，幾乎是集了這幾年前端領域 Pattern 之大成。</p>

<p>首先是命名很簡單，和 XHR 完全不一樣，那個時期的網路標準的命名都很繁雜，尤其像是 XML Schema 的那個時期，聽說是找了些語言學家來一起制訂的，那個時期的東西很多都名稱弄的很冗長，當然不可否認這樣有個好處是比較容易理解東西的源由，像 XHR 看名字就可以知道其實主要目的是為了抓 XML，而那個時期會想要抓 XML 大概就是為了 SOAP 協定的 Web Service 吧，只是真的用來抓 XML 的已經很少了，一直用這個名稱早就已經覺得很奇怪了，至於新的 fetch 顧名思義就是為了抓東西用的，反而和現在 XHR 使用的情境很符合，而且命名很簡單，好記，就像是 jQuery 的 <code>on</code> 取代了 <code>addEventListener</code> 一樣。（PS: 另外有一個叫 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/Beacon/Overview.html">sendBeacon</a> 的是只管送出，不管回來的東西的。）</p>

<p>第二個特點是使用了 <a href="https://blog.othree.net/log/2013/06/19/options-object/">Options Object</a>，不過 XHR 倒也不是收很多參數，他的設計是先產生物件後才對它操作：</p>

<pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', 'test.html');
xhr.setRequestHeader('Tester-Name', 'mike');
xhr.setRequestHeader('Tester-Name ', 'peter');
xhr.send();
</code></pre>

<p>雖然沒有搞不清楚參數順序的問題，卻也是多了很多步驟才能達成目標，不過其實產生了 XHR 物件但是卻不送出 request 的使用情境我實在想不太到，大概是因此，新的 fetch 才改成像是 jQuery 的 <code>$.ajax</code> 那樣，產生物件時直接就發出 request 了吧。</p>

<p>第三個特點當然就是回傳的是 ES6 Promise 物件，另外也支援 FormData 等等新東西，不過要說能不能完全取代 XHR 呢？目前看起來是不行的，最主要是因為 ES6 Promise 並沒有支援 progress 的機制，而且已經不是 event-based 的物件了，所以沒辦法抓上傳進度之類的資訊。</p>

<p>因為這個 spec 還很新，目前是沒瀏覽器支援，不過 Github 有提供一個 <a href="https://github.com/github/fetch">polyfill</a> 了，把基本的功能都做好了（還有缺一些比較少用到的細節），有興趣想開始用的人可以從這邊開始，大概要注意的有兩個，第一個是因為它是用 ES6 Promise，所以還要引入 ES6 Promise polyfill，第二個是回傳資料的處理，雖然 fetch 在發 request 的時候和 jQuery 的設計很像，不過回傳的資料處理方式就差距比較大了。</p>

<p>jQuery 的 ajax 收到 Response Body 時，會自動根據 Header 的 Content-Type 來處理，像是 JSON 會自動用 <code>JSON.parse</code> 把文字轉成 JS 物件，不過 fetch 不會，根據 spec 所說， fetch 算是一個底層的 library，所以這種事情就要自己來了：</p>

<pre><code>fetch("https://pk.example/berlin-calling.json", {mode:"cors"})
  .then(res =&gt; {
  if(res.headers.get("content-type") == "application/json") {
    return res.json()
  } else {
    throw new TypeError()
  }
}).then(processJSON)
</code></pre>

<p>fetch 需要你自己在程式碼裡面判斷回傳資料的格式是什麼，然後可以用它提供的 method 擷取到相對應格式的資料，像是這個例子中抓的是 JSON 格式的資料，就直接執行 Response 物件的 <code>json</code> 這個 method，當然你也可以不判斷就直接執行 <code>json()</code>，只是無法 parse 時會直接 throw error 出來，又因為在 Promise 串接過程中，後面就會跑到 reject 的 callback function 那邊去，除了 <code>json</code> 外，其他支援的還有 <code>arrayBuffer</code>、<code>blob</code>、<code>formData</code> 和 <code>text</code>。這些從 response 物件中讀取 body 資料出來的動作（spec 中稱為 consume）只能操作一次，如果真的很想讀很多次，建議是直接把回傳資料的那個 Promise 儲存起來，還有一個方法是用 clone 複製 Response 物件，不確定那個方法好就是了，這部分這樣設計的原因似乎是為了處理少一點事情，讓效能比較好。</p>

<p>而除了 Response Body 外，其它的回傳資訊像是 Response Header 等，都有新定義的物件來儲存，不過沒有很複雜，設計的很直覺，和送出去的 Options Object 很接近。不過講到 Header 就有一點還是要說一下，其實 HTTP Header 是可以重複送出一樣的 key 的，先不管合不合規範，現實是 HTTP Protocol 的實作都還可以處理這種狀況，以前的 XHR 也可以做出這樣的行為，印象中也有 framework 會這樣用，不過不太確定，總之 fetch 因為 Header 是給 Options Object 中的一個物件，而物件的 key 不能重複，所以不會允許這種行為出現，我個人是覺得這樣其實也比較好啦。</p>

<p>目前這個標準還未廣為人知，但是我是覺得前景非常看好，Spec 寫的也異常詳細，雖然不能把 XHR 的所有功能都取代，不過大部分的 XHR 應用都可以用的上了，也有 Github 提供的 polyfill，應該很容易吸引人進去使用，加上也沒其它的類似候選標準，除了沒有 progress 和回來的資料格式要自己判斷外，應該是沒什麼缺點了，而且判斷資料格式的部分也是可以自己寫點程式碼把他處理掉，所以嚴格一點說的話，問題就剩下沒有 progress 可以看這點了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/11/25/fetch/</link>
<guid>https://blog.othree.net/log/2014/11/25/fetch/</guid>
<category>script</category>
<pubDate>2014-11-25 20:48</pubDate>
</item>

<item>
<title>ES6 Promise</title>
<description><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ES6 Promise</a> 目前各家瀏覽器的支援程度雖然還沒到可以直接用的程度，但是目前已經有非常多的 polyfill，差不多是可以開始使用的時候了。</p>

<p>如果習慣了 jQuery 設計的 Deferred 物件，應該會對於 ES6 的 Promise 設計很不習慣吧，相較於 jQuery 是產生好物件然後提供一些 method 做操作，要不要封裝起來也是開發者的事，ES6 Promise 的設計更是強調了封裝的特性，要怎麼 resolve、reject，在一開始就要決定好了，只有在建構函數裡面碰的到 resolve 和 reject 的觸發點：</p>

<pre><code>new Promise(function (resolve, reject) {
  //...
});
</code></pre>

<p>這樣的設計雖然在物件封裝上比較嚴謹，但是其實會讓一些程式碼多了一層的縮排，例如本來用 jQuery Deferred 包起來的 XHR：</p>

<pre><code>function JQXHR(url) {
  var xhr = new XMLHttpRequest();
  var dfd = new $.Deferred();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) { dfd.resolve(xhr.response); }
  }
  xhr.open('GET', url);
  xhr.send();
  return dfd.promise();
}
</code></pre>

<p>用 ES6 Promise 就要改寫成：</p>

<pre><code>function ESXHR(url) {
  var xhr = new XMLHttpRequest();
  var dfd = new Promise(function (resolve) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) { resolve(xhr.response); }
    }
  });
  xhr.open('GET', url);
  xhr.send();
  return dfd;
}
</code></pre>

<p>第二個差異就在於回傳的 thenable 物件要怎麼把結果改掉，以前 jQuery 的時候可以在 callback 裡面回傳新的 Deferred 物件改結果：</p>

<pre><code>dfd.then(null, function () {
  return $.Deferred().resolve();
});
</code></pre>

<p>沒特別傳 Deferred 物件的話不管用 <code>then</code> 串接幾次的話結果都不會改變，不過 ES6 Promise 就不一樣了，不管是 resolve 狀況還是 reject 狀況，<code>then</code> 回傳的預設就是一個新的 resolved 狀態的 Promise 物件。那要怎樣改變狀態呢？這裡就要用 <code>throw new Error()</code> 了。在 ES6 Promise 的 <code>then</code> 裡面，不管是 resolve 還是 reject 的 handler，都是回傳任意值會讓後面拿到新的 resolved 的 Promise 物件，而如果在執行中 throw error 出去，就會讓後面拿到 rejected 的 Promise 物件：</p>

<pre><code>dfd.then(function (val) {
  if (val === 0) {
    throw new Error('');
  }
});
</code></pre>

<p>然後就是 rejected 狀態的 Promise 也是有值的，如果是 throw error 產生的，那就是看 throw 什麼東西，那個東西就會變成新的 Promise 物件的值，而以往手動 throw error 時，為了相容性都會產生 Error 物件，在這邊就不必如此了，其實可以隨便傳想要給後面使用的值。</p>

<p>再來，有時候只想要處理 reject 的狀況，會寫成：</p>

<pre><code>dfd.then(null, function () {
  //rejected handler
});
</code></pre>

<p>有個 null 放前面其實蠻討厭的，不過 ES6 有提供一個 <code>catch</code> 可以用： </p>

<pre><code>dfd.catch(function () {
  //rejected handler
});
</code></pre>

<p>這個以前倒是沒有類似的東西，蠻方便的。大概瞭解到這樣就可以使用 ES6 Promise 了，另外還有 <code>Promise.all</code> 和 <code>Promise.race</code> 可以做和 <code>jQuery.when</code> 類似的事情（race 是新的控制），至於我為什麼說現在差不多可以開始使用呢，除了 Polyfill 齊全外，其實還有一個原因是一些新的網路標準也開始使用 ES6 Promise 了，像是 <a href="http://www.w3.org/TR/WebCryptoAPI/">Web Crypto</a>，看 spec 比較不明顯，不過看 MDN 的<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">介紹</a>，就有列出 encrypt、decrypt、sign 等花時間的 method 回傳都是 Promise 物件，實做就可以丟到背景的 Worker 去處理，才不會把 UI 卡住。而除了 Web Crypto 外，還有像是 ES7 可能會有的 <a href="http://jakearchibald.com/2014/es7-async-functions/">await</a> 語法也是要接 Promise 物件，總之是個未來趨勢，我覺得現在比較尷尬的是在 ES6 Promise 出來前的一堆標準都是用 event base 設計的，像是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader">File Reader</a> 之類的，不知道有沒有機會慢慢都改到 Promise。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/11/13/es6-promise/</link>
<guid>https://blog.othree.net/log/2014/11/13/es6-promise/</guid>
<category>script</category>
<pubDate>2014-11-13 23:54</pubDate>
</item>

<item>
<title>node-ffi</title>
<description><![CDATA[<p>今年的 JSDC 分享的是 node-ffi，不過我覺得沒講很好，反而練習講得比較好...</p>

<script async="async" class="speakerdeck-embed" data-id="fcbffc9033fa013238ec56e996df704e" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]>
</description>
<link>https://blog.othree.net/log/2014/10/13/node-ffi/</link>
<guid>https://blog.othree.net/log/2014/10/13/node-ffi/</guid>
<category>script</category>
<pubDate>2014-10-13 22:48</pubDate>
</item>


</channel>
</rss>