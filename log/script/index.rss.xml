<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>O3noBLOG - script</title>
<link>https://blog.othree.net//log/ script/</link>
<description></description>
<copyright>Copyright 2014</copyright>
<lastBuildDate>2014-12-04 23:06</lastBuildDate>
<generator>http://www.movabletype.org/?v=4.381</generator>
<docs>http://blogs.law.harvard.edu/tech/rss</docs> 


<item>
<title>關於 TypeScript</title>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15756461070/" title="type-error by othree, on Flickr"><img src="https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca_b.jpg" width="1024" height="261" alt="type-error" srcset="https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca.jpg 768w, https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca_b.jpg 768w 2x" /></a></p>

<p>這幾年各種 compile to JavaScript language 盛行，大部分都是朝向讓程式碼更好寫的方向來前進，微軟在 2012 年也推出了 <a href="http://www.typescriptlang.org/">TypeScript</a> 這個 compile to JavaScript language，不過他的方向卻不一樣，TypeScript 是一個 JavaScript 的 superset，意思就是所有的 JavaScript 都是合法的 TypeScript，而 TypeScript 多了一些語法，加入了一些新功能，不過這些新的語法完全都不用也是可以正常的寫程式，給 TypeScript compiler 編譯。</p>

<p>TypeScript 顧名思義，它著重的在資料型別這個部分，JavaScript 是 weak type （弱型別）的語言，寫起來算是很方便，不過這個特性卻也是一些問題的來源，首先最常見到的是因為資料型態不嚴謹而造成的 bug，第二個常被提出來的就是為了實做 weak type 而造成的 performance 下降，因此一直有一些聲音在對抗弱型別這個特性，第一個是 Douglas Crockford 先出聲的，不過一開始是從程式碼的嚴謹和可靠性來說的，因為他當時主力在 <a href="http://www.jslint.com/">JSLint</a> 上，所以對於可靠的程式碼的要求比較高，JSLint 一度還把這項檢查放入，後來接著 Google V8 引擎也對沒有改變型別的變數作了最佳化，然後有 TypeScript，接著未來的 ES7 也可能會加入型別宣告的語法進來，這部分似乎是 Douglas 參與推動的，然後 Google 也打算推出 <a href="https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/mobilebasic?pli=1&amp;viewopt=127">AtScript</a> 的樣子，AtScript 是 TypeScript 的 superset，更進一步增加了型別相關的特性進來。</p>

<p>TypeScript 是一個介於中間的語言，當然為了支援  JavaScript 不能直接把整個環境都改成強型別的，所以 TypeScript 的作法是讓形別的宣告變為可省略的，如果沒有宣告型別，則一切和以前一樣，如果你的變數有宣告型別，那個變數才會是強型別，在編譯的時候，如果把不同型別的值給它，就會跑出警告訊息，像是 JSLint 一樣。TypeScript 的型別宣告語法中，一些比較簡單的可以和程式碼一起寫：</p>

<pre><code>var str:string;
</code></pre>

<p>可是稍微複雜一點，和物件有關係的話，就要獨立寫一段宣告的程式碼了：</p>

<pre><code>interface HotkeysProvider {
    template: string;
    includeCheatSheet: boolean;
    get(combo: string): ng.hotkeys.Hotkey;
    toggleCheatSheet(): void;
}
</code></pre>

<p>這段宣告其實是完全獨立於程式碼的邏輯本身，全部砍掉程式也可以運作，本身不牽涉到任何邏輯，所以可以完全獨立出去，在 TypeScript 中稱為 type definition（型別定義） ，常用的副檔名是 <code>.d.ts</code>，感覺上很像是 C 語言的 header file，其實我對於 TypeScript 本身的發展是不太樂觀的，覺得他的佔有率永遠不會起來，但是它的型別定義這塊我到覺得是大有可為，主因是目前沒有比較在業界有使用的到型別定義的語言，寫標準所用的 <a href="http://www.w3.org/TR/WebIDL/#idl">WebIDL</a> 普極度實在很低，相關的工具開發和支援實在很少，反而 .d.ts 檔知道的人比較多，編譯器也都有了，而且多虧 TypeScript 有開放原碼，事實上也有其它專案有借助 TypeScript 定義檔，像是我在用的 <a href="http://ternjs.net/">TernJS</a> 這個 JavaScript 自動補完工具，就有提供一個 <a href="https://github.com/marijnh/tern/blob/master/bin/from_ts">from_ts 工具</a> 可以把 .d.ts 檔轉成它可以讀的定義檔案，加上有 <a href="http://definitelytyped.org/">DefinitelyType</a> 專案，各種不同 JavaScript Library 的定義檔都已經有了，所以 TernJS 就可以利用這些資源，提供各種 Library 的自動補完支援了，不過前提是使用者要知道有這些東西，官方文件其實沒有把這塊講得這麼連貫。</p>

<p>除了 TernJS 的應用外，我相信這些定義檔還可以讓編輯器或是 IDE 可以提供更多的輔助功能，像是或許可以拿來產生編輯器用的 syntax 定義檔，在編寫程式時直接提出警告等等，其實現在想的到的這些功能微軟的 Visuall Studio 應該都有了，不過有個公定格式做中介還是比較方便第三方應用，雖然目前好像只有看到 TernJS 的第三方應用，有些可惜，而且微軟的 Compiler 常常偷改，TernJS 提供的 <code>from_ts</code> 是需要使用到一些 compiler 內部的 function 才能用的，而從我接觸 TernJS 以來，微軟至少已經改過兩次改很大造成 <code>from_ts</code>完全不能用的情形。</p>

<p>總之微軟的 TypeScript 我覺得使用人數也不會有什麼大變化，但是定義檔 <code>.d.ts</code> 的部分倒是比較可以期待，變成半個 JS 用的標準介面定義文件格式，競爭對手的話應該是 WebIDL 吧，不過 WebIDL 比較不親切，也不太有人去實做和推廣他的應用，ES7 的型別暗示其實是只是針對那五個基本型別為主，沒有像 WebIDL 和 TypeScript 那樣完整。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/12/04/typescript-definition/</link>
<guid>https://blog.othree.net/log/2014/12/04/typescript-definition/</guid>
<category>script</category>
<pubDate>2014-12-04 23:06</pubDate>
</item>

<item>
<title>前端工程師都應該知道的 fetch</title>
<description><![CDATA[<p>之前介紹 ES6 Promise 的時候就有提到一些過去的標準應該也可以更新到來支援 Promise，沒想到就看到 WHATWG 的 <a href="https://fetch.spec.whatwg.org/">fetch</a> 了，fetch 就是個 <a href="https://developer.mozilla.org/zh-TW/docs/DOM/XMLHttpRequest">XMLHttpRequest</a>（XHR）的 替代品，幾乎是集了這幾年前端領域 Pattern 之大成。</p>

<p>首先是命名很簡單，和 XHR 完全不一樣，那個時期的網路標準的命名都很繁雜，尤其像是 XML Schema 的那個時期，聽說是找了些語言學家來一起制訂的，那個時期的東西很多都名稱弄的很冗長，當然不可否認這樣有個好處是比較容易理解東西的源由，像 XHR 看名字就可以知道其實主要目的是為了抓 XML，而那個時期會想要抓 XML 大概就是為了 SOAP 協定的 Web Service 吧，只是真的用來抓 XML 的已經很少了，一直用這個名稱早就已經覺得很奇怪了，至於新的 fetch 顧名思義就是為了抓東西用的，反而和現在 XHR 使用的情境很符合，而且命名很簡單，好記，就像是 jQuery 的 <code>on</code> 取代了 <code>addEventListener</code> 一樣。（PS: 另外有一個叫 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/Beacon/Overview.html">sendBeacon</a> 的是只管送出，不管回來的東西的。）</p>

<p>第二個特點是使用了 <a href="https://blog.othree.net/log/2013/06/19/options-object/">Options Object</a>，不過 XHR 倒也不是收很多參數，他的設計是先產生物件後才對它操作：</p>

<pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', 'test.html');
xhr.setRequestHeader('Tester-Name', 'mike');
xhr.setRequestHeader('Tester-Name ', 'peter');
xhr.send();
</code></pre>

<p>雖然沒有搞不清楚參數順序的問題，卻也是多了很多步驟才能達成目標，不過其實產生了 XHR 物件但是卻不送出 request 的使用情境我實在想不太到，大概是因此，新的 fetch 才改成像是 jQuery 的 <code>$.ajax</code> 那樣，產生物件時直接就發出 request 了吧。</p>

<p>第三個特點當然就是回傳的是 ES6 Promise 物件，另外也支援 FormData 等等新東西，不過要說能不能完全取代 XHR 呢？目前看起來是不行的，最主要是因為 ES6 Promise 並沒有支援 progress 的機制，而且已經不是 event-based 的物件了，所以沒辦法抓上傳進度之類的資訊。</p>

<p>因為這個 spec 還很新，目前是沒瀏覽器支援，不過 Github 有提供一個 <a href="https://github.com/github/fetch">polyfill</a> 了，把基本的功能都做好了（還有缺一些比較少用到的細節），有興趣想開始用的人可以從這邊開始，大概要注意的有兩個，第一個是因為它是用 ES6 Promise，所以還要引入 ES6 Promise polyfill，第二個是回傳資料的處理，雖然 fetch 在發 request 的時候和 jQuery 的設計很像，不過回傳的資料處理方式就差距比較大了。</p>

<p>jQuery 的 ajax 收到 Response Body 時，會自動根據 Header 的 Content-Type 來處理，像是 JSON 會自動用 <code>JSON.parse</code> 把文字轉成 JS 物件，不過 fetch 不會，根據 spec 所說， fetch 算是一個底層的 library，所以這種事情就要自己來了：</p>

<pre><code>fetch("https://pk.example/berlin-calling.json", {mode:"cors"})
  .then(res =&gt; {
  if(res.headers.get("content-type") == "application/json") {
    return res.json()
  } else {
    throw new TypeError()
  }
}).then(processJSON)
</code></pre>

<p>fetch 需要你自己在程式碼裡面判斷回傳資料的格式是什麼，然後可以用它提供的 method 擷取到相對應格式的資料，像是這個例子中抓的是 JSON 格式的資料，就直接執行 Response 物件的 <code>json</code> 這個 method，當然你也可以不判斷就直接執行 <code>json()</code>，只是無法 parse 時會直接 throw error 出來，又因為在 Promise 串接過程中，後面就會跑到 reject 的 callback function 那邊去，除了 <code>json</code> 外，其他支援的還有 <code>arrayBuffer</code>、<code>blob</code>、<code>formData</code> 和 <code>text</code>。這些從 response 物件中讀取 body 資料出來的動作（spec 中稱為 consume）只能操作一次，如果真的很想讀很多次，建議是直接把回傳資料的那個 Promise 儲存起來，還有一個方法是用 clone 複製 Response 物件，不確定那個方法好就是了，這部分這樣設計的原因似乎是為了處理少一點事情，讓效能比較好。</p>

<p>而除了 Response Body 外，其它的回傳資訊像是 Response Header 等，都有新定義的物件來儲存，不過沒有很複雜，設計的很直覺，和送出去的 Options Object 很接近。不過講到 Header 就有一點還是要說一下，其實 HTTP Header 是可以重複送出一樣的 key 的，先不管合不合規範，現實是 HTTP Protocol 的實作都還可以處理這種狀況，以前的 XHR 也可以做出這樣的行為，印象中也有 framework 會這樣用，不過不太確定，總之 fetch 因為 Header 是給 Options Object 中的一個物件，而物件的 key 不能重複，所以不會允許這種行為出現，我個人是覺得這樣其實也比較好啦。</p>

<p>目前這個標準還未廣為人知，但是我是覺得前景非常看好，Spec 寫的也異常詳細，雖然不能把 XHR 的所有功能都取代，不過大部分的 XHR 應用都可以用的上了，也有 Github 提供的 polyfill，應該很容易吸引人進去使用，加上也沒其它的類似候選標準，除了沒有 progress 和回來的資料格式要自己判斷外，應該是沒什麼缺點了，而且判斷資料格式的部分也是可以自己寫點程式碼把他處理掉，所以嚴格一點說的話，問題就剩下沒有 progress 可以看這點了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/11/25/fetch/</link>
<guid>https://blog.othree.net/log/2014/11/25/fetch/</guid>
<category>script</category>
<pubDate>2014-11-25 20:48</pubDate>
</item>

<item>
<title>ES6 Promise</title>
<description><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ES6 Promise</a> 目前各家瀏覽器的支援程度雖然還沒到可以直接用的程度，但是目前已經有非常多的 polyfill，差不多是可以開始使用的時候了。</p>

<p>如果習慣了 jQuery 設計的 Deferred 物件，應該會對於 ES6 的 Promise 設計很不習慣吧，相較於 jQuery 是產生好物件然後提供一些 method 做操作，要不要封裝起來也是開發者的事，ES6 Promise 的設計更是強調了封裝的特性，要怎麼 resolve、reject，在一開始就要決定好了，只有在建構函數裡面碰的到 resolve 和 reject 的觸發點：</p>

<pre><code>new Promise(function (resolve, reject) {
  //...
});
</code></pre>

<p>這樣的設計雖然在物件封裝上比較嚴謹，但是其實會讓一些程式碼多了一層的縮排，例如本來用 jQuery Deferred 包起來的 XHR：</p>

<pre><code>function JQXHR(url) {
  var xhr = new XMLHttpRequest();
  var dfd = new $.Deferred();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) { dfd.resolve(xhr.response); }
  }
  xhr.open('GET', url);
  xhr.send();
  return dfd.promise();
}
</code></pre>

<p>用 ES6 Promise 就要改寫成：</p>

<pre><code>function ESXHR(url) {
  var xhr = new XMLHttpRequest();
  var dfd = new Promise(function (resolve) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) { resolve(xhr.response); }
    }
  });
  xhr.open('GET', url);
  xhr.send();
  return dfd;
}
</code></pre>

<p>第二個差異就在於回傳的 thenable 物件要怎麼把結果改掉，以前 jQuery 的時候可以在 callback 裡面回傳新的 Deferred 物件改結果：</p>

<pre><code>dfd.then(null, function () {
  return $.Deferred().resolve();
});
</code></pre>

<p>沒特別傳 Deferred 物件的話不管用 <code>then</code> 串接幾次的話結果都不會改變，不過 ES6 Promise 就不一樣了，不管是 resolve 狀況還是 reject 狀況，<code>then</code> 回傳的預設就是一個新的 resolved 狀態的 Promise 物件。那要怎樣改變狀態呢？這裡就要用 <code>throw new Error()</code> 了。在 ES6 Promise 的 <code>then</code> 裡面，不管是 resolve 還是 reject 的 handler，都是回傳任意值會讓後面拿到新的 resolved 的 Promise 物件，而如果在執行中 throw error 出去，就會讓後面拿到 rejected 的 Promise 物件：</p>

<pre><code>dfd.then(function (val) {
  if (val === 0) {
    throw new Error('');
  }
});
</code></pre>

<p>然後就是 rejected 狀態的 Promise 也是有值的，如果是 throw error 產生的，那就是看 throw 什麼東西，那個東西就會變成新的 Promise 物件的值，而以往手動 throw error 時，為了相容性都會產生 Error 物件，在這邊就不必如此了，其實可以隨便傳想要給後面使用的值。</p>

<p>再來，有時候只想要處理 reject 的狀況，會寫成：</p>

<pre><code>dfd.then(null, function () {
  //rejected handler
});
</code></pre>

<p>有個 null 放前面其實蠻討厭的，不過 ES6 有提供一個 <code>catch</code> 可以用： </p>

<pre><code>dfd.catch(function () {
  //rejected handler
});
</code></pre>

<p>這個以前倒是沒有類似的東西，蠻方便的。大概瞭解到這樣就可以使用 ES6 Promise 了，另外還有 <code>Promise.all</code> 和 <code>Promise.race</code> 可以做和 <code>jQuery.when</code> 類似的事情（race 是新的控制），至於我為什麼說現在差不多可以開始使用呢，除了 Polyfill 齊全外，其實還有一個原因是一些新的網路標準也開始使用 ES6 Promise 了，像是 <a href="http://www.w3.org/TR/WebCryptoAPI/">Web Crypto</a>，看 spec 比較不明顯，不過看 MDN 的<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">介紹</a>，就有列出 encrypt、decrypt、sign 等花時間的 method 回傳都是 Promise 物件，實做就可以丟到背景的 Worker 去處理，才不會把 UI 卡住。而除了 Web Crypto 外，還有像是 ES7 可能會有的 <a href="http://jakearchibald.com/2014/es7-async-functions/">await</a> 語法也是要接 Promise 物件，總之是個未來趨勢，我覺得現在比較尷尬的是在 ES6 Promise 出來前的一堆標準都是用 event base 設計的，像是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader">File Reader</a> 之類的，不知道有沒有機會慢慢都改到 Promise。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/11/13/es6-promise/</link>
<guid>https://blog.othree.net/log/2014/11/13/es6-promise/</guid>
<category>script</category>
<pubDate>2014-11-13 23:54</pubDate>
</item>

<item>
<title>node-ffi</title>
<description><![CDATA[<p>今年的 JSDC 分享的是 node-ffi，不過我覺得沒講很好，反而練習講得比較好...</p>

<script async="async" class="speakerdeck-embed" data-id="fcbffc9033fa013238ec56e996df704e" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]>
</description>
<link>https://blog.othree.net/log/2014/10/13/node-ffi/</link>
<guid>https://blog.othree.net/log/2014/10/13/node-ffi/</guid>
<category>script</category>
<pubDate>2014-10-13 22:48</pubDate>
</item>

<item>
<title>Chrome 將不支援 Pointer Events</title>
<description><![CDATA[<p>話說 W3C 預計要推出 <a href="http://www.w3.org/TR/pointerevents/">Pointer Events</a> 統一 mouse event 和 touch event，不過 Chorme 的引擎 Blink 說<a href="https://code.google.com/p/chromium/issues/detail?id=162757#c64">不打算支援這新東西了</a>，主要原因是在複雜度和效能問題，雖然在信件裡面也把 Firefox、IE、Safari 拉下水，不過其他幾家好像都還沒做出決定，而且看來接下來關鍵在 Safari，因為它掌控了大量的 iOS 用戶，不過其實 Pointer Events 不只是打算處理 mouse, touch，在現在的 CR 裡面其實還有觸控筆，基本上是目前想的到能在畫面上做輸入(pointer)的裝置都考慮進去了，再來應該是看 Safari 決定了吧。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/08/16/chrome_pointer_event/</link>
<guid>https://blog.othree.net/log/2014/08/16/chrome_pointer_event/</guid>
<category>script</category>
<pubDate>2014-08-16 23:28</pubDate>
</item>

<item>
<title>ECMAScript 6 at COSCUP</title>
<description><![CDATA[<p>今天在 COSCUP 的投影片，因為前一場 delay 導致後面講的有點趕，小可惜，不過該說的都有說到了～</p>

<script async="async" class="speakerdeck-embed" data-id="947e99f0f08f0131d797323063e9e5f4" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]>
</description>
<link>https://blog.othree.net/log/2014/07/19/ecmascript-6-cosup/</link>
<guid>https://blog.othree.net/log/2014/07/19/ecmascript-6-cosup/</guid>
<category>script</category>
<pubDate>2014-07-19 22:50</pubDate>
</item>

<item>
<title>ES6 的數字</title>
<description><![CDATA[<p>這篇想要介紹的是 ES6 的整數規則上的一些變化，首先是 <code>parseInt</code>，看過 JavaScript Good Part 的話都會知道，這個函數的第二個參數 radix 一定要給，不然如果遇到 <code>0</code> 開頭的字串時，會自動被當成八進位的數字，這個被人詬病許久的設計終於在 ES6 中拿掉了，未來 <code>parseInt</code> 只會自動判斷 <code>0x</code> <code>0X</code> 為 16 進位，不然沒給 radix 就是當 10 進位。</p>

<p>另外一個改變是多了可以直接表示 2 進位和 8 進位整數的語法：</p>

<pre><code>bin1 = 0b11;
bin2 = 0B1000;

oct1 = 0o1199;
oct2 = 0O17;
</code></pre>

<p>2 進位要 <code>0b</code> 或是 <code>0B</code> 開頭，8 進位則是 <code>0o</code> 或是 <code>0O</code>，雖然和 16 進位一樣設計，不過要注意的是 <code>parseInt</code> 目前的 spec 設計是只會自動判斷 16 進位的喔。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/07/15/es6-int/</link>
<guid>https://blog.othree.net/log/2014/07/15/es6-int/</guid>
<category>script</category>
<pubDate>2014-07-15 15:52</pubDate>
</item>

<item>
<title>YAJS: Yet Another JavaScript Syntax for Vim</title>
<description><![CDATA[<p>前陣子把我 fork 的 Enhanced Javascript syntax 大改後，乾脆改名上到 Vim Scripts 了，名字就叫做 <a href="http://www.vim.org/scripts/script.php?script_id=4974">YAJS</a>，全名是 Yet Another JavaScript Syntax for Vim（又一個 JS Syntax），當然也有 <a href="https://github.com/othree/yajs.vim">github repo</a> 方便安裝，為什麼這次會自己大修呢，主要的原因是想要弄支援 ES6 的一些新語法，不過剛好有一些問題也已經很久了，就一口氣處理，大概整理一下和其他版的差異如下：</p>

<ul>
<li>用 <code>javascript</code> 做 group name 的 prefix，如此才符合 Vim doc 的規範，並且可以直接讓 <code>SyntaxComplete</code> 使用</li>
<li>完整重新整理過的 Web API、DOM、JS 關鍵字</li>
<li>可以完美的和 javascript-libraries-syntax.vim 共用</li>
<li>把許多歷史遺跡的 syntax rule 都砍掉了</li>
<li>當然最後就是支援許多的 ES6 syntax，像是 arrow function、 method definition 等</li>
</ul>

<p>第一點這問題很久了，我好像之前也有說過，第二個一開始弄之前有點猶豫，因為關鍵字真的很多，目前整理了大概有 1800 個上下，不過後來看到 Vim 內建的 xs 的 <a href="https://code.google.com/p/vim/source/browse/runtime/syntax/xs.vim">syntax</a> 我就釋懷了，這個檔案有三千多行，而定義關鍵字的每行都有數個關鍵字，1800 其實還只整理了一部份，除了 Global 物件都有加上外，很多新 Spec 是還沒整理的，例如 Mozilla 為了 Firefox OS 定的那些和硬體溝通的 API 等。</p>

<p>第三點是我重新整理的時候才注意到的，本來我的 javascript-libraries-syntax.vim 會把 <code>.</code> 的 group 取代掉，也就是原來的 syntax rule 裡面，和 <code>.</code> 有關的東西在套用過 libraries syntax 之後就會消失，只是不太容易注意到，這次修改就讓這個問題不會發生，不過 JS 僅限於 YAJS，，其他還有 CoffeeScript、LiveScript 其實不受影響，不過是因為他們本來在 <code>.</code> 之後就沒其他的 syntax highlight 了。</p>

<p>第四點就是把一些不明用途或是過時的東西砍掉，最後就是 ES6 的語法了，目前大概知道會有的都已經做上去了像是 block scope、let、const、class、新的 number literal 等都支援，如果有缺什麼歡迎報 bug 摟。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/07/14/yajs/</link>
<guid>https://blog.othree.net/log/2014/07/14/yajs/</guid>
<category>script</category>
<pubDate>2014-07-14 18:35</pubDate>
</item>

<item>
<title>ES6 Method Definition</title>
<description><![CDATA[<p>以前在產生 function 時，一定不外乎是 function declaration：</p>

<pre><code>function foo() { return; }
</code></pre>

<p>或是 function expression：</p>

<pre><code>var foo = function () { return; }
</code></pre>

<p>不過在 ES6 有一種新的特殊的語法可以使用，叫做 <strong>method definition</strong>，顧名思義，這個新的語法是專門用在產生物件的 method 上用的，所以嚴格說來不是用來做 function 的，然後也因此很特別的不需要使用到 function 這個關鍵字，基本的用法通常會在 class syntax 中使用：</p>

<pre><code>class foo {
  constructor() {
    //blah
  }

  fooMeth() {
    //blah
  }
}
</code></pre>

<p>在上面這段程式碼中，<code>constructor</code> 和 <code>fooMeth</code> 都是 method definition，其實就很接近以前的 prototype method，但是大幅簡化了語法，而除了這樣使用，還可以配合 <code>get</code>、<code>set</code> 讓它變成 accessor function：</p>

<pre><code>class foo {
  get bar() {
    return this._bar;      
  }
  set bar(v) {
    this._bar = v + this._bar;
  }
}
</code></pre>

<p>Accessor 其實在 ES5 就已經有了，不過因為一直被 IE 卡著所以不太有人用，而且寫起來實在也麻煩很多，以前是要用 <code>defineProperty</code> 才能定義 accessor：</p>

<pre><code>Object.defineProperty(foo.prototype, 'bar', {
  get: function () {
    return this._bar;
  },
  set: function (v) {
    this._bar = v + this._bar;
  }
});
</code></pre>

<p>當然除了比較麻煩外，還有一個問題就是 <code>defineProperty</code> 只能用在實體物件上，所以上面的 class 範例，要做出一樣效果就要在 prototype 上使用，實在不直觀，加上 <code>defineProperty</code> 其他功能真的是很少看到使用需求，新的語法這樣設計真的是很不錯，不過看到 <code>defineProperty</code> 要在實體物件上用，就會讓人反過來想，method definition 可以不用在 class 上，而是用在普通物件上嗎？事實上是可以的，ES6 的物件語法多了簡化的寫法，其中一個就是支援 method definition，所以可以這樣寫：</p>

<pre><code>var object = {
  value: 42,
  toString() {
    return this.value;
  }
};
</code></pre>
]]>
</description>
<link>https://blog.othree.net/log/2014/07/14/es6-method-definition/</link>
<guid>https://blog.othree.net/log/2014/07/14/es6-method-definition/</guid>
<category>script</category>
<pubDate>2014-07-14 16:47</pubDate>
</item>

<item>
<title>SIMD in JavaScript</title>
<description><![CDATA[<p><a class="thumbnail" href="http://www.flickr.com/photos/othree/14510706785/" title="SIMD in JavaScript by othree, on Flickr"><img src="//farm3.staticflickr.com/2922/14510706785_971714a962_b.jpg" width="800" height="389" alt="SIMD in JavaScript" srcset="//farm3.staticflickr.com/2922/14510706785_971714a962.jpg 768w, //farm3.staticflickr.com/2922/14510706785_971714a962_b.jpg 768w 2x" /></a></p>

<p>Intel 前陣子推出了 SIMD in JavaScript 的概念以及實做後的<a href="https://01.org/zh/node/1495">效能比較</a>，SIMD 指的是下一個指令就能故做多個運算，基本上是 CPU、GPU 的指令，例如上圖那樣，本來的四個加法需要四個指令，改用 SIMD 就可以用兩個向量相加的方式把四個加法做好，效能可以提升不少，常見四維的向量和矩陣其實都是為了 3D 運算，所以這個新的提生效能的方式大概也會是 3D 相關的應用為主吧，本來以為這只是單純 Intel 在做些試驗，不過最近準備 COSCUP 的演講時，發現其實SIMD 也有打算標準化進 ECMAScript 裡面，不過不會太快，目前<a href="http://www.2ality.com/2011/09/es6-8.html">推斷</a>是 ES8 才會看到。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/06/26/simd-in-javascript/</link>
<guid>https://blog.othree.net/log/2014/06/26/simd-in-javascript/</guid>
<category>script</category>
<pubDate>2014-06-26 14:56</pubDate>
</item>

<item>
<title>ES6 的 Generator 與 Iterator</title>
<description><![CDATA[<p>第一次看到 generator 時，我只有看到 <code>yield</code> 這個關鍵字，以為只是流程控制的機制，後來才聽到 generator（產生器）這個名字，一直以為說的是 factory pattern 那種角色，困惑了起來去查了一些介紹才知道也是很早就有的機制，主要都是用在迴圈上，命名雖然是用 generator（生產器）和 yield（產出），但是不是 factory 那種，generator 其實是用來產生 iterator 的。</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">Iterator</a> 其實是一組定義好的介面，讓物件可以在迴圈裡面取得整個串列的資料，而在 ES6 裡，可以處理 iterator 的迴圈形式，就是上一篇文章介紹 Map 和 Set 時，有講到的 <code>for of</code> 這個新語法，在 ES6 裡面定義的 Iterator 介面其實很簡單，只有定義了一個 <code>next</code> method，每次執行會回傳一個物件，裡面兩個屬性：</p>

<pre><code>{
    value: 100, // 下一個元素的值
    done: false // Iterator 是否跑完了
}
</code></pre>

<p><code>value</code> 就是迴圈要的值，<code>done</code> 則是用來判斷迴圈是否該結束了，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator</a> 就是用 <code>yield</code> 這個語法來讓你簡單的可以產生 iterator，在 ES6 裡面的語法還算簡單，就是宣告 function 時加個 <code>*</code>：</p>

<pre><code>function* idMaker(){
    var index = 0;
    while(true)
        yield index++;
}
</code></pre>

<p>上面就是一個簡單的 generator，執行 <code>idMaker</code> 這個 generator function 才會回傳對應的 iterator：</p>

<pre><code>var gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
</code></pre>

<p>當然這是一個不會結束的 iterator 就是了，使用時要小心不要直接把這種東西丟到迴圈裡面。最後要來介紹的是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable
">iterable</a> 介面，其實如果直接把 iterator 丟給 <code>for of</code> 是不能用的，要是有支援 iterable 介面的物件才可以，ES6 內建有 iterable 介面的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable#Builtin_iterables">物件型態</a>包括了：</p>

<ul>
<li>字串</li>
<li>陣列</li>
<li>Generator</li>
<li>Map, WeakMap</li>
<li>Set, WeakSet</li>
<li>arguments</li>
</ul>

<p>這些形式的資料都可以直接用 <code>for of</code> 迴圈來跑，然後當然，介面都已經定義出來了，表示我們也可以自己寫一個物件來用，iterable 的定義也很簡單，就是把該物件 iterator 的 generator 放在 "@@iterator" 這個屬性下，由於 iterator 只能用一次，所以每次需要都要用 generator 產生一個新的 iterator。另外文件有提到說 "@@iterator" 就是 <code>Symbol.iterator</code> 這個環境變數，不過我目前測試還不支援的樣子（Symbol 目前還在變動中，以後會在介紹）：</p>

<pre><code>var myIterable = {}
myIterable["@@iterator"] = () =&gt; (function*(){
    yield 1;
    yield 2;
    yield 3
})();

for (let value of myIterable) {
    console.log(value);
} // 1, 2, 3
</code></pre>

<p>通常會把 "@@iterator" 屬性放到 prototype 下比較保險。而有了自定義 iterable 物件的能力，就可以有很多東西可以玩啦，可以拿來跑二元樹、DOM tree、三維陣列或是特定應用領域的資料結構等等。</p>

<p>另外和 iterable 相關的東西還有一個，就是新的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread</a> 運算子 <code>...</code>，它可以把 iterable 物件展開，然後放到像是陣列或是參數、destructuring 等等：</p>

<pre><code>[...myIterable]; // [1, 2, 3]

myFunc(...myIterable); // myFunc(1, 2, 3)
</code></pre>

<p>這個新的運算子也是一個非常好用的新功能。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/05/24/es6-iterable/</link>
<guid>https://blog.othree.net/log/2014/05/24/es6-iterable/</guid>
<category>script</category>
<pubDate>2014-05-24 14:03</pubDate>
</item>

<item>
<title>ES6 的 Map 與 Set</title>
<description><![CDATA[<p>ECMAScript 6 多了兩個新的資料結構，分別是 Map 與 Set，剛開始看到時還因為太久沒接觸其他語言，整個想不起來是什麼東西，不過還是簡單介紹一下。</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a> 我一開始想不起來到底和 Map 哪裡不一樣，後來還是看了說明才回憶起來，其實就是一組值，像是資料庫裡面的 enum 資料型態，也可以想像成是陣列那樣的結構，可是它沒辦法直接用索引取特定元素的值，只能用列舉的方法取值，常用的 method 有三個，<code>add</code>、<code>delete</code> 和 <code>clear</code>，預設是會幫你確保值都是唯一的，重複的值會被忽略，要列舉裡面的值基本上是要用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a> 語法，這和以前的 <code>for...in</code> 語法不一樣，是直接取值出來的，也是 ES6 新的東西。</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 則是和原來的 JS 物件好像重複到，都是 key value mapping 的資料結構，不過其實還是有個很重要的差異點，就是 Map 的 key 的可以用字串以外的值，例如你可以用 DOM Node 來當 Map 裡面的 key，用法基本上就是 <code>set</code> 和 <code>get</code>，可以避免一些以前會遇到的問題，例如 jQuery 的 data，以前會需要幫每個 DOM Node 生 unique id，如果用 Map 來實做的話就不需要了。</p>

<p>目前 Firefox 和 Chrome 都已經有把這兩個資料結構實做好了，不過 Chrome 還沒有把 <code>for...of</code> 實做好就是～</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/05/19/es6-map-set/</link>
<guid>https://blog.othree.net/log/2014/05/19/es6-map-set/</guid>
<category>script</category>
<pubDate>2014-05-19 21:07</pubDate>
</item>

<item>
<title>process.nextTick, setImmediate, setTimeout, requestAnimationFrame</title>
<description><![CDATA[<p>標題這幾個 API 是感覺功能有些接近的東西，<code>process.nextTick</code> 是 node 的，<code>setImmediate</code> 是微軟提出但是只有 IE 和 node 有實作，<code>setTimeout</code> 是最老牌的，感覺後面給它 0ms 延遲，效果和其他幾個很像，<code>requestAnimationFrame</code> 則是更新畫面作動畫時用的新 API，那細部這幾個 API 有什麼差異呢？</p>

<p>要繼續之前可能要先了解一下 JavaScript Event Loop，和 Timer 還有瀏覽器更新 UI 的關係，可以參考 John Resig 的 <a href="http://ejohn.org/blog/how-javascript-timers-work/">How JavaScript Timers Work</a> 這篇文章，標題那四個 API 除了最後一個 requestAnimationFrame 一定是等到瀏覽器要更新 UI 了才會呼叫到，然後螢幕有個更新頻率，不管怎樣快都不會到千分之一秒叫一次，所以它基本上就是最慢的。</p>

<p>那前面三個有什麼差別呢？先來看看 <code>setImmediate</code> 和 <code>setTimeout</code>，根據微軟的<a href="http://ie.microsoft.com/testdrive/Performance/setImmediateSorting/Default.html">說法</a>，因為 setTimeout 有個最小的 4ms 延遲，所以他們設計了 setImmediate 這個完全無延遲的 API 介面出來，不過其實根據 whatwg 的 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout">spec</a>，其實要 nesting 的 setTimeout call 才要加上這個 4ms 最小延遲，也就是在 setTimeout 裡面又呼叫 setTimeout 這種狀況，而且要超過五層，會這樣設計是為了避免連續的 setTimout 會造成 UI 卡住，所以我猜是微軟的 setTimeout 實作不正確，而 <a href="https://code.google.com/p/chromium/issues/detail?id=146172">Webkit</a> 和 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=686201">Firefox</a> 也因此都沒實作它，總之要是正確的作 setTimout，不要連續呼叫超過五層，那他和 setImmediate 應該會是一樣快的，順代一題，微軟那個比較的網頁上就沒有設成 0ms 的 case 可以看在其他瀏覽器上的表現。</p>

<p>最後一個是 <code>process.nextTick</code> 了，這是 node 才有的 API，它和後面三個的作法不太一樣，速度也是所有 API 裡面最快的，實際上它不是把 function 丟到 timer 的 queue 裡面等，而是跟系統說，現在這個 all stack 結束後，立即去執行這些 function，也就是它其實是獨立的 queue，所有丟到 nextTick 裡面的 function 都執行完後，才輪的到 setImmediate 或是其他 UI、系統 IO 的份，而這個 queue 是先進先出，所以其實還蠻好用的，難怪在 node 裡面感覺大家用得很兇，不過要注意。</p>

<p>回頭看一下 setImmediate，其實網路上也是有不少 <a href="https://github.com/NobleJS/setImmediate">polyfill</a> 提供，這些實作都是用 postMessage 來避開 setTimeout 會產生的 4ms 最小延遲，無法使用 postMessage 時會 fallback 到 setTimout。其實會看這些東西是因為 browserify 的關係，因為 <a href="http://browserify.org/">browserify</a> 有說會提供 node 的東西到瀏覽器上，像是 <code>process.nextTick</code>，好奇了一下 <code>setImmediate</code> 有沒有也提供，結果看起來目前是沒有，不過深入研究之後也發現其實不是真的有這個需要就是了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2014/03/02/immediate-in-js/</link>
<guid>https://blog.othree.net/log/2014/03/02/immediate-in-js/</guid>
<category>script</category>
<pubDate>2014-03-02 13:50</pubDate>
</item>

<item>
<title>asm.js 效能再提昇</title>
<description><![CDATA[<p><a class="thumbnail" href="http://www.flickr.com/photos/othree/11517198133/" title="asm1.5b by othree, on Flickr"><img src="//farm6.staticflickr.com/5520/11517198133_293174bb1e_b.jpg" width="1024" height="509" alt="asm1.5b" src-1="(max-width: 768px)  //farm6.staticflickr.com/5520/11517198133_293174bb1e.jpg 1x, //farm6.staticflickr.com/5520/11517198133_293174bb1e_b.jpg 2x"  /></a></p>

<p>Mozilla 之前發表 asm.js 後，公佈的速度大約是原生應用是的兩倍慢，不過最近這個數字又變好了，根據 20 日 Mozilla Hacks 發表的<a href="https://hacks.mozilla.org/2013/12/gap-between-asm-js-and-native-performance-gets-even-narrower-with-float32-optimizations/">文章</a>，現在這個數字已經變成 1.5 倍了，主要是歸功於  float32 數值處理最佳化，不過目前還不建議直接使用這個新的 float32 最佳化機制，Mozilla Blog 有一篇<a href="https://blog.mozilla.org/javascript/2013/11/07/efficient-float32-arithmetic-in-javascript/">文章</a>則是在講比較技術面的內容，大概看一下，應該是犧牲精確度來換取速度。本來我是覺的要真的和 native 一樣快不太可能，不過看到新的 benchmark 結果，覺的這天或許不會太久就會到來吧。</p>
]]>
</description>
<link>https://blog.othree.net/log/2013/12/24/asmjs-1half-x-slower-than-native/</link>
<guid>https://blog.othree.net/log/2013/12/24/asmjs-1half-x-slower-than-native/</guid>
<category>script</category>
<pubDate>2013-12-24 00:59</pubDate>
</item>

<item>
<title>JavaScript Promise</title>
<description><![CDATA[<p>最近 JavaScript 圈很熱的一則<a href="http://www.html5rocks.com/en/tutorials/es6/promises/">消息</a>就是要有原生的 Promise 了，不過這個時間點再來介紹 Promise 物件好像有點重複且不必要了，所以想來講一下標準這部份的發展。</p>

<p>在繼續下去前要先作些名詞統一，因為實際上 spec 用的名詞和 jQuery 用的不太一樣，首先是 promise、deferred 甚至是 future 在這邊其實都是同義詞，而 fulfill 則是 jQuery 的 resolve 那樣的動作，reject 就沒有不一樣詞彙，最後是 thenable，代表的是可以丟進 Promise 裡一起 chaining 的物件，只要有定義 then function 就可以算了。</p>

<p>之前的文章也有提過，JavaScript 領域的 Promise 基本上是 jQuery Deferred 實作後才開始受到廣為注目，而 jQuery 實作的說是基於 CommonJS <a href="http://wiki.commonjs.org/wiki/Promises">Promise/A</a> 這個標準，不過其實去看 Promise/A 會發現他內容根本就很少，不知道怎麼和 jQuery Deferred 扯上邊的，最近才了解，Promise/A 其實只有最基本的 Promise 的功能定義，而它的定義就只有說有個值未來會拿到，然後你要給他 <code>then</code> 這個 method。</p>

<p>而其它像是怎樣 fulfill，有沒有 <code>when</code> 那種功能之類的，都沒有定義，完全就是個自由發揮，所以 jQuery 的實作才會看起來和 Promise/A 比起來差距這麼多，不過更糟的是，第一版的 jQuery Deferred 卻還把 then 實作錯了，在 spec 中描述 then 的部份的第二段文字：</p>

<blockquote>
  <p>This function should return a new promise that is fulfilled when the given fulfilledHandler or errorHandler callback is finished. This allows promise operations to be chained together. The value returned from the callback handler is the fulfillment value for the returned promise. If the callback throws an error, the returned promise will be moved to failed state. </p>
</blockquote>

<p>這邊其實是在說 then 要回傳一個新的 promise 物件，然後你的 Promise 才會有 chaining 的特性，在 jQuery 一開始的版本，這個特性其實是要利用 <code>pipe</code> 來達成而不是 <code>then</code> 的，我想這也是後來為什麼 jQuery Deferred 把 then 的行為改成 pipe 的行為的原因，不過即使如此， jQuery 的 API 還是和 Promise/A 有些差距就是了，說來尷尬，Promise/A 只規範了 then，結果把 Promise 發揚光大的 jQuery 實作卻把 then 做錯了。</p>

<p>由於 Promise/A 只有描述行為，而不是詳細的實作，於是就有了 <a href="http://promises-aplus.github.io/promises-spec/">Promise/A+</a>，這個 spec 不是 CommonJS 的 spec，而是由一群人自主發起的，把 Promise/A 裡面所缺的詳細規範補齊，像是 Promise fulfill 時要怎樣處理之類的，定義得很詳細，這份標準完全沒宣告著作權，用的是 CC0，像 <a href="https://github.com/tildeio/rsvp.js">rsvp.js</a> 和 <a href="https://github.com/kriskowal/q">Q</a> 用的就是 Promise/A+ 標準來實作，不過 Promise/A+ 還是只有定義 then 的部份，怎樣 fulfill，怎樣 reject 部分的 API 還是沒碰，所以不同的實作都還是會有些差異。其實 Promise/A+ 組織的 github 帳號上可以看到有關於這部份的<a href="https://github.com/promises-aplus/resolvers-spec">討論</a>，雖然是沒寫出任何草案，我想應該就是直接進了 TC39 的 <a href="https://github.com/domenic/promises-unwrapping">Promise spec</a> 了吧，畢竟好像編輯有重複的<a href="https://twitter.com/domenic">人</a>。</p>

<p>TC39 的 Promise 就和 Promise/A+ 的差不多一樣，fulfill 和 reject 的 API 設計就是用他們討論時的其中一個選項，結果是和 rsvp.js 的時作比較接近，fulfill 和 reject function 是在 promise 物件的建構時給的 callback 裡面才會拿到，和 jQuery Deferred 物件可以從外面來 resolve/reject 的設計不一樣：</p>

<pre><code>new Promise(function (fulfill, reject, progress) {
    // blah....
});
</code></pre>

<p>我對於 JavaScript 原生要支援 Promise 這件事是非常樂觀看待啦，畢竟常常只想要它又不想要 jQuery 或是另外引入其他 Library，以後原生支援就省事很多了。</p>
]]>
</description>
<link>https://blog.othree.net/log/2013/12/21/javascript-promise/</link>
<guid>https://blog.othree.net/log/2013/12/21/javascript-promise/</guid>
<category>script</category>
<pubDate>2013-12-21 00:13</pubDate>
</item>


</channel>
</rss>