<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>c</b:listType>
			<b:listData listID="script">script</b:listData>
		</b:entriesMeta>

		<b:entry entryID="000824" baseName="typescript-definition">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-12-04</b:date>
				<b:time>23:06:48</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>關於 TypeScript</b:title>
			<b:content>
				<b:summary> 這幾年各種 compile to JavaScript language 盛行，大部分都是朝向讓程式碼更好寫的方向來前進，微軟在 2012 年也推出了 TypeScript 這個 compile to JavaScript language，不過他的方向卻不一樣，TypeScript 是一個 JavaScript 的 superset，意思就是所有的 JavaScript 都是合法的 TypeScript，而 TypeScript 多了一些語法，加入了一些新功能，不過這些新的語法完全都不用也是可以正常的寫程式，給 TypeScript compiler 編譯。 TypeScript 顧名思義，它著重的在資料型別這個部分，JavaScript 是 weak type （弱型別）的語言，寫起來算是很方便，不過這個特性卻也是一些問題的來源，首先最常見到的是因為資料型態不嚴謹而造成的 bug，第二個常被提出來的就是為了實做 weak type 而造成的 performance 下降，因此一直有一些聲音在對抗弱型別這個特性，第一個是 Douglas...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15756461070/" title="type-error by othree, on Flickr"><img src="https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca_b.jpg" width="1024" height="261" alt="type-error" srcset="https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca.jpg 768w, https://farm8.staticflickr.com/7510/15756461070_d3b58d0aca_b.jpg 768w 2x" /></a></p>

<p>這幾年各種 compile to JavaScript language 盛行，大部分都是朝向讓程式碼更好寫的方向來前進，微軟在 2012 年也推出了 <a href="http://www.typescriptlang.org/">TypeScript</a> 這個 compile to JavaScript language，不過他的方向卻不一樣，TypeScript 是一個 JavaScript 的 superset，意思就是所有的 JavaScript 都是合法的 TypeScript，而 TypeScript 多了一些語法，加入了一些新功能，不過這些新的語法完全都不用也是可以正常的寫程式，給 TypeScript compiler 編譯。</p>

<p>TypeScript 顧名思義，它著重的在資料型別這個部分，JavaScript 是 weak type （弱型別）的語言，寫起來算是很方便，不過這個特性卻也是一些問題的來源，首先最常見到的是因為資料型態不嚴謹而造成的 bug，第二個常被提出來的就是為了實做 weak type 而造成的 performance 下降，因此一直有一些聲音在對抗弱型別這個特性，第一個是 Douglas Crockford 先出聲的，不過一開始是從程式碼的嚴謹和可靠性來說的，因為他當時主力在 <a href="http://www.jslint.com/">JSLint</a> 上，所以對於可靠的程式碼的要求比較高，JSLint 一度還把這項檢查放入，後來接著 Google V8 引擎也對沒有改變型別的變數作了最佳化，然後有 TypeScript，接著未來的 ES7 也可能會加入型別宣告的語法進來，這部分似乎是 Douglas 參與推動的，然後 Google 也打算推出 <a href="https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/mobilebasic?pli=1&amp;viewopt=127">AtScript</a> 的樣子，AtScript 是 TypeScript 的 superset，更進一步增加了型別相關的特性進來。</p>

<p>TypeScript 是一個介於中間的語言，當然為了支援  JavaScript 不能直接把整個環境都改成強型別的，所以 TypeScript 的作法是讓形別的宣告變為可省略的，如果沒有宣告型別，則一切和以前一樣，如果你的變數有宣告型別，那個變數才會是強型別，在編譯的時候，如果把不同型別的值給它，就會跑出警告訊息，像是 JSLint 一樣。TypeScript 的型別宣告語法中，一些比較簡單的可以和程式碼一起寫：</p>

<pre><code>var str:string;
</code></pre>

<p>可是稍微複雜一點，和物件有關係的話，就要獨立寫一段宣告的程式碼了：</p>

<pre><code>interface HotkeysProvider {
    template: string;
    includeCheatSheet: boolean;
    get(combo: string): ng.hotkeys.Hotkey;
    toggleCheatSheet(): void;
}
</code></pre>

<p>這段宣告其實是完全獨立於程式碼的邏輯本身，全部砍掉程式也可以運作，本身不牽涉到任何邏輯，所以可以完全獨立出去，在 TypeScript 中稱為 type definition（型別定義） ，常用的副檔名是 <code>.d.ts</code>，感覺上很像是 C 語言的 header file，其實我對於 TypeScript 本身的發展是不太樂觀的，覺得他的佔有率永遠不會起來，但是它的型別定義這塊我到覺得是大有可為，主因是目前沒有比較在業界有使用的到型別定義的語言，寫標準所用的 <a href="http://www.w3.org/TR/WebIDL/#idl">WebIDL</a> 普極度實在很低，相關的工具開發和支援實在很少，反而 .d.ts 檔知道的人比較多，編譯器也都有了，而且多虧 TypeScript 有開放原碼，事實上也有其它專案有借助 TypeScript 定義檔，像是我在用的 <a href="http://ternjs.net/">TernJS</a> 這個 JavaScript 自動補完工具，就有提供一個 <a href="https://github.com/marijnh/tern/blob/master/bin/from_ts">from_ts 工具</a> 可以把 .d.ts 檔轉成它可以讀的定義檔案，加上有 <a href="http://definitelytyped.org/">DefinitelyType</a> 專案，各種不同 JavaScript Library 的定義檔都已經有了，所以 TernJS 就可以利用這些資源，提供各種 Library 的自動補完支援了，不過前提是使用者要知道有這些東西，官方文件其實沒有把這塊講得這麼連貫。</p>

<p>除了 TernJS 的應用外，我相信這些定義檔還可以讓編輯器或是 IDE 可以提供更多的輔助功能，像是或許可以拿來產生編輯器用的 syntax 定義檔，在編寫程式時直接提出警告等等，其實現在想的到的這些功能微軟的 Visuall Studio 應該都有了，不過有個公定格式做中介還是比較方便第三方應用，雖然目前好像只有看到 TernJS 的第三方應用，有些可惜，而且微軟的 Compiler 常常偷改，TernJS 提供的 <code>from_ts</code> 是需要使用到一些 compiler 內部的 function 才能用的，而從我接觸 TernJS 以來，微軟至少已經改過兩次改很大造成 <code>from_ts</code>完全不能用的情形。</p>

<p>總之微軟的 TypeScript 我覺得使用人數也不會有什麼大變化，但是定義檔 <code>.d.ts</code> 的部分倒是比較可以期待，變成半個 JS 用的標準介面定義文件格式，競爭對手的話應該是 WebIDL 吧，不過 WebIDL 比較不親切，也不太有人去實做和推廣他的應用，ES7 的型別暗示其實是只是針對那五個基本型別為主，沒有像 WebIDL 和 TypeScript 那樣完整。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000821" baseName="fetch">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-11-25</b:date>
				<b:time>20:48:20</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>前端工程師都應該知道的 fetch</b:title>
			<b:content>
				<b:summary>之前介紹 ES6 Promise 的時候就有提到一些過去的標準應該也可以更新到來支援 Promise，沒想到就看到 WHATWG 的 fetch 了，fetch 就是個 XMLHttpRequest（XHR）的 替代品，幾乎是集了這幾年前端領域 Pattern 之大成。 首先是命名很簡單，和 XHR 完全不一樣，那個時期的網路標準的命名都很繁雜，尤其像是 XML Schema 的那個時期，聽說是找了些語言學家來一起制訂的，那個時期的東西很多都名稱弄的很冗長，當然不可否認這樣有個好處是比較容易理解東西的源由，像 XHR 看名字就可以知道其實主要目的是為了抓 XML，而那個時期會想要抓 XML 大概就是為了 SOAP 協定的 Web Service 吧，只是真的用來抓 XML 的已經很少了，一直用這個名稱早就已經覺得很奇怪了，至於新的 fetch 顧名思義就是為了抓東西用的，反而和現在 XHR 使用的情境很符合，而且命名很簡單，好記，就像是 jQuery 的 on 取代了...</b:summary>
				<b:mainContent><p>之前介紹 ES6 Promise 的時候就有提到一些過去的標準應該也可以更新到來支援 Promise，沒想到就看到 WHATWG 的 <a href="https://fetch.spec.whatwg.org/">fetch</a> 了，fetch 就是個 <a href="https://developer.mozilla.org/zh-TW/docs/DOM/XMLHttpRequest">XMLHttpRequest</a>（XHR）的 替代品，幾乎是集了這幾年前端領域 Pattern 之大成。</p>

<p>首先是命名很簡單，和 XHR 完全不一樣，那個時期的網路標準的命名都很繁雜，尤其像是 XML Schema 的那個時期，聽說是找了些語言學家來一起制訂的，那個時期的東西很多都名稱弄的很冗長，當然不可否認這樣有個好處是比較容易理解東西的源由，像 XHR 看名字就可以知道其實主要目的是為了抓 XML，而那個時期會想要抓 XML 大概就是為了 SOAP 協定的 Web Service 吧，只是真的用來抓 XML 的已經很少了，一直用這個名稱早就已經覺得很奇怪了，至於新的 fetch 顧名思義就是為了抓東西用的，反而和現在 XHR 使用的情境很符合，而且命名很簡單，好記，就像是 jQuery 的 <code>on</code> 取代了 <code>addEventListener</code> 一樣。（PS: 另外有一個叫 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/Beacon/Overview.html">sendBeacon</a> 的是只管送出，不管回來的東西的。）</p>

<p>第二個特點是使用了 <a href="https://blog.othree.net/log/2013/06/19/options-object/">Options Object</a>，不過 XHR 倒也不是收很多參數，他的設計是先產生物件後才對它操作：</p>

<pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', 'test.html');
xhr.setRequestHeader('Tester-Name', 'mike');
xhr.setRequestHeader('Tester-Name ', 'peter');
xhr.send();
</code></pre>

<p>雖然沒有搞不清楚參數順序的問題，卻也是多了很多步驟才能達成目標，不過其實產生了 XHR 物件但是卻不送出 request 的使用情境我實在想不太到，大概是因此，新的 fetch 才改成像是 jQuery 的 <code>$.ajax</code> 那樣，產生物件時直接就發出 request 了吧。</p>

<p>第三個特點當然就是回傳的是 ES6 Promise 物件，另外也支援 FormData 等等新東西，不過要說能不能完全取代 XHR 呢？目前看起來是不行的，最主要是因為 ES6 Promise 並沒有支援 progress 的機制，而且已經不是 event-based 的物件了，所以沒辦法抓上傳進度之類的資訊。</p>

<p>因為這個 spec 還很新，目前是沒瀏覽器支援，不過 Github 有提供一個 <a href="https://github.com/github/fetch">polyfill</a> 了，把基本的功能都做好了（還有缺一些比較少用到的細節），有興趣想開始用的人可以從這邊開始，大概要注意的有兩個，第一個是因為它是用 ES6 Promise，所以還要引入 ES6 Promise polyfill，第二個是回傳資料的處理，雖然 fetch 在發 request 的時候和 jQuery 的設計很像，不過回傳的資料處理方式就差距比較大了。</p>

<p>jQuery 的 ajax 收到 Response Body 時，會自動根據 Header 的 Content-Type 來處理，像是 JSON 會自動用 <code>JSON.parse</code> 把文字轉成 JS 物件，不過 fetch 不會，根據 spec 所說， fetch 算是一個底層的 library，所以這種事情就要自己來了：</p>

<pre><code>fetch("https://pk.example/berlin-calling.json", {mode:"cors"})
  .then(res =&gt; {
  if(res.headers.get("content-type") == "application/json") {
    return res.json()
  } else {
    throw new TypeError()
  }
}).then(processJSON)
</code></pre>

<p>fetch 需要你自己在程式碼裡面判斷回傳資料的格式是什麼，然後可以用它提供的 method 擷取到相對應格式的資料，像是這個例子中抓的是 JSON 格式的資料，就直接執行 Response 物件的 <code>json</code> 這個 method，當然你也可以不判斷就直接執行 <code>json()</code>，只是無法 parse 時會直接 throw error 出來，又因為在 Promise 串接過程中，後面就會跑到 reject 的 callback function 那邊去，除了 <code>json</code> 外，其他支援的還有 <code>arrayBuffer</code>、<code>blob</code>、<code>formData</code> 和 <code>text</code>。這些從 response 物件中讀取 body 資料出來的動作（spec 中稱為 consume）只能操作一次，如果真的很想讀很多次，建議是直接把回傳資料的那個 Promise 儲存起來，還有一個方法是用 clone 複製 Response 物件，不確定那個方法好就是了，這部分這樣設計的原因似乎是為了處理少一點事情，讓效能比較好。</p>

<p>而除了 Response Body 外，其它的回傳資訊像是 Response Header 等，都有新定義的物件來儲存，不過沒有很複雜，設計的很直覺，和送出去的 Options Object 很接近。不過講到 Header 就有一點還是要說一下，其實 HTTP Header 是可以重複送出一樣的 key 的，先不管合不合規範，現實是 HTTP Protocol 的實作都還可以處理這種狀況，以前的 XHR 也可以做出這樣的行為，印象中也有 framework 會這樣用，不過不太確定，總之 fetch 因為 Header 是給 Options Object 中的一個物件，而物件的 key 不能重複，所以不會允許這種行為出現，我個人是覺得這樣其實也比較好啦。</p>

<p>目前這個標準還未廣為人知，但是我是覺得前景非常看好，Spec 寫的也異常詳細，雖然不能把 XHR 的所有功能都取代，不過大部分的 XHR 應用都可以用的上了，也有 Github 提供的 polyfill，應該很容易吸引人進去使用，加上也沒其它的類似候選標準，除了沒有 progress 和回來的資料格式要自己判斷外，應該是沒什麼缺點了，而且判斷資料格式的部分也是可以自己寫點程式碼把他處理掉，所以嚴格一點說的話，問題就剩下沒有 progress 可以看這點了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000819" baseName="es6-promise">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-11-13</b:date>
				<b:time>23:54:08</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ES6 Promise</b:title>
			<b:content>
				<b:summary>ES6 Promise 目前各家瀏覽器的支援程度雖然還沒到可以直接用的程度，但是目前已經有非常多的 polyfill，差不多是可以開始使用的時候了。 如果習慣了 jQuery 設計的 Deferred 物件，應該會對於 ES6 的 Promise 設計很不習慣吧，相較於 jQuery 是產生好物件然後提供一些 method 做操作，要不要封裝起來也是開發者的事，ES6 Promise 的設計更是強調了封裝的特性，要怎麼 resolve、reject，在一開始就要決定好了，只有在建構函數裡面碰的到 resolve 和 reject 的觸發點： new Promise(function (resolve, reject) { //... }); 這樣的設計雖然在物件封裝上比較嚴謹，但是其實會讓一些程式碼多了一層的縮排，例如本來用 jQuery Deferred 包起來的 XHR： function JQXHR(url) { var...</b:summary>
				<b:mainContent><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ES6 Promise</a> 目前各家瀏覽器的支援程度雖然還沒到可以直接用的程度，但是目前已經有非常多的 polyfill，差不多是可以開始使用的時候了。</p>

<p>如果習慣了 jQuery 設計的 Deferred 物件，應該會對於 ES6 的 Promise 設計很不習慣吧，相較於 jQuery 是產生好物件然後提供一些 method 做操作，要不要封裝起來也是開發者的事，ES6 Promise 的設計更是強調了封裝的特性，要怎麼 resolve、reject，在一開始就要決定好了，只有在建構函數裡面碰的到 resolve 和 reject 的觸發點：</p>

<pre><code>new Promise(function (resolve, reject) {
  //...
});
</code></pre>

<p>這樣的設計雖然在物件封裝上比較嚴謹，但是其實會讓一些程式碼多了一層的縮排，例如本來用 jQuery Deferred 包起來的 XHR：</p>

<pre><code>function JQXHR(url) {
  var xhr = new XMLHttpRequest();
  var dfd = new $.Deferred();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) { dfd.resolve(xhr.response); }
  }
  xhr.open('GET', url);
  xhr.send();
  return dfd.promise();
}
</code></pre>

<p>用 ES6 Promise 就要改寫成：</p>

<pre><code>function ESXHR(url) {
  var xhr = new XMLHttpRequest();
  var dfd = new Promise(function (resolve) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) { resolve(xhr.response); }
    }
  });
  xhr.open('GET', url);
  xhr.send();
  return dfd;
}
</code></pre>

<p>第二個差異就在於回傳的 thenable 物件要怎麼把結果改掉，以前 jQuery 的時候可以在 callback 裡面回傳新的 Deferred 物件改結果：</p>

<pre><code>dfd.then(null, function () {
  return $.Deferred().resolve();
});
</code></pre>

<p>沒特別傳 Deferred 物件的話不管用 <code>then</code> 串接幾次的話結果都不會改變，不過 ES6 Promise 就不一樣了，不管是 resolve 狀況還是 reject 狀況，<code>then</code> 回傳的預設就是一個新的 resolved 狀態的 Promise 物件。那要怎樣改變狀態呢？這裡就要用 <code>throw new Error()</code> 了。在 ES6 Promise 的 <code>then</code> 裡面，不管是 resolve 還是 reject 的 handler，都是回傳任意值會讓後面拿到新的 resolved 的 Promise 物件，而如果在執行中 throw error 出去，就會讓後面拿到 rejected 的 Promise 物件：</p>

<pre><code>dfd.then(function (val) {
  if (val === 0) {
    throw new Error('');
  }
});
</code></pre>

<p>然後就是 rejected 狀態的 Promise 也是有值的，如果是 throw error 產生的，那就是看 throw 什麼東西，那個東西就會變成新的 Promise 物件的值，而以往手動 throw error 時，為了相容性都會產生 Error 物件，在這邊就不必如此了，其實可以隨便傳想要給後面使用的值。</p>

<p>再來，有時候只想要處理 reject 的狀況，會寫成：</p>

<pre><code>dfd.then(null, function () {
  //rejected handler
});
</code></pre>

<p>有個 null 放前面其實蠻討厭的，不過 ES6 有提供一個 <code>catch</code> 可以用： </p>

<pre><code>dfd.catch(function () {
  //rejected handler
});
</code></pre>

<p>這個以前倒是沒有類似的東西，蠻方便的。大概瞭解到這樣就可以使用 ES6 Promise 了，另外還有 <code>Promise.all</code> 和 <code>Promise.race</code> 可以做和 <code>jQuery.when</code> 類似的事情（race 是新的控制），至於我為什麼說現在差不多可以開始使用呢，除了 Polyfill 齊全外，其實還有一個原因是一些新的網路標準也開始使用 ES6 Promise 了，像是 <a href="http://www.w3.org/TR/WebCryptoAPI/">Web Crypto</a>，看 spec 比較不明顯，不過看 MDN 的<a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">介紹</a>，就有列出 encrypt、decrypt、sign 等花時間的 method 回傳都是 Promise 物件，實做就可以丟到背景的 Worker 去處理，才不會把 UI 卡住。而除了 Web Crypto 外，還有像是 ES7 可能會有的 <a href="http://jakearchibald.com/2014/es7-async-functions/">await</a> 語法也是要接 Promise 物件，總之是個未來趨勢，我覺得現在比較尷尬的是在 ES6 Promise 出來前的一堆標準都是用 event base 設計的，像是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader">File Reader</a> 之類的，不知道有沒有機會慢慢都改到 Promise。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000813" baseName="node-ffi">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-10-13</b:date>
				<b:time>22:48:39</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>node-ffi</b:title>
			<b:content>
				<b:summary>今年的 JSDC 分享的是 node-ffi，不過我覺得沒講很好，反而練習講得比較好... /* A_A */...</b:summary>
				<b:mainContent><p>今年的 JSDC 分享的是 node-ffi，不過我覺得沒講很好，反而練習講得比較好...</p>

<script async="async" class="speakerdeck-embed" data-id="fcbffc9033fa013238ec56e996df704e" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000808" baseName="chrome_pointer_event">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-08-16</b:date>
				<b:time>23:28:51</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Chrome 將不支援 Pointer Events</b:title>
			<b:content>
				<b:summary>話說 W3C 預計要推出 Pointer Events 統一 mouse event 和 touch event，不過 Chorme 的引擎 Blink 說不打算支援這新東西了，主要原因是在複雜度和效能問題，雖然在信件裡面也把 Firefox、IE、Safari 拉下水，不過其他幾家好像都還沒做出決定，而且看來接下來關鍵在 Safari，因為它掌控了大量的 iOS 用戶，不過其實 Pointer Events 不只是打算處理 mouse, touch，在現在的 CR 裡面其實還有觸控筆，基本上是目前想的到能在畫面上做輸入(pointer)的裝置都考慮進去了，再來應該是看 Safari 決定了吧。...</b:summary>
				<b:mainContent><p>話說 W3C 預計要推出 <a href="http://www.w3.org/TR/pointerevents/">Pointer Events</a> 統一 mouse event 和 touch event，不過 Chorme 的引擎 Blink 說<a href="https://code.google.com/p/chromium/issues/detail?id=162757#c64">不打算支援這新東西了</a>，主要原因是在複雜度和效能問題，雖然在信件裡面也把 Firefox、IE、Safari 拉下水，不過其他幾家好像都還沒做出決定，而且看來接下來關鍵在 Safari，因為它掌控了大量的 iOS 用戶，不過其實 Pointer Events 不只是打算處理 mouse, touch，在現在的 CR 裡面其實還有觸控筆，基本上是目前想的到能在畫面上做輸入(pointer)的裝置都考慮進去了，再來應該是看 Safari 決定了吧。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000806" baseName="ecmascript-6-cosup">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-07-19</b:date>
				<b:time>22:50:58</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ECMAScript 6 at COSCUP</b:title>
			<b:content>
				<b:summary>今天在 COSCUP 的投影片，因為前一場 delay 導致後面講的有點趕，小可惜，不過該說的都有說到了～ /* A_A */...</b:summary>
				<b:mainContent><p>今天在 COSCUP 的投影片，因為前一場 delay 導致後面講的有點趕，小可惜，不過該說的都有說到了～</p>

<script async="async" class="speakerdeck-embed" data-id="947e99f0f08f0131d797323063e9e5f4" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000804" baseName="es6-int">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-07-15</b:date>
				<b:time>15:52:15</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ES6 的數字</b:title>
			<b:content>
				<b:summary>這篇想要介紹的是 ES6 的整數規則上的一些變化，首先是 parseInt，看過 JavaScript Good Part 的話都會知道，這個函數的第二個參數 radix 一定要給，不然如果遇到 0 開頭的字串時，會自動被當成八進位的數字，這個被人詬病許久的設計終於在 ES6 中拿掉了，未來 parseInt 只會自動判斷 0x 0X 為 16 進位，不然沒給 radix 就是當 10 進位。 另外一個改變是多了可以直接表示 2 進位和 8 進位整數的語法： bin1 = 0b11; bin2 = 0B1000; oct1 = 0o1199; oct2...</b:summary>
				<b:mainContent><p>這篇想要介紹的是 ES6 的整數規則上的一些變化，首先是 <code>parseInt</code>，看過 JavaScript Good Part 的話都會知道，這個函數的第二個參數 radix 一定要給，不然如果遇到 <code>0</code> 開頭的字串時，會自動被當成八進位的數字，這個被人詬病許久的設計終於在 ES6 中拿掉了，未來 <code>parseInt</code> 只會自動判斷 <code>0x</code> <code>0X</code> 為 16 進位，不然沒給 radix 就是當 10 進位。</p>

<p>另外一個改變是多了可以直接表示 2 進位和 8 進位整數的語法：</p>

<pre><code>bin1 = 0b11;
bin2 = 0B1000;

oct1 = 0o1199;
oct2 = 0O17;
</code></pre>

<p>2 進位要 <code>0b</code> 或是 <code>0B</code> 開頭，8 進位則是 <code>0o</code> 或是 <code>0O</code>，雖然和 16 進位一樣設計，不過要注意的是 <code>parseInt</code> 目前的 spec 設計是只會自動判斷 16 進位的喔。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000803" baseName="yajs">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-07-14</b:date>
				<b:time>18:35:34</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>YAJS: Yet Another JavaScript Syntax for Vim</b:title>
			<b:content>
				<b:summary>前陣子把我 fork 的 Enhanced Javascript syntax 大改後，乾脆改名上到 Vim Scripts 了，名字就叫做 YAJS，全名是 Yet Another JavaScript Syntax for Vim（又一個 JS Syntax），當然也有 github repo 方便安裝，為什麼這次會自己大修呢，主要的原因是想要弄支援 ES6 的一些新語法，不過剛好有一些問題也已經很久了，就一口氣處理，大概整理一下和其他版的差異如下： 用 javascript 做 group name 的 prefix，如此才符合 Vim doc 的規範，並且可以直接讓 SyntaxComplete 使用 完整重新整理過的 Web API、DOM、JS 關鍵字...</b:summary>
				<b:mainContent><p>前陣子把我 fork 的 Enhanced Javascript syntax 大改後，乾脆改名上到 Vim Scripts 了，名字就叫做 <a href="http://www.vim.org/scripts/script.php?script_id=4974">YAJS</a>，全名是 Yet Another JavaScript Syntax for Vim（又一個 JS Syntax），當然也有 <a href="https://github.com/othree/yajs.vim">github repo</a> 方便安裝，為什麼這次會自己大修呢，主要的原因是想要弄支援 ES6 的一些新語法，不過剛好有一些問題也已經很久了，就一口氣處理，大概整理一下和其他版的差異如下：</p>

<ul>
<li>用 <code>javascript</code> 做 group name 的 prefix，如此才符合 Vim doc 的規範，並且可以直接讓 <code>SyntaxComplete</code> 使用</li>
<li>完整重新整理過的 Web API、DOM、JS 關鍵字</li>
<li>可以完美的和 javascript-libraries-syntax.vim 共用</li>
<li>把許多歷史遺跡的 syntax rule 都砍掉了</li>
<li>當然最後就是支援許多的 ES6 syntax，像是 arrow function、 method definition 等</li>
</ul>

<p>第一點這問題很久了，我好像之前也有說過，第二個一開始弄之前有點猶豫，因為關鍵字真的很多，目前整理了大概有 1800 個上下，不過後來看到 Vim 內建的 xs 的 <a href="https://code.google.com/p/vim/source/browse/runtime/syntax/xs.vim">syntax</a> 我就釋懷了，這個檔案有三千多行，而定義關鍵字的每行都有數個關鍵字，1800 其實還只整理了一部份，除了 Global 物件都有加上外，很多新 Spec 是還沒整理的，例如 Mozilla 為了 Firefox OS 定的那些和硬體溝通的 API 等。</p>

<p>第三點是我重新整理的時候才注意到的，本來我的 javascript-libraries-syntax.vim 會把 <code>.</code> 的 group 取代掉，也就是原來的 syntax rule 裡面，和 <code>.</code> 有關的東西在套用過 libraries syntax 之後就會消失，只是不太容易注意到，這次修改就讓這個問題不會發生，不過 JS 僅限於 YAJS，，其他還有 CoffeeScript、LiveScript 其實不受影響，不過是因為他們本來在 <code>.</code> 之後就沒其他的 syntax highlight 了。</p>

<p>第四點就是把一些不明用途或是過時的東西砍掉，最後就是 ES6 的語法了，目前大概知道會有的都已經做上去了像是 block scope、let、const、class、新的 number literal 等都支援，如果有缺什麼歡迎報 bug 摟。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000802" baseName="es6-method-definition">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-07-14</b:date>
				<b:time>16:47:15</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ES6 Method Definition</b:title>
			<b:content>
				<b:summary>以前在產生 function 時，一定不外乎是 function declaration： function foo() { return; } 或是 function expression： var foo = function () { return; } 不過在 ES6 有一種新的特殊的語法可以使用，叫做 method definition，顧名思義，這個新的語法是專門用在產生物件的 method 上用的，所以嚴格說來不是用來做 function 的，然後也因此很特別的不需要使用到 function 這個關鍵字，基本的用法通常會在 class syntax 中使用： class foo { constructor() {...</b:summary>
				<b:mainContent><p>以前在產生 function 時，一定不外乎是 function declaration：</p>

<pre><code>function foo() { return; }
</code></pre>

<p>或是 function expression：</p>

<pre><code>var foo = function () { return; }
</code></pre>

<p>不過在 ES6 有一種新的特殊的語法可以使用，叫做 <strong>method definition</strong>，顧名思義，這個新的語法是專門用在產生物件的 method 上用的，所以嚴格說來不是用來做 function 的，然後也因此很特別的不需要使用到 function 這個關鍵字，基本的用法通常會在 class syntax 中使用：</p>

<pre><code>class foo {
  constructor() {
    //blah
  }

  fooMeth() {
    //blah
  }
}
</code></pre>

<p>在上面這段程式碼中，<code>constructor</code> 和 <code>fooMeth</code> 都是 method definition，其實就很接近以前的 prototype method，但是大幅簡化了語法，而除了這樣使用，還可以配合 <code>get</code>、<code>set</code> 讓它變成 accessor function：</p>

<pre><code>class foo {
  get bar() {
    return this._bar;      
  }
  set bar(v) {
    this._bar = v + this._bar;
  }
}
</code></pre>

<p>Accessor 其實在 ES5 就已經有了，不過因為一直被 IE 卡著所以不太有人用，而且寫起來實在也麻煩很多，以前是要用 <code>defineProperty</code> 才能定義 accessor：</p>

<pre><code>Object.defineProperty(foo.prototype, 'bar', {
  get: function () {
    return this._bar;
  },
  set: function (v) {
    this._bar = v + this._bar;
  }
});
</code></pre>

<p>當然除了比較麻煩外，還有一個問題就是 <code>defineProperty</code> 只能用在實體物件上，所以上面的 class 範例，要做出一樣效果就要在 prototype 上使用，實在不直觀，加上 <code>defineProperty</code> 其他功能真的是很少看到使用需求，新的語法這樣設計真的是很不錯，不過看到 <code>defineProperty</code> 要在實體物件上用，就會讓人反過來想，method definition 可以不用在 class 上，而是用在普通物件上嗎？事實上是可以的，ES6 的物件語法多了簡化的寫法，其中一個就是支援 method definition，所以可以這樣寫：</p>

<pre><code>var object = {
  value: 42,
  toString() {
    return this.value;
  }
};
</code></pre>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000801" baseName="simd-in-javascript">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-06-26</b:date>
				<b:time>14:56:13</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>SIMD in JavaScript</b:title>
			<b:content>
				<b:summary> Intel 前陣子推出了 SIMD in JavaScript 的概念以及實做後的效能比較，SIMD 指的是下一個指令就能故做多個運算，基本上是 CPU、GPU 的指令，例如上圖那樣，本來的四個加法需要四個指令，改用 SIMD 就可以用兩個向量相加的方式把四個加法做好，效能可以提升不少，常見四維的向量和矩陣其實都是為了 3D 運算，所以這個新的提生效能的方式大概也會是 3D 相關的應用為主吧，本來以為這只是單純 Intel 在做些試驗，不過最近準備 COSCUP 的演講時，發現其實SIMD 也有打算標準化進 ECMAScript 裡面，不過不會太快，目前推斷是 ES8 才會看到。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/14510706785/" title="SIMD in JavaScript by othree, on Flickr"><img src="//farm3.staticflickr.com/2922/14510706785_971714a962_b.jpg" width="800" height="389" alt="SIMD in JavaScript" srcset="//farm3.staticflickr.com/2922/14510706785_971714a962.jpg 768w, //farm3.staticflickr.com/2922/14510706785_971714a962_b.jpg 768w 2x" /></a></p>

<p>Intel 前陣子推出了 SIMD in JavaScript 的概念以及實做後的<a href="https://01.org/zh/node/1495">效能比較</a>，SIMD 指的是下一個指令就能故做多個運算，基本上是 CPU、GPU 的指令，例如上圖那樣，本來的四個加法需要四個指令，改用 SIMD 就可以用兩個向量相加的方式把四個加法做好，效能可以提升不少，常見四維的向量和矩陣其實都是為了 3D 運算，所以這個新的提生效能的方式大概也會是 3D 相關的應用為主吧，本來以為這只是單純 Intel 在做些試驗，不過最近準備 COSCUP 的演講時，發現其實SIMD 也有打算標準化進 ECMAScript 裡面，不過不會太快，目前<a href="http://www.2ality.com/2011/09/es6-8.html">推斷</a>是 ES8 才會看到。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
