<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>c</b:listType>
			<b:listData listID="script">script</b:listData>
		</b:entriesMeta>

		<b:entry entryID="000797" baseName="es6-iterable">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-05-24</b:date>
				<b:time>14:03:12</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ES6 的 Generator 與 Iterator</b:title>
			<b:content>
				<b:summary>第一次看到 generator 時，我只有看到 yield 這個關鍵字，以為只是流程控制的機制，後來才聽到 generator（產生器）這個名字，一直以為說的是 factory pattern 那種角色，困惑了起來去查了一些介紹才知道也是很早就有的機制，主要都是用在迴圈上，命名雖然是用 generator（生產器）和 yield（產出），但是不是 factory 那種，generator 其實是用來產生 iterator 的。 Iterator 其實是一組定義好的介面，讓物件可以在迴圈裡面取得整個串列的資料，而在 ES6 裡，可以處理 iterator 的迴圈形式，就是上一篇文章介紹 Map 和 Set 時，有講到的 for of 這個新語法，在 ES6 裡面定義的 Iterator 介面其實很簡單，只有定義了一個 next method，每次執行會回傳一個物件，裡面兩個屬性： { value: 100, // 下一個元素的值...</b:summary>
				<b:mainContent><p>第一次看到 generator 時，我只有看到 <code>yield</code> 這個關鍵字，以為只是流程控制的機制，後來才聽到 generator（產生器）這個名字，一直以為說的是 factory pattern 那種角色，困惑了起來去查了一些介紹才知道也是很早就有的機制，主要都是用在迴圈上，命名雖然是用 generator（生產器）和 yield（產出），但是不是 factory 那種，generator 其實是用來產生 iterator 的。</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">Iterator</a> 其實是一組定義好的介面，讓物件可以在迴圈裡面取得整個串列的資料，而在 ES6 裡，可以處理 iterator 的迴圈形式，就是上一篇文章介紹 Map 和 Set 時，有講到的 <code>for of</code> 這個新語法，在 ES6 裡面定義的 Iterator 介面其實很簡單，只有定義了一個 <code>next</code> method，每次執行會回傳一個物件，裡面兩個屬性：</p>

<pre><code>{
    value: 100, // 下一個元素的值
    done: false // Iterator 是否跑完了
}
</code></pre>

<p><code>value</code> 就是迴圈要的值，<code>done</code> 則是用來判斷迴圈是否該結束了，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator</a> 就是用 <code>yield</code> 這個語法來讓你簡單的可以產生 iterator，在 ES6 裡面的語法還算簡單，就是宣告 function 時加個 <code>*</code>：</p>

<pre><code>function* idMaker(){
    var index = 0;
    while(true)
        yield index++;
}
</code></pre>

<p>上面就是一個簡單的 generator，執行 <code>idMaker</code> 這個 generator function 才會回傳對應的 iterator：</p>

<pre><code>var gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
</code></pre>

<p>當然這是一個不會結束的 iterator 就是了，使用時要小心不要直接把這種東西丟到迴圈裡面。最後要來介紹的是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable
">iterable</a> 介面，其實如果直接把 iterator 丟給 <code>for of</code> 是不能用的，要是有支援 iterable 介面的物件才可以，ES6 內建有 iterable 介面的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable#Builtin_iterables">物件型態</a>包括了：</p>

<ul>
<li>字串</li>
<li>陣列</li>
<li>Generator</li>
<li>Map, WeakMap</li>
<li>Set, WeakSet</li>
<li>arguments</li>
</ul>

<p>這些形式的資料都可以直接用 <code>for of</code> 迴圈來跑，然後當然，介面都已經定義出來了，表示我們也可以自己寫一個物件來用，iterable 的定義也很簡單，就是把該物件 iterator 的 generator 放在 "@@iterator" 這個屬性下，由於 iterator 只能用一次，所以每次需要都要用 generator 產生一個新的 iterator。另外文件有提到說 "@@iterator" 就是 <code>Symbol.iterator</code> 這個環境變數，不過我目前測試還不支援的樣子（Symbol 目前還在變動中，以後會在介紹）：</p>

<pre><code>var myIterable = {}
myIterable["@@iterator"] = () =&gt; (function*(){
    yield 1;
    yield 2;
    yield 3
})();

for (let value of myIterable) {
    console.log(value);
} // 1, 2, 3
</code></pre>

<p>通常會把 "@@iterator" 屬性放到 prototype 下比較保險。而有了自定義 iterable 物件的能力，就可以有很多東西可以玩啦，可以拿來跑二元樹、DOM tree、三維陣列或是特定應用領域的資料結構等等。</p>

<p>另外和 iterable 相關的東西還有一個，就是新的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread</a> 運算子 <code>...</code>，它可以把 iterable 物件展開，然後放到像是陣列或是參數、destructuring 等等：</p>

<pre><code>[...myIterable]; // [1, 2, 3]

myFunc(...myIterable); // myFunc(1, 2, 3)
</code></pre>

<p>這個新的運算子也是一個非常好用的新功能。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000796" baseName="es6-map-set">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-05-19</b:date>
				<b:time>21:07:07</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ES6 的 Map 與 Set</b:title>
			<b:content>
				<b:summary>ECMAScript 6 多了兩個新的資料結構，分別是 Map 與 Set，剛開始看到時還因為太久沒接觸其他語言，整個想不起來是什麼東西，不過還是簡單介紹一下。 Set 我一開始想不起來到底和 Map 哪裡不一樣，後來還是看了說明才回憶起來，其實就是一組值，像是資料庫裡面的 enum 資料型態，也可以想像成是陣列那樣的結構，可是它沒辦法直接用索引取特定元素的值，只能用列舉的方法取值，常用的 method 有三個，add、delete 和 clear，預設是會幫你確保值都是唯一的，重複的值會被忽略，要列舉裡面的值基本上是要用 for...of 語法，這和以前的 for...in 語法不一樣，是直接取值出來的，也是 ES6 新的東西。 Map 則是和原來的 JS 物件好像重複到，都是 key value mapping 的資料結構，不過其實還是有個很重要的差異點，就是 Map 的 key 的可以用字串以外的值，例如你可以用 DOM Node 來當 Map 裡面的 key，用法基本上就是...</b:summary>
				<b:mainContent><p>ECMAScript 6 多了兩個新的資料結構，分別是 Map 與 Set，剛開始看到時還因為太久沒接觸其他語言，整個想不起來是什麼東西，不過還是簡單介紹一下。</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a> 我一開始想不起來到底和 Map 哪裡不一樣，後來還是看了說明才回憶起來，其實就是一組值，像是資料庫裡面的 enum 資料型態，也可以想像成是陣列那樣的結構，可是它沒辦法直接用索引取特定元素的值，只能用列舉的方法取值，常用的 method 有三個，<code>add</code>、<code>delete</code> 和 <code>clear</code>，預設是會幫你確保值都是唯一的，重複的值會被忽略，要列舉裡面的值基本上是要用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a> 語法，這和以前的 <code>for...in</code> 語法不一樣，是直接取值出來的，也是 ES6 新的東西。</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 則是和原來的 JS 物件好像重複到，都是 key value mapping 的資料結構，不過其實還是有個很重要的差異點，就是 Map 的 key 的可以用字串以外的值，例如你可以用 DOM Node 來當 Map 裡面的 key，用法基本上就是 <code>set</code> 和 <code>get</code>，可以避免一些以前會遇到的問題，例如 jQuery 的 data，以前會需要幫每個 DOM Node 生 unique id，如果用 Map 來實做的話就不需要了。</p>

<p>目前 Firefox 和 Chrome 都已經有把這兩個資料結構實做好了，不過 Chrome 還沒有把 <code>for...of</code> 實做好就是～</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000791" baseName="immediate-in-js">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2014-03-02</b:date>
				<b:time>13:50:53</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>process.nextTick, setImmediate, setTimeout, requestAnimationFrame</b:title>
			<b:content>
				<b:summary>標題這幾個 API 是感覺功能有些接近的東西，process.nextTick 是 node 的，setImmediate 是微軟提出但是只有 IE 和 node 有實作，setTimeout 是最老牌的，感覺後面給它 0ms 延遲，效果和其他幾個很像，requestAnimationFrame 則是更新畫面作動畫時用的新 API，那細部這幾個 API 有什麼差異呢？ 要繼續之前可能要先了解一下 JavaScript Event Loop，和 Timer 還有瀏覽器更新 UI 的關係，可以參考 John Resig 的 How JavaScript Timers Work 這篇文章，標題那四個 API 除了最後一個 requestAnimationFrame 一定是等到瀏覽器要更新 UI 了才會呼叫到，然後螢幕有個更新頻率，不管怎樣快都不會到千分之一秒叫一次，所以它基本上就是最慢的。...</b:summary>
				<b:mainContent><p>標題這幾個 API 是感覺功能有些接近的東西，<code>process.nextTick</code> 是 node 的，<code>setImmediate</code> 是微軟提出但是只有 IE 和 node 有實作，<code>setTimeout</code> 是最老牌的，感覺後面給它 0ms 延遲，效果和其他幾個很像，<code>requestAnimationFrame</code> 則是更新畫面作動畫時用的新 API，那細部這幾個 API 有什麼差異呢？</p>

<p>要繼續之前可能要先了解一下 JavaScript Event Loop，和 Timer 還有瀏覽器更新 UI 的關係，可以參考 John Resig 的 <a href="http://ejohn.org/blog/how-javascript-timers-work/">How JavaScript Timers Work</a> 這篇文章，標題那四個 API 除了最後一個 requestAnimationFrame 一定是等到瀏覽器要更新 UI 了才會呼叫到，然後螢幕有個更新頻率，不管怎樣快都不會到千分之一秒叫一次，所以它基本上就是最慢的。</p>

<p>那前面三個有什麼差別呢？先來看看 <code>setImmediate</code> 和 <code>setTimeout</code>，根據微軟的<a href="http://ie.microsoft.com/testdrive/Performance/setImmediateSorting/Default.html">說法</a>，因為 setTimeout 有個最小的 4ms 延遲，所以他們設計了 setImmediate 這個完全無延遲的 API 介面出來，不過其實根據 whatwg 的 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout">spec</a>，其實要 nesting 的 setTimeout call 才要加上這個 4ms 最小延遲，也就是在 setTimeout 裡面又呼叫 setTimeout 這種狀況，而且要超過五層，會這樣設計是為了避免連續的 setTimout 會造成 UI 卡住，所以我猜是微軟的 setTimeout 實作不正確，而 <a href="https://code.google.com/p/chromium/issues/detail?id=146172">Webkit</a> 和 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=686201">Firefox</a> 也因此都沒實作它，總之要是正確的作 setTimout，不要連續呼叫超過五層，那他和 setImmediate 應該會是一樣快的，順代一題，微軟那個比較的網頁上就沒有設成 0ms 的 case 可以看在其他瀏覽器上的表現。</p>

<p>最後一個是 <code>process.nextTick</code> 了，這是 node 才有的 API，它和後面三個的作法不太一樣，速度也是所有 API 裡面最快的，實際上它不是把 function 丟到 timer 的 queue 裡面等，而是跟系統說，現在這個 all stack 結束後，立即去執行這些 function，也就是它其實是獨立的 queue，所有丟到 nextTick 裡面的 function 都執行完後，才輪的到 setImmediate 或是其他 UI、系統 IO 的份，而這個 queue 是先進先出，所以其實還蠻好用的，難怪在 node 裡面感覺大家用得很兇，不過要注意。</p>

<p>回頭看一下 setImmediate，其實網路上也是有不少 <a href="https://github.com/NobleJS/setImmediate">polyfill</a> 提供，這些實作都是用 postMessage 來避開 setTimeout 會產生的 4ms 最小延遲，無法使用 postMessage 時會 fallback 到 setTimout。其實會看這些東西是因為 browserify 的關係，因為 <a href="http://browserify.org/">browserify</a> 有說會提供 node 的東西到瀏覽器上，像是 <code>process.nextTick</code>，好奇了一下 <code>setImmediate</code> 有沒有也提供，結果看起來目前是沒有，不過深入研究之後也發現其實不是真的有這個需要就是了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000782" baseName="asmjs-1half-x-slower-than-native">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-12-24</b:date>
				<b:time>00:59:41</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>asm.js 效能再提昇</b:title>
			<b:content>
				<b:summary> Mozilla 之前發表 asm.js 後，公佈的速度大約是原生應用是的兩倍慢，不過最近這個數字又變好了，根據 20 日 Mozilla Hacks 發表的文章，現在這個數字已經變成 1.5 倍了，主要是歸功於 float32 數值處理最佳化，不過目前還不建議直接使用這個新的 float32 最佳化機制，Mozilla Blog 有一篇文章則是在講比較技術面的內容，大概看一下，應該是犧牲精確度來換取速度。本來我是覺的要真的和 native 一樣快不太可能，不過看到新的 benchmark 結果，覺的這天或許不會太久就會到來吧。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/11517198133/" title="asm1.5b by othree, on Flickr"><img src="//farm6.staticflickr.com/5520/11517198133_293174bb1e_b.jpg" width="1024" height="509" alt="asm1.5b" src-1="(max-width: 768px)  //farm6.staticflickr.com/5520/11517198133_293174bb1e.jpg 1x, //farm6.staticflickr.com/5520/11517198133_293174bb1e_b.jpg 2x"  /></a></p>

<p>Mozilla 之前發表 asm.js 後，公佈的速度大約是原生應用是的兩倍慢，不過最近這個數字又變好了，根據 20 日 Mozilla Hacks 發表的<a href="https://hacks.mozilla.org/2013/12/gap-between-asm-js-and-native-performance-gets-even-narrower-with-float32-optimizations/">文章</a>，現在這個數字已經變成 1.5 倍了，主要是歸功於  float32 數值處理最佳化，不過目前還不建議直接使用這個新的 float32 最佳化機制，Mozilla Blog 有一篇<a href="https://blog.mozilla.org/javascript/2013/11/07/efficient-float32-arithmetic-in-javascript/">文章</a>則是在講比較技術面的內容，大概看一下，應該是犧牲精確度來換取速度。本來我是覺的要真的和 native 一樣快不太可能，不過看到新的 benchmark 結果，覺的這天或許不會太久就會到來吧。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000780" baseName="javascript-promise">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-12-21</b:date>
				<b:time>00:13:01</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>JavaScript Promise</b:title>
			<b:content>
				<b:summary>最近 JavaScript 圈很熱的一則消息就是要有原生的 Promise 了，不過這個時間點再來介紹 Promise 物件好像有點重複且不必要了，所以想來講一下標準這部份的發展。 在繼續下去前要先作些名詞統一，因為實際上 spec 用的名詞和 jQuery 用的不太一樣，首先是 promise、deferred 甚至是 future 在這邊其實都是同義詞，而 fulfill 則是 jQuery 的 resolve 那樣的動作，reject 就沒有不一樣詞彙，最後是 thenable，代表的是可以丟進 Promise 裡一起 chaining 的物件，只要有定義 then function 就可以算了。 之前的文章也有提過，JavaScript 領域的 Promise 基本上是 jQuery Deferred 實作後才開始受到廣為注目，而 jQuery 實作的說是基於...</b:summary>
				<b:mainContent><p>最近 JavaScript 圈很熱的一則<a href="http://www.html5rocks.com/en/tutorials/es6/promises/">消息</a>就是要有原生的 Promise 了，不過這個時間點再來介紹 Promise 物件好像有點重複且不必要了，所以想來講一下標準這部份的發展。</p>

<p>在繼續下去前要先作些名詞統一，因為實際上 spec 用的名詞和 jQuery 用的不太一樣，首先是 promise、deferred 甚至是 future 在這邊其實都是同義詞，而 fulfill 則是 jQuery 的 resolve 那樣的動作，reject 就沒有不一樣詞彙，最後是 thenable，代表的是可以丟進 Promise 裡一起 chaining 的物件，只要有定義 then function 就可以算了。</p>

<p>之前的文章也有提過，JavaScript 領域的 Promise 基本上是 jQuery Deferred 實作後才開始受到廣為注目，而 jQuery 實作的說是基於 CommonJS <a href="http://wiki.commonjs.org/wiki/Promises">Promise/A</a> 這個標準，不過其實去看 Promise/A 會發現他內容根本就很少，不知道怎麼和 jQuery Deferred 扯上邊的，最近才了解，Promise/A 其實只有最基本的 Promise 的功能定義，而它的定義就只有說有個值未來會拿到，然後你要給他 <code>then</code> 這個 method。</p>

<p>而其它像是怎樣 fulfill，有沒有 <code>when</code> 那種功能之類的，都沒有定義，完全就是個自由發揮，所以 jQuery 的實作才會看起來和 Promise/A 比起來差距這麼多，不過更糟的是，第一版的 jQuery Deferred 卻還把 then 實作錯了，在 spec 中描述 then 的部份的第二段文字：</p>

<blockquote>
  <p>This function should return a new promise that is fulfilled when the given fulfilledHandler or errorHandler callback is finished. This allows promise operations to be chained together. The value returned from the callback handler is the fulfillment value for the returned promise. If the callback throws an error, the returned promise will be moved to failed state. </p>
</blockquote>

<p>這邊其實是在說 then 要回傳一個新的 promise 物件，然後你的 Promise 才會有 chaining 的特性，在 jQuery 一開始的版本，這個特性其實是要利用 <code>pipe</code> 來達成而不是 <code>then</code> 的，我想這也是後來為什麼 jQuery Deferred 把 then 的行為改成 pipe 的行為的原因，不過即使如此， jQuery 的 API 還是和 Promise/A 有些差距就是了，說來尷尬，Promise/A 只規範了 then，結果把 Promise 發揚光大的 jQuery 實作卻把 then 做錯了。</p>

<p>由於 Promise/A 只有描述行為，而不是詳細的實作，於是就有了 <a href="http://promises-aplus.github.io/promises-spec/">Promise/A+</a>，這個 spec 不是 CommonJS 的 spec，而是由一群人自主發起的，把 Promise/A 裡面所缺的詳細規範補齊，像是 Promise fulfill 時要怎樣處理之類的，定義得很詳細，這份標準完全沒宣告著作權，用的是 CC0，像 <a href="https://github.com/tildeio/rsvp.js">rsvp.js</a> 和 <a href="https://github.com/kriskowal/q">Q</a> 用的就是 Promise/A+ 標準來實作，不過 Promise/A+ 還是只有定義 then 的部份，怎樣 fulfill，怎樣 reject 部分的 API 還是沒碰，所以不同的實作都還是會有些差異。其實 Promise/A+ 組織的 github 帳號上可以看到有關於這部份的<a href="https://github.com/promises-aplus/resolvers-spec">討論</a>，雖然是沒寫出任何草案，我想應該就是直接進了 TC39 的 <a href="https://github.com/domenic/promises-unwrapping">Promise spec</a> 了吧，畢竟好像編輯有重複的<a href="https://twitter.com/domenic">人</a>。</p>

<p>TC39 的 Promise 就和 Promise/A+ 的差不多一樣，fulfill 和 reject 的 API 設計就是用他們討論時的其中一個選項，結果是和 rsvp.js 的時作比較接近，fulfill 和 reject function 是在 promise 物件的建構時給的 callback 裡面才會拿到，和 jQuery Deferred 物件可以從外面來 resolve/reject 的設計不一樣：</p>

<pre><code>new Promise(function (fulfill, reject, progress) {
    // blah....
});
</code></pre>

<p>我對於 JavaScript 原生要支援 Promise 這件事是非常樂觀看待啦，畢竟常常只想要它又不想要 jQuery 或是另外引入其他 Library，以後原生支援就省事很多了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000778" baseName="mutation-observer">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-12-08</b:date>
				<b:time>21:28:13</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Mutation Observer</b:title>
			<b:content>
				<b:summary>DOM Level 4 裡面提出了一個新的 DOM Mutation 的對應機制，叫做 Mutation Observer，顧名思義，它是 observer pattern 的一種，和以前的 Mutation Event 比起來有不少優點，現在大家也都建議使用 Mutation Obeserver 而不要用 Mutation Events 了。主要的差異是： Observer 是非同步的，效能比較好 DOM change 整理成 mutation record 給你 可以察看所有的 DOM 變動，也可以只注意想要的變動 這邊要先解釋第一點，可能會有人覺得 Mutation Event 也是非同步的，不過實際上，在 event callback 的 function...</b:summary>
				<b:mainContent><p><a href="https://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#mutation-observers">DOM Level 4</a> 裡面提出了一個新的 DOM Mutation 的對應機制，叫做 Mutation Observer，顧名思義，它是 observer pattern 的一種，和以前的 <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-mutationevents">Mutation Event</a> 比起來有不少優點，現在大家也都建議使用 Mutation Obeserver 而不要用 Mutation Events 了。主要的差異是：</p>

<ol>
<li>Observer 是非同步的，效能比較好</li>
<li>DOM change 整理成 mutation record 給你</li>
<li>可以察看所有的 DOM 變動，也可以只注意想要的變動</li>
</ol>

<p>這邊要先解釋第一點，可能會有人覺得 Mutation Event 也是非同步的，不過實際上，在 event callback 的 function call 內，整個算是一個同步的執行 process，也就是說一個 mutation event 發生後，一定會執行對應的 event callback，而且開始執行後中間不會插入其他的東西，這樣的行為有個缺點就是，如果我要在一個 function process 中一口氣砍掉 100 個節點，然後又有綁 mutation event 來作對應的處理，不過如果這個對應的處理動作可以等到最後在執行就好的話，用 Mutation Event 就會被迫多執行 99 次。但是 Mutation Observer 則是非同步的機制，就是不會你的 DOM 有一點變動就會引發它去執行 callback，而是等你的 function process 結束，timer 空出來時才會去檢查，然後一口氣把所有變動整理好丟到 callback 裡面。</p>

<p>目前<a href="http://caniuse.com/#feat=mutationobserver">支援</a>的程度也還不錯，Mutation Observer 用起來也不難，只是它就真的是一個獨立的觀察者物件，剛開始看到可能會不太習慣，可以參考 Dev.Opera 的 <a href="http://dev.opera.com/articles/view/mutation-observers-tutorial/">Getting to know mutation observers</a> 這篇文章，講的蠻詳細，包括怎樣偵測瀏覽器有沒有支援，如果是沒有支援的瀏覽器，一是可以 fallback 到 Mutation Event 做事，另一個則是可以用 Polymer 的 Mutation Observer <a href="https://github.com/Polymer/MutationObservers">polyfill</a>，底層也是用 Mutation Event 來達成的就是。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000775" baseName="angularjs-data-binding">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-12-05</b:date>
				<b:time>10:26:51</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>AngularJS Data Binding 機制</b:title>
			<b:content>
				<b:summary>一開始沒特別注意，前陣子看 PolymerJS 的時候才發現 AngularJS 的 data binding 是只要改 POJSO(Plain Old JavaScript Object) 的值，然後魔法就發生了，如果有寫 JS 應該都了解，目前其實沒辦法偵測某個物件的屬性是否被更改，所以 AngularJS 到底怎麼辦到的就引起我的興趣了，以下內容如有錯誤還請告知，畢竟我還沒有 AngularJS 開發經驗，可能有誤解。 結果又是在 StackOverflow 找到重要的參考資料，說到 $digest 和 $apply 這兩個 method，$apply 最主要是給外部的程式來用（還有 AngularJS 內部），如果是外部的程式改動你 scope 內的值，那還要順便執行 $apply() ，然後 $apply 會去執行 angular expression，然後接著執行 $digest 檢查資料變化並讓對應的變化發生。所以...</b:summary>
				<b:mainContent><p>一開始沒特別注意，前陣子看 PolymerJS 的時候才發現 AngularJS 的 data binding 是只要改 POJSO(Plain Old JavaScript Object) 的值，然後魔法就發生了，如果有寫 JS 應該都了解，目前其實沒辦法偵測某個物件的屬性是否被更改，所以 AngularJS 到底怎麼辦到的就引起我的興趣了，以下內容如有錯誤還請告知，畢竟我還沒有 AngularJS 開發經驗，可能有誤解。</p>

<p>結果又是在 StackOverflow 找到重要的<a href="http://stackoverflow.com/questions/9682092/databinding-in-angularjs">參考資料</a>，說到 <code>$digest</code> 和 <code>$apply</code> 這兩個 method，<code>$apply</code> 最主要是給外部的程式來用（還有 AngularJS 內部），如果是外部的程式改動你 scope 內的值，那還要順便執行 <code>$apply()</code> ，然後 <code>$apply</code> 會去執行 <a href="http://docs.angularjs.org/guide/expression">angular expression</a>，然後接著執行 <code>$digest</code> 檢查資料變化並讓對應的變化發生。所以 AngularJS 的 data binding 作法實際上是，AngularJS Framework 內的 controller function 有經手過的 scope，它會自己接在 function 的後面執行 <code>$apply()</code> 來套用變動，算是一種 dirty check，不過是檢查的很乾淨。</p>

<p>另外還剛好看到今年 <a href="2013.jsconf.eu/">JSConf EU</a> 有一場 <a href="http://2013.jsconf.eu/speakers/marius-gundersen-a-comparison-of-the-twoway-binding-in-angularjs-emberjs-and-knockoutjs.html">A comparison of the two-way binding in AngularJS, EmberJS and KnockoutJS</a> 的演講，不長，二十分而已內容也很不錯，推薦花點時間看看：</p>

<iframe width="420" height="315" src="//www.youtube.com/embed/mVjpwia1YN4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>講者 Marius Gundersen 比較了 AngularJS、EmberJS 和 KnockoutJS 三套 framework 的 data binding 機制，結果是各有優缺點，在最後的問與答也說到現在制定中的 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe">Object.observer</a> 的 JavaScript 未來新功能，等到這功能正式可以用時，就可以解決現在這些實作大部分的問題。</p>

<p>還有一篇文章 <a href="http://blog.bguiz.com/post/57373805814/accessors-vs-dirty-checking-in-javascript-frameworks">Accessors vs Dirty-checking in Javascript Frameworks</a> 有蠻深入的比較現在不同 data binding 實作的特性，就如標題是 Dirty-checking 和 Accessor 兩類實作為主，Accessor 的實作其實就是像 Backbone 那樣，要修改 model 的屬性要用他的 <code>set()</code> 方法來作，才能順便觸發後面的動作。</p>

<p>最後文章寫完才看到 AngularJS 社群第四次聚會 Ticore 已經講過這個主題了，<a href="http://www.slideshare.net/ticore/angularjs-data-binding">投影片</a>內容也還蠻深入的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000770" baseName="web_component">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-11-27</b:date>
				<b:time>19:35:38</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Web Component</b:title>
			<b:content>
				<b:summary>最近覺得可以開始玩 Web Component 了，然後就開始研究，本來以為應該會是個簡單的東西，結果意外的有一些細節還蠻複雜，有些設計目前也不知道為什麼，不過還是從基本的來開始整理吧。 Web Component 其實最早只有 Shaodw DOM 的概念，不過現在已經變成好幾個標準合在一起來構成 component 了，這些標準中，最主要的三個分別是： Shadow DOM Custom Element HTML Imports 這三者分別都是構成 Web Component 很重要的元素，不過也分別規範了一些不是單純只能應用在 Web Component 上的功能，這篇文章不一定會說到這些特色，一切都看緣份吧～...</b:summary>
				<b:mainContent><p>最近覺得可以開始玩 Web Component 了，然後就開始研究，本來以為應該會是個簡單的東西，結果意外的有一些細節還蠻複雜，有些設計目前也不知道為什麼，不過還是從基本的來開始整理吧。</p>

<p>Web Component 其實最早只有 Shaodw DOM 的概念，不過現在已經變成好幾個標準合在一起來構成 component 了，這些標準中，最主要的三個分別是：</p>

<ul>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a></li>
<li><a href="http://www.w3.org/TR/custom-elements/">Custom Element</a></li>
<li><a href="http://www.w3.org/TR/html-imports/">HTML Imports</a></li>
</ul>

<p>這三者分別都是構成 Web Component 很重要的元素，不過也分別規範了一些不是單純只能應用在 Web Component 上的功能，這篇文章不一定會說到這些特色，一切都看緣份吧～</p>
</b:mainContent>
				<b:extendContent><h4>Shadow DOM</h4>

<p>我所知當中這是最早被提出的部分，這份文件的目的在提出一套標準來在文件樹上把一些 DOM 節點隱藏起來，有這個需求的原因是因為現在越來越多的自訂 UI 元件，為了達成效果可能用了很多的 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 等元素，但是在做 DOM Traversal 或是 Inspect 時，這些元素的出現其實很多餘，而且看起來會很花，如果是開發要除錯看到大量不相干的東西實在是很干擾，而最重要的其實是，如果要把能讓這些自訂元件模組化再利用，那應該也要能把東西封裝起來。</p>

<p>Shadow DOM 最大的功用就是在 DOM Tree 上能把子文件樹封裝起來的機制，使用很簡單，就在你想要放隱藏元件結構的地方，執行 <code>createShadowRoot()</code>，然後把東西塞進去就可以了：</p>

<pre><code>var host = document.querySelector('.custom-component');
var root = host.createShadowRoot();
host.innerHTML = html_template_string;
</code></pre>

<p>目前應該還只有 Chrome 支援，而且要先去 <code>about:flags</code> 裡面把「Experimental Web Platform features」打開，然後標準還沒定案，所以其實現在要執行 <code>webkitCreateShadowRoot</code> 才會動。這個 function 回傳的東西稱為 <em>shadow root</em>，它下面的文件樹就稱為 <em>shadow tree</em>，至於 <code>host</code> 那個變數所指的 DOM node 則是 <em>shadow host</em>。</p>

<p>簡單說的 Shadow DOM 就這樣講完了，不過事情當然不會這麼簡單，還有幾個問題要解決，首先第一個是 style，要給 shadow tree 內的元素加上樣式其實就把 style 標籤也插進去就可以了：</p>

<pre><code>var html_template_string = 
    '&lt;style&gt;div { color: red; }&lt;/style&gt;&lt;div&gt;Click me!&lt;/div&gt;';
</code></pre>

<p>預設這種在 shadow tree 裡面的 style 都是 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#attr-style-scoped">scoped</a> 的，是從 host 節點開始算，所以包括 host 節點本身也會受到影響，而在這邊，一個新的 CSS at-rule <code>@host</code> 就誕生了，是專門從 shadow tree 裡面來對外面的 host 節點的樣式做調整用的：</p>

<pre><code>@host {
    .custom-component {
        display: inline-block;
    }
}
</code></pre>

<p>第二個問題則是，如果我要做的 custom element 是下拉式選單時，我的選項哪裡來呢？當然我可以直接把東西用 JS 寫到 shadow tree 裡面，但是如果是用以前的 <code>&lt;select&gt;</code> 的話，是用 <code>&lt;select&gt;</code> 下的子節點作為選項的來源。：</p>

<pre><code>&lt;select&gt;
    &lt;option value="1"&gt; 1
    &lt;option value="2"&gt; 2
    &lt;option value="3"&gt; 3
&lt;/select&gt;
</code></pre>

<p>如果要用 shadow DOM 做到類似的效果，把複雜的 UI 呈現用結構藏起來，只讓單純的選項出現在文件樹內，也是可以辦到的，不過比較複雜，這個特性叫 distribution，配合一個新的標籤 <code>&lt;content&gt;</code> 和 CSS selector 來把 shadow host 的子元素移動到 shadow tree 內。</p>

<p>舉例來說，下面是我的 shadow host 節點：</p>

<pre><code>&lt;div class="x-header"&gt;
    &lt;h1&gt;Site Name&lt;/h1&gt;
    &lt;h2&gt;Section 1&lt;/h2&gt;
    &lt;h2&gt;Section 2&lt;/h2&gt;
    &lt;h2&gt;Section 3&lt;/h2&gt;
&lt;/div&gt;
</code></pre>

<p>除了他自己外還有一個大標題，三個小標題。然後我希望丟進 shadow root 的結構如下：</p>

<pre><code>&lt;header&gt;
   &lt;img src="logo.png" /&gt;
   &lt;h1&gt;Site Name&lt;/h1&gt;
&lt;/header&gt;
&lt;nav&gt;
    &lt;div class="wrapper"&gt;
        &lt;h2&gt;Section 1&lt;/h2&gt;
        &lt;h2&gt;Section 2&lt;/h2&gt;
        &lt;h2&gt;Section 3&lt;/h2&gt;
    &lt;/div&gt;
&lt;/nav&gt;
</code></pre>

<p>那麼我可以用 <code>&lt;content&gt;</code> 來辦到：</p>

<pre><code>&lt;header&gt;
   &lt;img src="logo.png" /&gt;
   &lt;content select="h1"&gt;
&lt;/header&gt;
&lt;nav&gt;
    &lt;div class="wrapper"&gt;
        &lt;content select="h2"&gt;
    &lt;/div&gt;
&lt;/nav&gt;
</code></pre>

<p><code>select</code> 屬性的內容是 CSS selector，可以把符合該 selector 的 shadow host 子節點抓出來放在 <code>&lt;content&gt;</code> 的位置。如果不給任何 selector 的話，就會把全部的東西都抓過去，像下拉選單就可以用這種方式來把選項填入 shadow tree。</p>

<p>不過這邊要注意，distributed 的 DOM node 吃的樣式是外面的文件的樣式，shadow tree 裡面的 style 不會套用到他們上面。</p>

<p>第三個問題是，用 JS 字串或是動態產生 DOM 節點的方式來作 shadow DOM 的內容實在很多問題，所以 HTML 還多了個 <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html">Templates</a> 擴充，就是多了一個眾望所歸的 <code>&lt;template&gt;</code> 標籤，內容會 parse，會有內容的 DOM tree，但是不 render，所以裡面需要的圖片、JS 等等都不會抓下來，然後 template 標籤的 <code>content</code> 屬性就是內容的 DOM node，所以第一段程式碼範例就可以改寫成：</p>

<pre><code>var host = document.querySelector('.custom-component');
var root = host.createShadowRoot();
var clone = templateNode.content.cloneNode(true);
root.appendChild(clone);
</code></pre>

<p>以前比較常見的作法是用 <code>&lt;script&gt;</code> 標籤，然後說 type 是某個瀏覽器不認得的語言，像是 "text/template" 之類的，這樣瀏覽器就不會去執行內容，不過這方法的缺點一就是語意不對，二是潛藏有安全性問題。</p>

<h4>Custom Element</h4>

<p>Custom Element 的部分就是定義了怎樣在 document 下定義新的自訂標籤，不是以前剛進入 HTML5 時代時為了語意而產生的新標籤，這邊說的自訂標籤通常都是為了有特殊的用途，會能和使用者有互動，可以操控等特性的，只用 shadow DOM 的話，雖然可以把整個元件封裝起來，但是最外層還是用 div 標籤來把東西包起來，在語意上不太合，而且加上可能有非同步的問題，新標籤可能是動態插入文件樹內，傳統的方法並不方便處理這種狀況。</p>

<p>在繼續之前要先說，網路上還可以看到一些比較舊的文章有介紹 <code>&lt;element&gt;</code> 這個標籤，不過該標籤目前已經被廢棄了，custom element 現在是全由 JavaScript 那邊來和 document 作溝通，所以基本上就是定義了一組 document 的擴充 API，<em>register</em>：</p>

<pre><code>document.register('x-button', {prototype: xButtonProto});
</code></pre>

<p>這樣在這個文件樹下，就有了 <code>&lt;x-button&gt;</code> 這個新的標籤，其中標籤的命名方式是有建議一定要有個 '-' 的，有 '-' 的標籤，在有定義之前，會被認為是 unresolved element，可以用新的 CSS pseudo class <code>:unresolved</code> 來隱藏起來，避免類似 FOUT 的現象，但是如果你沒有 '-' 而只是用了簡單的單詞來作自訂標籤的名稱，像是 slider、calendar 之類的，這樣就會被認為是 unknown element，就沒辦法用 <code>:unresolved</code> 了。</p>

<p>第二個參數則是 option object，其中的 prototype 則是定義了關於這個新的自訂標籤的行為，通常會從 HTMLElement 繼承來：</p>

<pre><code>var xButtonProto = Object.create(HTMLElement.prototype);
</code></pre>

<p>然後接著定義它的 <a href="http://w3c.github.io/webcomponents/spec/custom/#custom-element-lifecycle">lifecycle</a> callback function，lifecycle 這是個新的東西，在 custom element 的標準裡面定義了一個標籤的一生會發生的事情，包括：</p>

<ul>
<li>created</li>
<li>enteredView</li>
<li>leftView</li>
<li>attributeChanged</li>
</ul>

<p>最常會用到的大概就是 created 了吧：</p>

<pre><code>xButtonProto.createdCallback = function () {
    var root = this;
    var host = this.webkitCreateShadowRoot();
    var clone = tpl.content.cloneNode(true);
    host.appendChild(clone);
};
</code></pre>

<p>像這樣定義 lifecycle callback，就會在 <code>&lt;x-button&gt;</code> 插入文件時，把他裡面的 shadow tree 建好，同時你也可以把一些事件和行為也在這個時間點建立起來。要拿到 shadow tree 裡面的元素的話，可以直接對 shadow host 下 query selector 指令來達成。</p>

<p>目前 WebKit 雖然有支援 custom element，不過也還是實驗中的狀態，要自己去把 'Experimental Web Platform features' 選項打開。</p>

<h4>HTML Imports</h4>

<p>HTML Imports 雖然是比較晚期才聽到有成形的標準，不過其實很早之前，在 Web Component 的概念成形之前，就已經有很多地方有類似的，引用外部資源需求了，所以標準的設計也沒有局現在 Web Component 的使用，結果而言，在 Web Component 這塊，import 的功能是讓 Web Component 的程式碼能夠在維護、發布時也能模組化、封裝起來的關鍵標準，但是他的設計方向卻不是以此為中心，HTML Imports 設計上市 link 標籤的一個擴充：</p>

<pre><code>&lt;link rel="import" href="component.html" /&gt;
</code></pre>

<p>結果就是，有支援 HTML Imports 的瀏覽器就會把 component.html 抓下來也 parse 過，正常網頁該抓的圖片、script，該跑的 script 也都會真的執行，而且在該檔案內的 script 執行環境的 document 和外面的 document 是同一個。所以理論上，只要把所有的 custom element 相關的東西移到獨立的檔案，然後在 import 進來就好了，這樣就可以保持主文件內容的乾淨，也可以讓這些自訂的標籤能夠獨立管理，方便維護。</p>

<p>不過這邊有個細節需要注意，就是要怎麼在被 import 的 component.html 裡面的 script 中，去 query component.html 的內容呢？例如我要 query template 出來塞到 shadow tree 裡面，那就要用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.currentScript">currentScript</a> 這個 HTML5 的 API：</p>

<pre><code>var doc = document.currentScript.ownerDocument;
var tpl = doc.getElementById('x-button-template');
</code></pre>

<p>這個寫法在非 import 的 HTML 文件中也是可以動的，所以即使沒有要用 HTML Imports 也可以直接用這個寫法，而 currentScript 的出現其實一部分原因是為了大量的第三方 widget 吧，像是 Facebook like button 之類的，它會給的通常是一個 script 標籤，然後我們把他放到想放的位置，script 再用 document.write 寫入 widget 元素，不過 document.write 不支援 async 的操作，還會有效能 issue，然而 currentScript 會指到現在這行程式碼所在的 <code>&lt;script&gt;</code>，就可以非同步的用標準的 DOM 操作而不需要 document.write 也可以把東西放到正確的位置，這樣就可以解決很多這種第三方 script 插入元素的定位問題。</p>

<p>到這邊就可以把上面的東西全部接在一起了，目錄下會有以下檔案：</p>

<ul>
<li>index.html</li>
<li>x-button/x-button.html</li>
<li>x-button/x-button-style.css</li>
<li>x-button/x-button-script.js</li>
</ul>

<p>x-button.html 的內容：</p>

<pre><code>&lt;template id="x-button-template"&gt;
    &lt;style&gt;
        @import 'x-button/x-button-style.css';
    &lt;/style&gt;

    &lt;div class="x-button"&gt;
        &lt;i class="icon"&gt;&lt;/i&gt;
        &lt;div class="content"&gt;&lt;content&gt;&lt;/div&gt;
    &lt;/div&gt;

&lt;/template&gt;

&lt;script src="x-button-script.js"&gt;&lt;/script&gt;
</code></pre>

<p>CSS 跳過，js 的內容：</p>

<pre><code>var doc = document.currentScript.ownerDocument;
var tpl = doc.getElementById('x-button-template');
var xButtonProto = Object.create(HTMLElement.prototype);

xButtonProto.createdCallback = function () {
    var root = this;
    var host = this.webkitCreateShadowRoot();
    var clone = tpl.content.cloneNode(true);
    host.appendChild(clone);
};

document.register('x-button', {prototype: xButtonProto});
</code></pre>

<p>最後 html 的內容：</p>

<pre><code>&lt;link rel="import" href="x-button/x-button.html"&gt;

&lt;x-button&gt;Super Button&lt;/x-button&gt;
</code></pre>

<h4>Library</h4>

<p>瀏覽器的實作，目前是 Chrome 最完整，不過都還在測試，要自己去把功能打開，其中 HTML Imports 比較新，Firefox 也還不支援，不過想要用的話還是可以透過兩套 JavaScript Library 來用，一個是 Google 的 Polymer，另外一套是 Mozilla 的 <a href="http://www.x-tags.org/">&lt;x-tags&gt;</a>，Mozilla 的比較單純，就是可以方便定義 Custom Element 的一套 Library，看上面的介紹可以知道要定義一個 custom element 有很多地方要處理，x-tags 則是另外定義了一套 API 來把東西都集中起來，順便也把 custom element 登錄到文件內，另外也開了一個 repository 來收集大家做的 custom element，至於底層的部份，其實是用 Polymer 的 polyfill - platform.js。</p>

<p>Polymer 這套涵蓋的範圍就比較大了，首先它為了讓 Web Component 的相關新標準可以在現在的主流瀏覽器上動，它把這些標準的 polyfill 的做好了，接著基於這些標準做了 polymer-element 和 data binding 機制等核心的功能，然後開發者就可以用這些東西建構自己想要的 custom component，當然它也提供一些常用的 cusotm element，拼裝起來就可以把 application 建構出來。</p>

<p>Polymer 其實除了上面說的三個標準外，還做了好幾個 polyfill，包括 Web Animations、Pointer Event 以及目前沒有在標準內的 binding 機制我覺得終極目標應該是會和 AngularJS 相輔相成，畢竟現在 AngularJS 的 directive 機制就有點像是 Web Component + data binding 的組合。</p>

<h4>Summary</h4>

<p>其實 Web Component 真的是越看越覺得細節很多，這篇文章其實還是有不少沒提到的細節，不過大部分都可以在參考文獻中找到，有很多東西其實都還在進行中，文件不完整，找的到的範例也太過單純，不過相信資源會越來越完整，目前看起來 Web Component 的潮流遲早會成為主流，加上 Google 還把這麼多標準的 polyfill 都做好了，AngularJS 也把 component 的模式在開發者之間帶起來，我想整個潮流只會越來越快。</p>

<h4>Reference</h4>

<p>最後整理一下參考資料，有不少細節和一些相關的東西這篇文章還沒有講，之後有機會在分享吧。首先是 w3c 的 editor draft，包含三份 spec 還有一篇 <a href="http://w3c.github.io/webcomponents/explainer/">intro</a>：</p>

<ul>
<li><a href="http://w3c.github.io/webcomponents/">Web Component Editor Draft</a></li>
<li><a href="http://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM Editor Draft</a></li>
<li><a href="http://w3c.github.io/webcomponents/spec/custom/">Custom Element Editor Draft</a></li>
<li><a href="http://w3c.github.io/webcomponents/spec/imports/">HTML Imports Editor Draft</a></li>
</ul>

<p>Specs：</p>

<ul>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a></li>
<li><a href="http://www.w3.org/TR/custom-elements/">Custom Element</a></li>
<li><a href="http://www.w3.org/TR/html-imports/">HTML Imports</a></li>
<li><a href="http://www.w3.org/TR/pointerevents/">Pointer Events</a></li>
<li><a href="http://www.w3.org/TR/web-animations/">Web Animations</a></li>
</ul>

<p>然後 HTML5 Rocks 有好幾篇文章：</p>

<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/customelements/">Custom Element</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/">HTML Imports</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">Template</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">Shadow DOM 201</a>，特別要注意現在 pseudo 屬性已經沒了，改成 part 了。</li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/">Shadow DOM 301</a></li>
</ul>

<p>看到各主題的篇數就知道什麼東西比較複雜了，還有一些其他地方的介紹文章：</p>

<ul>
<li><a href="http://css-tricks.com/modular-future-web-components/">Modular Future Web Components</a></li>
<li><a href="http://html5-demos.appspot.com/static/webcomponents/index.html">&lt;web&gt;components&lt;/web&gt;</a></li>
<li><a href="http://robdodson.me/blog/2013/08/20/exploring-html-imports/">Exploring HTML Imports</a></li>
</ul>

<p>一個 Web Component 的 <a href="http://jonrimmer.github.io/are-we-componentized-yet/">支援度檢查表</a> 和 shadow DOM <a href="http://html5-demos.appspot.com/static/shadowdom-visualizer/index.html">視覺化工具</a>。Google 推廣還算蠻用力的，今年的 Google IO 有不少 <a href="https://developers.google.com/events/io/sessions">場次</a> 有相關，還有一個 Google Plus <a href="https://plus.google.com/103330502635338602217/posts">專頁</a>。</p>

<p>Libraries 的就是上面說到的兩個，Google 的 Polymer，建議可以去他的 Github 看看，然後還有 Mozilla 的 x-tags 和 Brick，其中 Brick 沒說到，不過他是基於 x-tag 的專案，要來收集各種 custom element，然後未來可以疊床架屋用的：</p>

<ul>
<li><a href="http://www.polymer-project.org/">Polymer</a></li>
<li><a href="http://www.x-tags.org/">x-tags</a></li>
<li><a href="http://mozilla.github.io/brick/">Brick</a></li>
</ul>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000766" baseName="mobile-web-application-mopcon">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-10-31</b:date>
				<b:time>11:53:16</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Mobile Web Application 甘苦談</b:title>
			<b:content>
				<b:summary>上個週末在 MOPCON 演講的投影片： /*A_A*/...</b:summary>
				<b:mainContent><p>上個週末在 <a href="http://mopcon.org/2013/">MOPCON</a> 演講的投影片：</p>

<script async="async" class="speakerdeck-embed" data-id="0c7d22d02409013107c55e2c4b81d3ea" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/*A_A*/</script>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000763" baseName="javascript-object-you-dont-know">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-09-16</b:date>
				<b:time>20:47:28</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>你所不知道的 JavaScript Object</b:title>
			<b:content>
				<b:summary>以前在寫 VB 時，看到物件有 set/get 可以用，你可以用簡單的存取方式設定或取得物件的某個屬性，但是實際上存取時做一些操作和運算，對物件外來說，就和一般屬性一樣的，當時覺得這個特性還蠻方便的，不過這不是所有程式語言都有的，像是當年的 JavaScript 就沒有，不過時光飛逝，歲月如梭，其實現在 JavaScript 也支援 get/set 了，只是要用 defineProperty 來設定，沒辦法用 Good Part 裡面建議的，單純用 object literal notation，當然比較舊的 IE 也不支援，寫起來如下： var square = { side: 1 }; Object.defineProperty(square, 'area', { get: function () { return Math.pow(this.side, 2); }, set:...</b:summary>
				<b:mainContent><p>以前在寫 VB 時，看到物件有 set/get 可以用，你可以用簡單的存取方式設定或取得物件的某個屬性，但是實際上存取時做一些操作和運算，對物件外來說，就和一般屬性一樣的，當時覺得這個特性還蠻方便的，不過這不是所有程式語言都有的，像是當年的 JavaScript 就沒有，不過時光飛逝，歲月如梭，其實現在 JavaScript 也支援 get/set 了，只是要用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty</a> 來設定，沒辦法用 Good Part 裡面建議的，單純用 object literal notation，當然比較舊的 IE 也不支援，寫起來如下：</p>

<pre><code>var square = {
    side: 1
};

Object.defineProperty(square, 'area', {
    get: function () {
        return Math.pow(this.side, 2);
    },
    set: function (val) {
        this.side = Math.pow(val, 0.5);
    }
});
</code></pre>

<p>不過，defineProperty 的功能可不止於此，它提供了更改更為底層設定的能力，包括 configurable、enumerable 和 writable 三個設定。configurable 表示這個屬性的設定是否可以再次用 defineProperty 更改，writable 比較簡單就是表示這個屬性的值是否可以修改，enumerable 則是設定這個屬性在列舉的時候會不會被列出，物件的列舉其實就是用 <code>for in</code>：</p>

<pre><code>for (attr in obj) {
    obj[attr] = 'foo';
}
</code></pre>

<p>如果有在用 JSLint 可能會看過這樣寫的話都會跳出下面的錯誤訊息：</p>

<blockquote>
  <p>The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype</p>
</blockquote>

<p>這是因為用 <code>for in</code> 的話，會把 prototype 裡面的屬性也列舉出來，這樣會有什麼問題呢，以前在做陣列的新 method 的 polyfill 時，會有個狀況就是，我們手動新增的 method，會在列舉時被列出，所以變成所有的陣列都不能用 <code>for in</code> 來跑，但是現在有 defneProperty 的 enumerable 了，未來在有類似的狀況，可以直接給陣列新增 method 而不會影響 <code>for in</code> 的行為。</p>

<p>除了 defineProperty 之外，還有 defineProperties 可以大量設定屬性，另外也可以在 Object.create 時直接設定好。</p>

<p>第二個要說的是，現在 JavaScript 的物件可以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">封</a>(seal) 起來或是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">凍</a>(freeze) 起來了，seal 做的事情是限制物件屬性的新增或刪除，既有屬性的值還是可以修改，freeze 則是把物件完全凍結住，連修改屬性都不可以。而且這些行為是不可逆的，沒有提供可以 unseal 或是 unfreeze 的方法，不過倒是有 <code>isSealed</code> 和 <code>isFrozen</code> 可以判斷物件狀態。</p>

<p>在 strict mode 下，上面兩個特性有限制的地方在被違反的時候，都會 throw error，普通模式下是不會有錯誤，不過他的行為還是不變，使用時需要注意。</p>

<p>最後要介紹的是還不能使用的 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe">observe</a>，observe 又稱為觀察者，在 Backbone 有利用 set 和事件系統來實做，是在開發應用程式時很有用的 pattern，TC39 有打算把它加進 JavaScript 之中，目前還只有草案就是，要能用應該還要好一陣子就是了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
