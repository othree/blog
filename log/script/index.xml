<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>c</b:listType>
			<b:listData listID="script">script</b:listData>
		</b:entriesMeta>

		<b:entry entryID="000751" baseName="javascript-primitives-obj">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-30</b:date>
				<b:time>14:24:41</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>JavaScript Primitives Objects</b:title>
			<b:content>
				<b:summary>接續上一篇文章，JavaScript 的資料型別可以分為兩類：基本型別(primitive value)和物件(object)。基本型別包含字串、數值、布林值等，物件除了物件外，還有像是函數、Regular Expression 等。JavaScript 還有一組很特別的 constructor，對應到每種基本型別，所以你可以 new String('blah'); 來產生基本型別的物件： new String('blah'); new Number(42); ner Boolean(true); 如果看最近的書本和教學都會說不要使用這種方法來建立這些基本型別，缺點有效能問題、API 設計不好，會有混淆等等。不過如果是物件的話，不就可以很方便的做一些操作了嗎？ 這兩年很受歡迎的 Ruby 有一個特性就是所有的基本型別都是物件，所以就可以很簡單的用一些串接的方式直接對這些基本型別進行操作： str = 'hello' str.capitalize # Hello str.capitalize! str # Hello str.count('l') # 2 在 JavaScript 中的基本型別其實不需要以物件的形式，也可以做類似的操作： var str =...</b:summary>
				<b:mainContent><p>接續上一篇文章，JavaScript 的資料型別可以分為兩類：基本型別(primitive value)和物件(object)。基本型別包含字串、數值、布林值等，物件除了物件外，還有像是函數、Regular Expression 等。JavaScript 還有一組很特別的 constructor，對應到每種基本型別，所以你可以 <code>new String('blah');</code> 來產生基本型別的物件：</p>

<pre><code>new String('blah');
new Number(42);
ner Boolean(true);
</code></pre>

<p>如果看最近的書本和教學都會說不要使用這種方法來建立這些基本型別，缺點有效能問題、API 設計不好，會有混淆等等。不過如果是物件的話，不就可以很方便的做一些操作了嗎？</p>

<p>這兩年很受歡迎的 Ruby 有一個特性就是所有的基本型別都是物件，所以就可以很簡單的用一些串接的方式直接對這些基本型別進行操作：</p>

<pre><code>str = 'hello'
str.capitalize        #  Hello
str.capitalize!
str                   #  Hello
str.count('l')        #  2
</code></pre>

<p>在 JavaScript 中的基本型別其實不需要以物件的形式，也可以做類似的操作：</p>

<pre><code>var str = 'hello';
str.length;           // 2
str.contains('l');    // true
str.indexOf('l');     // 2
</code></pre>

<p>但是如果想要更進一步的在上面加上屬性或是 method 就會發現行不通：</p>

<pre><code>var str = 'hello';
str.target = 'world';
str.target;            // undefined
</code></pre>

<p>這中間到底是有什麼差異呢？這個問題我想了很久，直到看了 <a href="http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/">The Secret Life of JavaScript Primitives</a> 這篇文章才瞭解，最後面這個例子，其實等同於：</p>

<pre><code>var str = 'hello';
(new String(str)).target = 'world';
(new String(str)).target;
</code></pre>

<p>當使用物件形式的 <code>.</code> 運算子對基本型別資料操作的時候，會產生一個新的物件，然後用完就丟掉，所以在指派 target 屬性那行操作到的物件，和要取回 target 屬性那行的物件，是完全不一樣的兩個物件，這也就是為什麼這些資料可以用類似物件的方法操作，但是卻不能真的像物件一樣使用。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000750" baseName="javascript-is-untyped">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-30</b:date>
				<b:time>00:08:06</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>JavaScript is Untyped</b:title>
			<b:content>
				<b:summary> 上週去聽 Gias Kay Lee 講 Animation in AngularJS，說到 JavaScript 其實是 untyped language，因為我沒受過 Computer Science 的正統教育，這名詞對我來說是新的，所以回來花了些時間看網路上的文件。 Wikipedia 上的文章不少，不過看起來比較吃力，Stack Overflow 上也有幾則不錯的問答，對我來說幫助很大，這個問題其實也沒很複雜，在 Computer Science 上來說，是不使用 strong type 和 weak type 來形容程式語言的，因為沒有明確的定義，取而代之的，是數個有明確定義的相關特性：type safety、memory safety、static/dynamic type checking、type conversions。 所以我之前 文章 說到 JavaScript 是 weak...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/9167965602/" title="Flickr 上 othree 的 untyped"><img src="//farm6.staticflickr.com/5328/9167965602_d9be012d23_b.jpg" width="674" height="382" alt="untyped" srcset="//farm6.staticflickr.com/5328/9167965602_d9be012d23.jpg 768w, //farm6.staticflickr.com/5328/9167965602_d9be012d23_b.jpg 768w 2x" /></a></p>

<p>上週去聽 <a href="https://twitter.com/gsklee">Gias Kay Lee</a> 講 <a href="http://slid.es/gsklee/animation-in-angularjs">Animation in AngularJS</a>，說到 JavaScript 其實是 <a href="http://en.wikipedia.org/wiki/Talk%3ATyped_and_untyped_languages#.22Untyped_Language.22">untyped language</a>，因為我沒受過 Computer Science 的正統教育，這名詞對我來說是新的，所以回來花了些時間看網路上的文件。</p>

<p>Wikipedia 上的文章不少，不過看起來比較吃力，Stack Overflow 上也有幾則不錯的<a href="http://stackoverflow.com/questions/964910/is-javascript-an-untyped-language">問答</a>，對我來說幫助很大，這個問題其實也沒很複雜，在 Computer Science 上來說，是不使用 strong type 和 weak type 來形容程式語言的，因為沒有明確的定義，取而代之的，是數個有明確定義的相關特性：type safety、memory safety、static/dynamic type checking、type conversions。</p>

<p>所以我之前 <a href="https://blog.othree.net/log/2013/06/01/dependency-injection-of-angularjs/">文章</a> 說到 JavaScript 是 weak type 那段其實應該要說是 untyped 會比較好。其實講到 type 的問題，就會想到 JavaScript 的效能問題，Brendan Eich 說過 JavaScript 引擎很難跑得快的原因就是因為它是 untyped 的。在 <a href="http://www.html5rocks.com/en/tutorials/speed/v8/">Performance Tips for JavaScript in V8</a> 這篇文章有提到，V8 引擎其中有一個提升速度的設計是給變數 hidden class，這個 hidden class 其實就是隱藏的變數型別，如果你的變數從頭到尾都維持同樣的型別，例如整數永遠是整數、字串永遠是字串，而不會有中間換型別的情形，那 V8 引擎就可以利用 hidden class 的資訊來提升運算速度，我覺得這個 tip 很不錯，不只是 V8 可以跑比較快，即使其他引擎沒有受益，作為寫程式時的 good practice 也很受用，減少了程式內的不可預期性。</p>

<p>另外一個我覺得很相似的例子是這兩年新的 <a href="http://asmjs.org/spec/latest/">asm.js</a>，asm.js 是一個 JavaScript 的子集，設計上可以直接做一些比較低階的操作，像是直接 allocate 記憶體還有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">Typed Array</a> 等，而其中還定義了一組相容於普通 JavaScript 的寫法來宣告變數的型別：</p>

<pre><code>function f(x, y) {
    x = x|0;      // int parameter
    y = +y;       // double parameter

    return;
}
</code></pre>

<p>只是 asm.js 會直接手寫的應該很少，像 asm.js 有名的例子： Unreal Engine 就是用工具 compile 過去的。</p>

<p>PS: 我還找不到上面那張圖片的投影片出處，有人知道的話麻煩告訴我，感謝。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="1"></b:comments>


		</b:entry>

		<b:entry entryID="000746" baseName="options-object">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-19</b:date>
				<b:time>01:35:15</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Options Object</b:title>
			<b:content>
				<b:summary> 上一篇文章 DOM Event Module 有講到 function API 設計收 option 物件比不同設定的值分開接收還好，這篇就要介紹一下這個 pattern，其實這個 pattern 我看過好幾篇文章講了，想不到等我現在要寫文章時卻找不太到，因為關鍵字有點太通用，不過剛好最近看完的 Effective JavaScript 也有說到這個 pattern，所以就拿他當參考文獻了~~ 這種設計的優點第一個當然就是前一篇有說到的，使用時的程式碼，用看的就知道不同的參數是什麼意義，直接偷 Effective JavaScript 的範例來，先看看不是 options object 的： var alert = new Alert(100, 75, 300, 200, "Error", messaage, "blue", "white", "black", "error", true);...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/9074497361/" title="Flickr 上 othree 的 Options Object"><img src="//farm4.staticflickr.com/3829/9074497361_5298d2643e_b.jpg" width="1024" height="683" alt="Options Object" srcset="//farm4.staticflickr.com/3829/9074497361_5298d2643e.jpg 768w, //farm4.staticflickr.com/3829/9074497361_5298d2643e_b.jpg 768w 2x, //farm4.staticflickr.com/3829/9074497361_013ef7e2be_k.jpg 2x" /></a></p>

<p>上一篇文章 <a href="https://blog.othree.net/log/2013/06/18/dom-event-module/">DOM Event Module</a> 有講到 function API 設計收 option 物件比不同設定的值分開接收還好，這篇就要介紹一下這個 pattern，其實這個 pattern 我看過好幾篇文章講了，想不到等我現在要寫文章時卻找不太到，因為關鍵字有點太通用，不過剛好最近看完的 <a href="http://effectivejs.com/">Effective JavaScript</a> 也有說到這個 pattern，所以就拿他當參考文獻了~~</p>

<p>這種設計的優點第一個當然就是前一篇有說到的，使用時的程式碼，用看的就知道不同的參數是什麼意義，直接偷 Effective JavaScript 的範例來，先看看不是 options object 的：</p>

<pre><code>var alert = new Alert(100, 75, 300, 200, 
                      "Error", messaage,
                      "blue", "white", "black",
                      "error", true);
</code></pre>

<p>這個例子比我前一篇的例子還要複雜許多，相信更能夠感覺到這些參數分別的意義很難判斷吧，所以改成用 options object 的：</p>

<pre><code>var alert = new Alert({
    x: 100, y: 75,
    width: 300, height: 200,
    title: "Error", message: message,
    titleColor: "blue", bgColor: "white", textColor: "black",
    icon: "error", modal: "true"
});
</code></pre>

<p>雖然其實我覺得全部的參數都塞到 options object 也不好，不過這問題不是這篇文章的重點，接下來要說的是另外一個優點，就是 API 介面可以和參數的數量脫勾（decouple），在未來更新改版增加新選項時也不用改參數的設計，這個優點要舉的例子是 <a href="http://api.jquery.com/jQuery.ajax/">jQuery.ajax</a>，他的第二個參數就是 options object，可以看文件有詳細的介紹所有的可以用選項，然後有一些選項，像是 headers、converts 就是後來才新增的，而 jQuery.ajax 本身收的參數則是從 1.0 之後就沒有變化了。</p>

<p>收了參數之後，通常第一步要做的是填預設值，很多的 JavaScript Library 都有提供 extend 可以利用，以 jQuery.ajax 為例，它用的是特製的 <a href="https://github.com/jquery/jquery/blob/2.0.2/src/ajax.js#L117">ajaxExtend</a>，當然 jQuery 也有提供 [jQuery.extend][] 給一般的 case 使用，undersocre 也有 <a href="http://underscorejs.org/#extend">extend</a>，不過它還有一個填預設值專用的 <a href="http://underscorejs.org/#defaults">defaults</a>，兩者的差別在當初 propose 的 <a href="https://github.com/documentcloud/underscore/issues/106">issue</a> 上介紹的蠻清楚，基本上就是用 defaults 你可以這樣寫：</p>

<pre><code>_.defaults(options, defaultOptions);
</code></pre>

<p>但是如果用 options 要達成一樣的效果，你要寫成：</p>

<pre><code>options = _.extend({}, defaultOptions, options);
</code></pre>

<p>因為 extend 會讓後者的屬性覆蓋掉前者的，所以 defaultOptions 要放在 options 前面，但是 extend 回傳的是前面那個物件，所以要取代原本的 options 還要多一個 assign，至於 defaults 則是會改原來的 options 物件，所以不需要多那個 assign，也不需要先丟一個空物件給它，如果要讓 options 是可省略的參數，用 CoffeeScript 還可以在定義 function 時給它預設值，整個程式碼就漂亮很多：</p>

<pre><code>mylib.ajax = (url, options = {}) -&gt;
    _.default(options, defaultOptions)
</code></pre>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="1"></b:comments>


		</b:entry>

		<b:entry entryID="000745" baseName="dom-event-module">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-18</b:date>
				<b:time>16:51:19</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Native DOM Event Module</b:title>
			<b:content>
				<b:summary>我是在看 tap.js 的程式碼時，才真的注意到 DOM 的 event module （事件模組）其實我們已經可以拿來用了，關鍵在於比較少人注意到的 dispatchEvent 這個 method，這個 method 可以讓你對任意的 DOM Node 觸發任意事件，不管是 click 事件、mousemove 事件，還是 keydown 事件都可以，所以理論上你可以用 JS 模擬所有使用者做的操作，要做 integration 測試也沒問題，不過像是滑鼠拖拉要模擬就有點辛苦了。而除了原生有的事件外，其實 dispatchEvent 還支援自訂事件，對於自訂事件用途還不清楚的可以先看看以前的文章。 dispatchEvent 的用法和一般 JavaScript Library 的 trigger event 不太一樣，要先建立一個 event 物件給他： var event =...</b:summary>
				<b:mainContent><p>我是在看 <a href="http://alxgbsn.co.uk/2012/03/12/tap-js-a-lightweight-tap-event-javascript-plugin/">tap.js</a> 的程式碼時，才真的注意到 DOM 的 event module （事件模組）其實我們已經可以拿來用了，關鍵在於比較少人注意到的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.dispatchEvent">dispatchEvent</a>  這個 method，這個 method 可以讓你對任意的 DOM Node 觸發任意事件，不管是 click 事件、mousemove 事件，還是 keydown 事件都可以，所以理論上你可以用 JS 模擬所有使用者做的操作，要做 integration 測試也沒問題，不過像是滑鼠拖拉要模擬就有點辛苦了。而除了原生有的事件外，其實 dispatchEvent 還支援自訂事件，對於自訂事件用途還不清楚的可以先看看以前的<a href="https://blog.othree.net/log/2010/05/20/jquery-events/">文章</a>。</p>

<p>dispatchEvent 的用法和一般 JavaScript Library 的 trigger event 不太一樣，要先建立一個 event 物件給他：</p>

<pre><code>var event = document.createEvent('Event');
event.initEvent(type, true, true);

domnode.dispatchEvent(event);
</code></pre>

<p>其中的 type 才是你想要觸發的事件名稱，而第一個 createEvent 收的參數，除了 "Event" 這個最通用的之外，還有很多種<a href="https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent">原生事件</a>，如果是要自訂事件的話，可以用最通用的 "Event"。不過其實，還有一個比較新的 API：</p>

<pre><code>var event = new CustomEvent(type, {bubbles: true, cancelable: true});
</code></pre>

<p>這是 DOM Level 4 裡面提出來的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">Custom Event Constructor</a>，在這之前的 Level 3 就可以用第一個範例的方法產生 custom event，要先 create 再 init。這邊岔題一下，應該有人會注意到，createEvent 後 initEvent 那邊的 API 設計和 CustomEvent 不一樣，initEvent 收三個值，後面兩個都傳了 true，可是這樣的 API 設計近年來都被認為是不好的，因為你看程式碼，你完全不知道這兩個 true 是什麼意思，所以都是建議用第二種 API 的設計，收一個 options 物件，其實，initEvent 那兩個 true 分別就是 CustomEvent 後面的 bubbles 和 cancelable，但是後者的設計就可以讓程式碼看一眼就知道那兩個 true 是什麼用途的，看到這種不止開發者的程式在進化，連標準也跟著一起演進的現象還蠻有趣的~</p>

<p>Custom Event Constructor 目前 IE 的支援還比較差，所以還不能直接使用，還是要做一下 feature detection。至於哪些物件可以使用這些 method，除了 DOM Node，外，其實一般瀏覽器都還有一些物件可以聽事件，像是 window、document、 XMLHttpRequest instance 等，很可惜不是任意物件都可以，事實上，這些可以使用 DOM Event Module 的物件都是實作了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget</a> 這個介面，不過又要再說一次很可惜的，目前沒辦法把瀏覽器內的這些實作偷出來給其它物件使用，幸好 Andrea Giammarchi 有做了 <a href="https://github.com/WebReflection/event-target">一個</a> 放在 Github 上，可以給一般物件繼承去用。</p>

<p>我曾經寫過一篇文章介紹 <a href="https://blog.othree.net/log/2007/02/06/third-argument-of-addeventlistener/">addEventListener 的第三個參數</a>，這篇文章的最後我要來介紹第二個參數，第二個參數一般都是丟 function 進去，不過他其實也可以丟 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener">EventListener</a> 進去，基本上就是一個物件有 handleEvent 來當事件的 callback 而已，不過像 tap.js 就有很有趣的用法，它不管是什麼事件，在<a href="https://github.com/alexgibson/tap.js/blob/f6a3eef75e448de5ce2a659570cfd4511570f672/tap.js#L35">加上 addEventListener 時</a>丟進去的都是 this 物件，實際上則是統一在 handleEvent 裡面在<a href="https://github.com/alexgibson/tap.js/blob/f6a3eef75e448de5ce2a659570cfd4511570f672/tap.js#L97">根據事件的不同去作不同的事情</a>：</p>

<pre><code>Tap.prototype.handleEvent = function (e) {
    switch (e.type) {
        case 'touchstart': this.start(e); break;
        case 'touchmove': this.move(e); break;
        case 'touchend': this.end(e); break;
        case 'touchcancel': this.cancel(e); break;
        case 'mousedown': this.start(e); break;
        case 'mousemove': this.move(e); break;
        case 'mouseup': this.end(e); break;
    }
};
</code></pre>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000744" baseName="dependency-injection-of-angularjs">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-01</b:date>
				<b:time>01:56:48</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Dependency Injection of AngularJS</b:title>
			<b:content>
				<b:summary>在公開 javascript-libraries-syntax.vim 之後，我收到的第一個 Issue 就是支援 AngularJS，因為我一直都沒寫過，所以就花了些時間下去研究，然後就看到一個很有趣的名詞：Dependency Injection AngularJS 有一些很特別的參數，像是 $scope、$http 之類的，只要你的 function 是在 AngularJS 的 framework 內，然後接收的參數用到這些名字，例如： function($http, $q) { // do something with $http and $q } 這個 function 執行的時候，你不用管怎麼把正確的 $http 和 $q 傳給他，AngularJS 自己會幫你把他處理好，而這個特色就被稱為 Dependency Injection，當然除了內建的那些模組外，也可以自己註冊新的名稱對應到你開發的模組。 其實一開始看到這個特性的時候覺得有點神奇，很好奇怎麼做的，因為我想的到的就只有一個方法可以辦到，就是 Function.prototype.toString，這個...</b:summary>
				<b:mainContent><p>在公開 <a href="https://github.com/othree/javascript-libraries-syntax.vim">javascript-libraries-syntax.vim</a> 之後，我收到的第一個 Issue 就是支援 <a href="http://angularjs.org/">AngularJS</a>，因為我一直都沒寫過，所以就花了些時間下去研究，然後就看到一個很有趣的名詞：<strong>Dependency Injection</strong></p>

<p>AngularJS 有一些很特別的參數，像是 <code>$scope</code>、<code>$http</code> 之類的，只要你的 function 是在 AngularJS 的 framework 內，然後接收的參數用到這些名字，例如：</p>

<pre><code>function($http, $q) {
    // do something with $http and $q   
}
</code></pre>

<p>這個 function 執行的時候，你不用管怎麼把正確的 $http 和 $q 傳給他，AngularJS 自己會幫你把他處理好，而這個特色就被稱為 Dependency Injection，當然除了內建的那些模組外，也可以自己註冊新的名稱對應到你開發的模組。</p>

<p>其實一開始看到這個特性的時候覺得有點神奇，很好奇怎麼做的，因為我想的到的就只有一個方法可以辦到，就是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString">Function.prototype.toString</a>，這個 method 會把整個 function 的定義從第一行開始輸出成字串，然後分析字串把參數抓出來，這樣就可以在執行前知道需要哪些模組，本來一直期待是不是有什麼神奇技巧，而不是用 toString 辦到的，結果去看了看原始碼，發現真的就是這樣做的，一下子神秘感就消失了～～</p>

<p>Merrick 有一篇 <a href="http://merrickchristensen.com/articles/javascript-dependency-injection.html">JavaScript Dependency Injection</a>，有比較清楚的介紹到 AngularJS 這塊是怎麼做的。不過其實我對於 AngularJS 的這個特性是不是能稱為 Dependency Injection 一直存疑。</p>

<p>在看介紹 Dependency Injection 的文章時，幾乎舉的例子都是在有 Interface 的語言下，程式內的的相依性都相依在 Interface 上，而不相依在實做的 instance 上，等到實際上跑的時候才根據情況丟不同的實做（implement），而 JavaScript 並沒有這層 interface 的設計，AngularJS 自然也沒有，為此我想了很久，也一直在找網路上的資源，直到昨天終於想通了。</p>

<p>Dependency Injection 的重點不在於用程式語言的 Interface 特性來把相依性抽離，而是利用這樣的設計，讓你的程式不要直接相依於實際的實體（instance），由於 JavaScript 是弱型別的語言，所以其實在定義 function 時，並不需要指定輸入參數的型別，利用這個特性，其實就已經可以達成 Depedency Injection 了，只要實際執行程式時，根據狀況丟入應該丟入的 instance 即可。</p>

<p>AngularJS 則是在這特性之上，利用參數名稱來當成相依的 Interface，實際上程式執行時會是那個模組的實體傳入，就要看是哪一個模組註冊到對應的名稱了。</p>

<p>在我終於想通之後，發現到其實 <a href="http://requirejs.org/">RequireJS</a> 也是很相似的架構，所以就搜尋了一下，果然也有人利用 RequireJS 來做 Dependency Injection，Eric Feminella 寫了 <a href="http://www.ericfeminella.com/blog/2012/12/15/basic-dependency-injection-with-requirejs/">Basic Dependency Injection with RequireJS</a> 這篇文章，裡面的例子很不錯，假設開發一個 Web Applicaiotion，同時需要支援 Desktop 和 Mobile，兩種環境要不同的介面，但是核心的程式運作是一樣的，和 UI 相關的東西則要有 Mobile 用和 Desktop 用，這時候就可以用 Dependency Injection 來根據不同環境，決定要丟 Mobile 版的 UI 模組還是 Desktop 版的，核心的模組則不需要考慮到不同環境的差異，只要確保不同的 UI 模組的介面是一樣的就可以了。</p>

<p>最後還要講的是 RequireJS 的一個語法：</p>

<pre><code>define(function (require) {
    var core = require('core'),
        ui = require('ui');

    // do something with core and ui
});
</code></pre>

<p>我第一次看到這種寫法時就覺得：「不對吧，這樣沒辦法確保這個模組執行時，裡面需要的 core 和 ui 已經有了啊。」因為除了去解析程式碼外，這樣子寫從外面根本不知道 function 裡面 require 了什麼東西，而且現在也不可能讓程式跑到某行暫時停下等其他模組準備好，所以看了 RequireJS 原始碼的結論是，它就是去分析程式碼裡面 require 了什麼東西，然後自動加到這個模組的相依性清單裡面這樣，一樣是用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString">Function.prototype.toString</a> 辦到的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="1"></b:comments>


		</b:entry>

		<b:entry entryID="000743" baseName="this">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-05-19</b:date>
				<b:time>21:25:25</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>this</b:title>
			<b:content>
				<b:summary>這次 JSDC 2013 分享的投影片出來了，這次的主題是比較根基的東西，也算是我寫一陣子 JavaScript 後覺得可以整理出來的一個 Pattern，沒聽現場的，應該看投影片也可以知道我說的是什麼，本來題目是 Magic this，後來改成 this 了，不過已經生好的標題圖片不用太可惜，所以還是放上來了。 /*A_A*/...</b:summary>
				<b:mainContent><p>這次 JSDC 2013 分享的投影片出來了，這次的主題是比較根基的東西，也算是我寫一陣子 JavaScript 後覺得可以整理出來的一個 Pattern，沒聽現場的，應該看投影片也可以知道我說的是什麼，本來題目是 Magic this，後來改成 <strong>this</strong> 了，不過已經生好的標題圖片不用太可惜，所以還是放上來了。</p>

<script async="async" class="speakerdeck-embed" data-id="148e0f10a2b50130c7f86aa80182a416" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/*A_A*/</script>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000741" baseName="chrome-debug-doc">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-05-09</b:date>
				<b:time>00:13:09</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Chrome Debug 文件</b:title>
			<b:content>
				<b:summary>Google Chrome 開發工具的文件昨天有更新，不確定這整頁是新的還是改寫，不過總之是詳細很多的 Script Debugging 的使用說明，從詳細的介面介紹，到如何用這些功能都有說明，值得推薦一看。 另外還有一篇新的則是關於把開發工具導入開發流程內的文件，所以包括一些新功能像是 snippets 的介紹，也有 in place editing ，如何儲存修改過的檔案等。...</b:summary>
				<b:mainContent><p>Google Chrome 開發工具的文件昨天有更新，不確定這整頁是新的還是改寫，不過總之是詳細很多的 Script Debugging 的<a href="https://developers.google.com/chrome-developer-tools/docs/javascript-debugging">使用說明</a>，從詳細的介面介紹，到如何用這些功能都有說明，值得推薦一看。</p>

<p>另外還有一篇新的則是關於把開發工具導入<a href="https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow">開發流程內的文件</a>，所以包括一些新功能像是 snippets 的介紹，也有 in place editing ，如何儲存修改過的檔案等。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000738" baseName="deferred-then">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-05-03</b:date>
				<b:time>20:11:59</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>deferred.then</b:title>
			<b:content>
				<b:summary>前陣子 Bingo 告知才發現，jQuery Deferred 物件的 pipe 在 1.8 被標為 Deprecated 了，以後請改用 then，兩者其實不管回傳值的話，行為還蠻接近的，現在的 pipe 還沒移除掉，不過已經是新版的 then 的 alias 了。看文件的話如果不看下面的敘述，很可能不知道 1.8 前後的差異，雖然回傳的都是 Promise 物件，不過 1.8 之前回傳的是同一個 Promise 物件，1.8 之後回傳的則是新的，和原來 pipe 行為一樣，結果修改過的 Promise 物件。...</b:summary>
				<b:mainContent><p>前陣子 <a href="http://blog.blackbing.net/">Bingo</a> 告知才發現，jQuery Deferred 物件的 <a href="http://api.jquery.com/deferred.pipe/">pipe</a> 在 1.8 被標為 <strong>Deprecated</strong> 了，以後請改用 <a href="http://api.jquery.com/deferred.then/">then</a>，兩者其實不管回傳值的話，行為還蠻接近的，現在的 pipe 還沒移除掉，不過已經是新版的 then 的 alias 了。看文件的話如果不看下面的敘述，很可能不知道 1.8 前後的差異，雖然回傳的都是 Promise 物件，不過 1.8 之前回傳的是同一個 Promise 物件，1.8 之後回傳的則是新的，和原來 pipe 行為一樣，結果修改過的 Promise 物件。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000734" baseName="functional-underscorejs">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-04-21</b:date>
				<b:time>00:01:42</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Functional Programming using underscore.js</b:title>
			<b:content>
				<b:summary>昨天在 OSDC 的演講投影片~ /* A_A */...</b:summary>
				<b:mainContent><p>昨天在 OSDC 的演講投影片~</p>

<p>
<script async="async" class="speakerdeck-embed" data-id="26d284708c000130b42a22000a9d071a" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000714" baseName="device-pixel-ratio">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2012-10-28</b:date>
				<b:time>22:42:31</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Device Pixel Ratio</b:title>
			<b:content>
				<b:summary> 這兩天又對 blog 做了一些加強，主要是處理 Device Pixel Ratio 和 OpenGraph Protocol 及 Twitter Card 的支援，這篇當然主要是要說 Device Pixel Ratio，這東西是隨著 Apple Device 的 Retina Display 上市後才有的，Retina Display 有著原來的四倍的點數，長寬的 DPI 都是原來的兩倍，但是網頁瀏覽不可能會是直接讓瀏覽器的 window size 變成兩倍寬，這樣的話字會小到難以閱讀，因此有了 Device Pixel Ratio 這樣的設計出現，以橫置的 iPad with Retina Display 為例，window 的...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/8128174518/" title="Flickr 上 othree 的 2x compare to 1x"><img src="//farm9.staticflickr.com/8463/8128174518_387a27b3dd.jpg" width="500" height="333" alt="2x compare to 1x"/></a></p>

<p>這兩天又對 blog 做了一些加強，主要是處理 Device Pixel Ratio 和 OpenGraph Protocol 及 Twitter Card 的支援，這篇當然主要是要說 Device Pixel Ratio，這東西是隨著 Apple Device 的 Retina Display 上市後才有的，Retina Display 有著原來的四倍的點數，長寬的 DPI 都是原來的兩倍，但是網頁瀏覽不可能會是直接讓瀏覽器的 window size 變成兩倍寬，這樣的話字會小到難以閱讀，因此有了 Device Pixel Ratio 這樣的設計出現，以橫置的 iPad with Retina Display 為例，window 的 width 是 1024px，而其實際的螢幕點數有 2048 點，除上 Device Pixel Ratio 是 2，結果會剛好回到 1024，對於網頁製作上來說，直接當程式 1024px 寬的畫面來處理基本上就沒問題了。</p>

<p>雖然說好像瀏覽器都幫你把東西解決了，不過其實還會有一個問題需要處理，那就是圖片 asset 的問題，原來的圖片在這些高 DPI 的螢幕上顯示，解析度不夠，結果都會有鉅齒出現，而這裡出現的就是 Device Pixel Ratio 了，要得到 Device Pixel Ratio 的方法目前有兩種，一個是 CSS 用 <a href="https://developer.mozilla.org/en-US/docs/CSS/Media_queries#-moz-device-pixel-ratio">media query</a>：</p>

<pre><code>@media (-webkit-min-device-pixel-ratio: 2),
       (min--moz-device-pixel-ratio: 2),
       (min-resolution: 2dppx)
</code></pre>

<p>這個 <a href="https://developer.mozilla.org/en-US/docs/CSS/Media_queries#-moz-device-pixel-ratio">MDN 提供的範例</a>中，共有三行，第一行是 WebKit Based 瀏覽器用的，像是 iOS 內建的瀏覽器就是用這行，第二行則是給比較舊的 Firefox （&lt; 16）用的，第三行則是 <a href="http://www.w3.org/TR/css3-mediaqueries/#resolution">W3C 提出的標準</a>，W3C 的應該還是會是以後的主流，dppx 代表的是 dots per pixel，除了這個單位外其實還可以用 dpi, dpcm 等密度單位，考量的比較全面，CSS 那邊管的圖片像是元件背景之類的，透過這個 media query 就可以順利的在需要的時候換成不同品質的圖片，另外還有一種圖片來源是動態從 JavaScript 那邊插入的，這目前也有個方法可以支援：</p>

<pre><code>window.devicePixelRatio
</code></pre>

<p>直接讀取這個值就可以知道現在的 device pixel ratio 了，然後根據讀到的值來選擇適當的圖片，不過講到網頁的圖片，其實最先應該想到的是 img 標籤才是，偏偏這兩個方法都不直接適用，而且實際上目前也還沒有針對這個問題，可直接使用的新機制，有人有寫 jQuery plugin 來把圖片換掉，我的作法則是第一次瀏覽不管，不過同時就把 device pixel ratio 數值寫進 cookie，這樣下次使用者來訪，或是他點到其他頁時，server 端就可以知道他用的 device pixel ratio，然後先一步把 img 要丟出的圖片網址處理好，以 flickr 的圖片為例，我平常貼的都是 500px 寬的縮圖，要給 ratio 2 的裝置看則需要 1000px 以上，flickr 最大的縮圖是 1024px，剛好很接近 1000px，又很幸運的兩者檔案路徑只有在檔名最後面差一個 _b ，所以我就很開心的拿來用了，在 XSLT parse 時把 img 標籤，src 是 flickrfarm 來的，檔名結尾不是 _o 的（代表原始檔）的圖片路徑都加上 _b ，結果的差異就是上面第一張圖那樣，其他還抓了不少比較圖，不過都要到 flickr 那去開原始檔比較才看得出差異。</p>

<p><figure class="thumbnail">
<a href="http://www.flickr.com/photos/othree/8128147819/" title="Flickr 上 othree 的 2x compare to 1x"><img src="//farm9.staticflickr.com/8043/8128147819_45f5f33352.jpg" width="500" height="333" alt="2x compare to 1x"/></a>
<figcaption>比較圖原始大小</figcaption>
</figure></p>

<p><figure class="thumbnail">
<a href="http://www.flickr.com/photos/othree/8127784377/" title="Flickr 上 othree 的 Support device pixel ratio 2x"><img src="//farm9.staticflickr.com/8052/8127784377_5db2831fb7.jpg" width="375" height="500" alt="Support device pixel ratio 2x"/></a>
<figcaption>2x 圖片</figcaption>
</figure></p>

<p><figure class="thumbnail">
<a href="http://www.flickr.com/photos/othree/8127811546/" title="Flickr 上 othree 的 Not support device pixel ratio 2x"><img src="//farm9.staticflickr.com/8336/8127811546_4e62af122b.jpg" width="375" height="500" alt="Not support device pixel ratio 2x"/></a>
<figcaption>1x 圖片</figcaption>
</figure></p>

<p>這支寫 device pixel ratio cookie 的程式很簡單，我也放上 github 了，就叫 <a href="https://github.com/othree/dpr-cookie">dpr-cookie</a>，完全 stand alone，不需要其他 Library，有需要的歡迎使用，還沒放上 License 宣告，不過會用 MIT License。</p>

<p>最後提一下 img 標籤的問題，WHATWG 目前是有<a href="http://www.w3.org/community/respimg/2012/05/11/respimg-proposal/">候選方案</a>的，不過我覺得各方意見還很多，要有個定案應該不會太快，看起來會像是這樣：</p>

<pre><code>&lt;img src="face-600-200@1.jpg" alt=""
    set="face-600-200@1.jpg 600w 200h 1x, face-600-200@2.jpg 600w 200h 2x, face-icon.png 200w 200h"&gt;
</code></pre>

<p>或是：</p>

<pre><code>&lt;picture alt=""&gt;
    &lt;source src="mobile.jpg" /&gt;
    &lt;source src="large.jpg" media="min-width: 600px" /&gt;
    &lt;source src="large_1.5x-res.jpg" media="min-width: 600px, min-device-pixel-ratio: 1.5" /&gt;
    &lt;img src="mobile.jpg" /&gt;
&lt;/picture&gt;
</code></pre>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="2"></b:comments>


		</b:entry>

	</b:entries>
</b:blog>
