<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>c</b:listType>
			<b:listData listID="script">script</b:listData>
		</b:entriesMeta>

		<b:entry entryID="000775" baseName="angularjs-data-binding">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-12-05</b:date>
				<b:time>10:26:51</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>AngularJS Data Binding 機制</b:title>
			<b:content>
				<b:summary>一開始沒特別注意，前陣子看 PolymerJS 的時候才發現 AngularJS 的 data binding 是只要改 POJSO(Plain Old JavaScript Object) 的值，然後魔法就發生了，如果有寫 JS 應該都了解，目前其實沒辦法偵測某個物件的屬性是否被更改，所以 AngularJS 到底怎麼辦到的就引起我的興趣了，以下內容如有錯誤還請告知，畢竟我還沒有 AngularJS 開發經驗，可能有誤解。 結果又是在 StackOverflow 找到重要的參考資料，說到 $digest 和 $apply 這兩個 method，$apply 最主要是給外部的程式來用（還有 AngularJS 內部），如果是外部的程式改動你 scope 內的值，那還要順便執行 $apply() ，然後 $apply 會去執行 angular expression，然後接著執行 $digest 檢查資料變化並讓對應的變化發生。所以...</b:summary>
				<b:mainContent><p>一開始沒特別注意，前陣子看 PolymerJS 的時候才發現 AngularJS 的 data binding 是只要改 POJSO(Plain Old JavaScript Object) 的值，然後魔法就發生了，如果有寫 JS 應該都了解，目前其實沒辦法偵測某個物件的屬性是否被更改，所以 AngularJS 到底怎麼辦到的就引起我的興趣了，以下內容如有錯誤還請告知，畢竟我還沒有 AngularJS 開發經驗，可能有誤解。</p>

<p>結果又是在 StackOverflow 找到重要的<a href="http://stackoverflow.com/questions/9682092/databinding-in-angularjs">參考資料</a>，說到 <code>$digest</code> 和 <code>$apply</code> 這兩個 method，<code>$apply</code> 最主要是給外部的程式來用（還有 AngularJS 內部），如果是外部的程式改動你 scope 內的值，那還要順便執行 <code>$apply()</code> ，然後 <code>$apply</code> 會去執行 <a href="http://docs.angularjs.org/guide/expression">angular expression</a>，然後接著執行 <code>$digest</code> 檢查資料變化並讓對應的變化發生。所以 AngularJS 的 data binding 作法實際上是，AngularJS Framework 內的 controller function 有經手過的 scope，它會自己接在 function 的後面執行 <code>$apply()</code> 來套用變動，算是一種 dirty check，不過是檢查的很乾淨。</p>

<p>另外還剛好看到今年 <a href="2013.jsconf.eu/">JSConf EU</a> 有一場 <a href="http://2013.jsconf.eu/speakers/marius-gundersen-a-comparison-of-the-twoway-binding-in-angularjs-emberjs-and-knockoutjs.html">A comparison of the two-way binding in AngularJS, EmberJS and KnockoutJS</a> 的演講，不長，二十分而已內容也很不錯，推薦花點時間看看：</p>

<iframe width="420" height="315" src="//www.youtube.com/embed/mVjpwia1YN4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>講者 Marius Gundersen 比較了 AngularJS、EmberJS 和 KnockoutJS 三套 framework 的 data binding 機制，結果是各有優缺點，在最後的問與答也說到現在制定中的 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe">Object.observer</a> 的 JavaScript 未來新功能，等到這功能正式可以用時，就可以解決現在這些實作大部分的問題。</p>

<p>還有一篇文章 <a href="http://blog.bguiz.com/post/57373805814/accessors-vs-dirty-checking-in-javascript-frameworks">Accessors vs Dirty-checking in Javascript Frameworks</a> 有蠻深入的比較現在不同 data binding 實作的特性，就如標題是 Dirty-checking 和 Accessor 兩類實作為主，Accessor 的實作其實就是像 Backbone 那樣，要修改 model 的屬性要用他的 <code>set()</code> 方法來作，才能順便觸發後面的動作。</p>

<p>最後文章寫完才看到 AngularJS 社群第四次聚會 Ticore 已經講過這個主題了，<a href="http://www.slideshare.net/ticore/angularjs-data-binding">投影片</a>內容也還蠻深入的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000770" baseName="web_component">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-11-27</b:date>
				<b:time>19:35:38</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Web Component</b:title>
			<b:content>
				<b:summary>最近覺得可以開始玩 Web Component 了，然後就開始研究，本來以為應該會是個簡單的東西，結果意外的有一些細節還蠻複雜，有些設計目前也不知道為什麼，不過還是從基本的來開始整理吧。 Web Component 其實最早只有 Shaodw DOM 的概念，不過現在已經變成好幾個標準合在一起來構成 component 了，這些標準中，最主要的三個分別是： Shadow DOM Custom Element HTML Imports 這三者分別都是構成 Web Component 很重要的元素，不過也分別規範了一些不是單純只能應用在 Web Component 上的功能，這篇文章不一定會說到這些特色，一切都看緣份吧～...</b:summary>
				<b:mainContent><p>最近覺得可以開始玩 Web Component 了，然後就開始研究，本來以為應該會是個簡單的東西，結果意外的有一些細節還蠻複雜，有些設計目前也不知道為什麼，不過還是從基本的來開始整理吧。</p>

<p>Web Component 其實最早只有 Shaodw DOM 的概念，不過現在已經變成好幾個標準合在一起來構成 component 了，這些標準中，最主要的三個分別是：</p>

<ul>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a></li>
<li><a href="http://www.w3.org/TR/custom-elements/">Custom Element</a></li>
<li><a href="http://www.w3.org/TR/html-imports/">HTML Imports</a></li>
</ul>

<p>這三者分別都是構成 Web Component 很重要的元素，不過也分別規範了一些不是單純只能應用在 Web Component 上的功能，這篇文章不一定會說到這些特色，一切都看緣份吧～</p>
</b:mainContent>
				<b:extendContent><h4>Shadow DOM</h4>

<p>我所知當中這是最早被提出的部分，這份文件的目的在提出一套標準來在文件樹上把一些 DOM 節點隱藏起來，有這個需求的原因是因為現在越來越多的自訂 UI 元件，為了達成效果可能用了很多的 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 等元素，但是在做 DOM Traversal 或是 Inspect 時，這些元素的出現其實很多餘，而且看起來會很花，如果是開發要除錯看到大量不相干的東西實在是很干擾，而最重要的其實是，如果要把能讓這些自訂元件模組化再利用，那應該也要能把東西封裝起來。</p>

<p>Shadow DOM 最大的功用就是在 DOM Tree 上能把子文件樹封裝起來的機制，使用很簡單，就在你想要放隱藏元件結構的地方，執行 <code>createShadowHost()</code>，然後把東西塞進去就可以了：</p>

<pre><code>var host = document.querySelector('.custom-component');
var root = host.createShadowRoot();
host.innerHTML = html_template_string;
</code></pre>

<p>目前應該還只有 Chrome 支援，而且要先去 <code>about:flags</code> 裡面把「Experimental Web Platform features」打開，然後標準還沒定案，所以其實現在要執行 <code>webkitCreateShadowRoot</code> 才會動。這個 function 回傳的東西稱為 <em>shadow root</em>，它下面的文件樹就稱為 <em>shadow tree</em>，至於 <code>host</code> 那個變數所指的 DOM node 則是 <em>shadow host</em>。</p>

<p>簡單說的 Shadow DOM 就這樣講完了，不過事情當然不會這麼簡單，還有幾個問題要解決，首先第一個是 style，要給 shadow tree 內的元素加上樣式其實就把 style 標籤也插進去就可以了：</p>

<pre><code>var html_template_string = 
    '&lt;style&gt;div { color: red; }&lt;/style&gt;&lt;div&gt;Click me!&lt;/div&gt;';
</code></pre>

<p>預設這種在 shadow tree 裡面的 style 都是 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#attr-style-scoped">scoped</a> 的，是從 host 節點開始算，所以包括 host 節點本身也會受到影響，而在這邊，一個新的 CSS at-rule <code>@host</code> 就誕生了，是專門從 shadow tree 裡面來對外面的 host 節點的樣式做調整用的：</p>

<pre><code>@host {
    .custom-component {
        display: inline-block;
    }
}
</code></pre>

<p>第二個問題則是，如果我要做的 custom element 是下拉式選單時，我的選項哪裡來呢？當然我可以直接把東西用 JS 寫到 shadow tree 裡面，但是如果是用以前的 <code>&lt;select&gt;</code> 的話，是用 <code>&lt;select&gt;</code> 下的子節點作為選項的來源。：</p>

<pre><code>&lt;select&gt;
    &lt;option value="1"&gt; 1
    &lt;option value="2"&gt; 2
    &lt;option value="3"&gt; 3
&lt;/select&gt;
</code></pre>

<p>如果要用 shadow DOM 做到類似的效果，把複雜的 UI 呈現用結構藏起來，只讓單純的選項出現在文件樹內，也是可以辦到的，不過比較複雜，這個特性叫 distribution，配合一個新的標籤 <code>&lt;content&gt;</code> 和 CSS selector 來把 shadow host 的子元素移動到 shadow tree 內。</p>

<p>舉例來說，下面是我的 shadow host 節點：</p>

<pre><code>&lt;div class="x-header"&gt;
    &lt;h1&gt;Site Name&lt;/h1&gt;
    &lt;h2&gt;Section 1&lt;/h2&gt;
    &lt;h2&gt;Section 2&lt;/h2&gt;
    &lt;h2&gt;Section 3&lt;/h2&gt;
&lt;/div&gt;
</code></pre>

<p>除了他自己外還有一個大標題，三個小標題。然後我希望丟進 shadow root 的結構如下：</p>

<pre><code>&lt;header&gt;
   &lt;img src="logo.png" /&gt;
   &lt;h1&gt;Site Name&lt;/h1&gt;
&lt;/header&gt;
&lt;nav&gt;
    &lt;div class="wrapper"&gt;
        &lt;h2&gt;Section 1&lt;/h2&gt;
        &lt;h2&gt;Section 2&lt;/h2&gt;
        &lt;h2&gt;Section 3&lt;/h2&gt;
    &lt;/div&gt;
&lt;/nav&gt;
</code></pre>

<p>那麼我可以用 <code>&lt;content&gt;</code> 來辦到：</p>

<pre><code>&lt;header&gt;
   &lt;img src="logo.png" /&gt;
   &lt;content select="h1"&gt;
&lt;/header&gt;
&lt;nav&gt;
    &lt;div class="wrapper"&gt;
        &lt;content select="h2"&gt;
    &lt;/div&gt;
&lt;/nav&gt;
</code></pre>

<p><code>select</code> 屬性的內容是 CSS selector，可以把符合該 selector 的 shadow host 子節點抓出來放在 <code>&lt;content&gt;</code> 的位置。如果不給任何 selector 的話，就會把全部的東西都抓過去，像下拉選單就可以用這種方式來把選項填入 shadow tree。</p>

<p>不過這邊要注意，distributed 的 DOM node 吃的樣式是外面的文件的樣式，shadow tree 裡面的 style 不會套用到他們上面。</p>

<p>第三個問題是，用 JS 字串或是動態產生 DOM 節點的方式來作 shadow DOM 的內容實在很多問題，所以 HTML 還多了個 <a href="https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html">Templates</a> 擴充，就是多了一個眾望所歸的 <code>&lt;template&gt;</code> 標籤，內容會 parse，會有內容的 DOM tree，但是不 render，所以裡面需要的圖片、JS 等等都不會抓下來，然後 template 標籤的 <code>content</code> 屬性就是內容的 DOM node，所以第一段程式碼範例就可以改寫成：</p>

<pre><code>var host = document.querySelector('.custom-component');
var root = host.createShadowRoot();
var clone = templateNode.content.cloneNode(true);
root.appendChild(clone);
</code></pre>

<p>以前比較常見的作法是用 <code>&lt;script&gt;</code> 標籤，然後說 type 是某個瀏覽器不認得的語言，像是 "text/template" 之類的，這樣瀏覽器就不會去執行內容，不過這方法的缺點一就是語意不對，二是潛藏有安全性問題。</p>

<h4>Custom Element</h4>

<p>Custom Element 的部分就是定義了怎樣在 document 下定義新的自訂標籤，不是以前剛進入 HTML5 時代時為了語意而產生的新標籤，這邊說的自訂標籤通常都是為了有特殊的用途，會能和使用者有互動，可以操控等特性的，只用 shadow DOM 的話，雖然可以把整個元件封裝起來，但是最外層還是用 div 標籤來把東西包起來，在語意上不太合，而且加上可能有非同步的問題，新標籤可能是動態插入文件樹內，傳統的方法並不方便處理這種狀況。</p>

<p>在繼續之前要先說，網路上還可以看到一些比較舊的文章有介紹 <code>&lt;element&gt;</code> 這個標籤，不過該標籤目前已經被廢棄了，custom element 現在是全由 JavaScript 那邊來和 document 作溝通，所以基本上就是定義了一組 document 的擴充 API，<em>register</em>：</p>

<pre><code>document.register('x-button', {prototype: xButtonProto});
</code></pre>

<p>這樣在這個文件樹下，就有了 <code>&lt;x-button&gt;</code> 這個新的標籤，其中標籤的命名方式是有建議一定要有個 '-' 的，有 '-' 的標籤，在有定義之前，會被認為是 unresolved element，可以用新的 CSS pseudo class <code>:unresolved</code> 來隱藏起來，避免類似 FOUT 的現象，但是如果你沒有 '-' 而只是用了簡單的單詞來作自訂標籤的名稱，像是 slider、calendar 之類的，這樣就會被認為是 unknown element，就沒辦法用 <code>:unresolved</code> 了。</p>

<p>第二個參數則是 option object，其中的 prototype 則是定義了關於這個新的自訂標籤的行為，通常會從 HTMLElement 繼承來：</p>

<pre><code>var xButtonProto = Object.create(HTMLElement.prototype);
</code></pre>

<p>然後接著定義它的 <a href="http://w3c.github.io/webcomponents/spec/custom/#custom-element-lifecycle">lifecycle</a> callback function，lifecycle 這是個新的東西，在 custom element 的標準裡面定義了一個標籤的一生會發生的事情，包括：</p>

<ul>
<li>created</li>
<li>enteredView</li>
<li>leftView</li>
<li>attributeChanged</li>
</ul>

<p>最常會用到的大概就是 created 了吧：</p>

<pre><code>xButtonProto.createdCallback = function () {
    var root = this;
    var host = this.webkitCreateShadowRoot();
    var clone = tpl.content.cloneNode(true);
    host.appendChild(clone);
};
</code></pre>

<p>像這樣定義 lifecycle callback，就會在 <code>&lt;x-button&gt;</code> 插入文件時，把他裡面的 shadow tree 建好，同時你也可以把一些事件和行為也在這個時間點建立起來。要拿到 shadow tree 裡面的元素的話，可以直接對 shadow host 下 query selector 指令來達成。</p>

<p>目前 WebKit 雖然有支援 custom element，不過也還是實驗中的狀態，要自己去把 'Experimental Web Platform features' 選項打開。</p>

<h4>HTML Imports</h4>

<p>HTML Imports 雖然是比較晚期才聽到有成形的標準，不過其實很早之前，在 Web Component 的概念成形之前，就已經有很多地方有類似的，引用外部資源需求了，所以標準的設計也沒有局現在 Web Component 的使用，結果而言，在 Web Component 這塊，import 的功能是讓 Web Component 的程式碼能夠在維護、發布時也能模組化、封裝起來的關鍵標準，但是他的設計方向卻不是以此為中心，HTML Imports 設計上市 link 標籤的一個擴充：</p>

<pre><code>&lt;link rel="import" href="component.html" /&gt;
</code></pre>

<p>結果就是，有支援 HTML Imports 的瀏覽器就會把 component.html 抓下來也 parse 過，正常網頁該抓的圖片、script，該跑的 script 也都會真的執行，而且在該檔案內的 script 執行環境的 document 和外面的 document 是同一個。所以理論上，只要把所有的 custom element 相關的東西移到獨立的檔案，然後在 import 進來就好了，這樣就可以保持主文件內容的乾淨，也可以讓這些自訂的標籤能夠獨立管理，方便維護。</p>

<p>不過這邊有個細節需要注意，就是要怎麼在被 import 的 component.html 裡面的 script 中，去 query component.html 的內容呢？例如我要 query template 出來塞到 shadow tree 裡面，那就要用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.currentScript">currentScript</a> 這個 HTML5 的 API：</p>

<pre><code>var doc = document.currentScript.ownerDocument;
var tpl = doc.getElementById('x-button-template');
</code></pre>

<p>這個寫法在非 import 的 HTML 文件中也是可以動的，所以即使沒有要用 HTML Imports 也可以直接用這個寫法，而 currentScript 的出現其實一部分原因是為了大量的第三方 widget 吧，像是 Facebook like button 之類的，它會給的通常是一個 script 標籤，然後我們把他放到想放的位置，script 再用 document.write 寫入 widget 元素，不過 document.write 不支援 async 的操作，還會有效能 issue，然而 currentScript 會指到現在這行程式碼所在的 <code>&lt;script&gt;</code>，就可以非同步的用標準的 DOM 操作而不需要 document.write 也可以把東西放到正確的位置，這樣就可以解決很多這種第三方 script 插入元素的定位問題。</p>

<p>到這邊就可以把上面的東西全部接在一起了，目錄下會有以下檔案：</p>

<ul>
<li>index.html</li>
<li>x-button/x-button.html</li>
<li>x-button/x-button-style.css</li>
<li>x-button/x-button-script.js</li>
</ul>

<p>x-button.html 的內容：</p>

<pre><code>&lt;template id="x-button-template"&gt;
    &lt;style&gt;
        @import 'x-button/x-button-style.css';
    &lt;/style&gt;

    &lt;div class="x-button"&gt;
        &lt;i class="icon"&gt;&lt;/i&gt;
        &lt;div class="content"&gt;&lt;content&gt;&lt;/div&gt;
    &lt;/div&gt;

&lt;/template&gt;

&lt;script src="x-button-script.js"&gt;&lt;/script&gt;
</code></pre>

<p>CSS 跳過，js 的內容：</p>

<pre><code>var doc = document.currentScript.ownerDocument;
var tpl = doc.getElementById('x-button-template');
var xButtonProto = Object.create(HTMLElement.prototype);

xButtonProto.createdCallback = function () {
    var root = this;
    var host = this.webkitCreateShadowRoot();
    var clone = tpl.content.cloneNode(true);
    host.appendChild(clone);
};

document.register('x-button', {prototype: xButtonProto});
</code></pre>

<p>最後 html 的內容：</p>

<pre><code>&lt;link rel="import" href="x-button/x-button.html"&gt;

&lt;x-button&gt;Super Button&lt;/x-button&gt;
</code></pre>

<h4>Library</h4>

<p>瀏覽器的實作，目前是 Chrome 最完整，不過都還在測試，要自己去把功能打開，其中 HTML Imports 比較新，Firefox 也還不支援，不過想要用的話還是可以透過兩套 JavaScript Library 來用，一個是 Google 的 Polymer，另外一套是 Mozilla 的 <a href="http://www.x-tags.org/">&lt;x-tags&gt;</a>，Mozilla 的比較單純，就是可以方便定義 Custom Element 的一套 Library，看上面的介紹可以知道要定義一個 custom element 有很多地方要處理，x-tags 則是另外定義了一套 API 來把東西都集中起來，順便也把 custom element 登錄到文件內，另外也開了一個 repository 來收集大家做的 custom element，至於底層的部份，其實是用 Polymer 的 polyfill - platform.js。</p>

<p>Polymer 這套涵蓋的範圍就比較大了，首先它為了讓 Web Component 的相關新標準可以在現在的主流瀏覽器上動，它把這些標準的 polyfill 的做好了，接著基於這些標準做了 polymer-element 和 data binding 機制等核心的功能，然後開發者就可以用這些東西建構自己想要的 custom component，當然它也提供一些常用的 cusotm element，拼裝起來就可以把 application 建構出來。</p>

<p>Polymer 其實除了上面說的三個標準外，還做了好幾個 polyfill，包括 Web Animations、Pointer Event 以及目前沒有在標準內的 binding 機制我覺得終極目標應該是會和 AngularJS 相輔相成，畢竟現在 AngularJS 的 directive 機制就有點像是 Web Component + data binding 的組合。</p>

<h4>Summary</h4>

<p>其實 Web Component 真的是越看越覺得細節很多，這篇文章其實還是有不少沒提到的細節，不過大部分都可以在參考文獻中找到，有很多東西其實都還在進行中，文件不完整，找的到的範例也太過單純，不過相信資源會越來越完整，目前看起來 Web Component 的潮流遲早會成為主流，加上 Google 還把這麼多標準的 polyfill 都做好了，AngularJS 也把 component 的模式在開發者之間帶起來，我想整個潮流只會越來越快。</p>

<h4>Reference</h4>

<p>最後整理一下參考資料，有不少細節和一些相關的東西這篇文章還沒有講，之後有機會在分享吧。首先是 w3c 的 editor draft，包含三份 spec 還有一篇 <a href="http://w3c.github.io/webcomponents/explainer/">intro</a>：</p>

<ul>
<li><a href="http://w3c.github.io/webcomponents/">Web Component Editor Draft</a></li>
<li><a href="http://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM Editor Draft</a></li>
<li><a href="http://w3c.github.io/webcomponents/spec/custom/">Custom Element Editor Draft</a></li>
<li><a href="http://w3c.github.io/webcomponents/spec/imports/">HTML Imports Editor Draft</a></li>
</ul>

<p>Specs：</p>

<ul>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a></li>
<li><a href="http://www.w3.org/TR/custom-elements/">Custom Element</a></li>
<li><a href="http://www.w3.org/TR/html-imports/">HTML Imports</a></li>
<li><a href="http://www.w3.org/TR/pointerevents/">Pointer Events</a></li>
<li><a href="http://www.w3.org/TR/web-animations/">Web Animations</a></li>
</ul>

<p>然後 HTML5 Rocks 有好幾篇文章：</p>

<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/customelements/">Custom Element</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/">HTML Imports</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">Template</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">Shadow DOM 201</a>，特別要注意現在 pseudo 屬性已經沒了，改成 part 了。</li>
<li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-301/">Shadow DOM 301</a></li>
</ul>

<p>看到各主題的篇數就知道什麼東西比較複雜了，還有一些其他地方的介紹文章：</p>

<ul>
<li><a href="http://css-tricks.com/modular-future-web-components/">Modular Future Web Components</a></li>
<li><a href="http://html5-demos.appspot.com/static/webcomponents/index.html">&lt;web&gt;components&lt;/web&gt;</a></li>
<li><a href="http://robdodson.me/blog/2013/08/20/exploring-html-imports/">Exploring HTML Imports</a></li>
</ul>

<p>一個 Web Component 的 <a href="http://jonrimmer.github.io/are-we-componentized-yet/">支援度檢查表</a> 和 shadow DOM <a href="http://html5-demos.appspot.com/static/shadowdom-visualizer/index.html">視覺化工具</a>。Google 推廣還算蠻用力的，今年的 Google IO 有不少 <a href="https://developers.google.com/events/io/sessions">場次</a> 有相關，還有一個 Google Plus <a href="https://plus.google.com/103330502635338602217/posts">專頁</a>。</p>

<p>Libraries 的就是上面說到的兩個，Google 的 Polymer，建議可以去他的 Github 看看，然後還有 Mozilla 的 x-tags 和 Brick，其中 Brick 沒說到，不過他是基於 x-tag 的專案，要來收集各種 custom element，然後未來可以疊床架屋用的：</p>

<ul>
<li><a href="http://www.polymer-project.org/">Polymer</a></li>
<li><a href="http://www.x-tags.org/">x-tags</a></li>
<li><a href="http://mozilla.github.io/brick/">Brick</a></li>
</ul>
</b:extendContent>
			</b:content>

			<b:comments commentCount="2"></b:comments>


		</b:entry>

		<b:entry entryID="000766" baseName="mobile-web-application-mopcon">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-10-31</b:date>
				<b:time>11:53:16</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Mobile Web Application 甘苦談</b:title>
			<b:content>
				<b:summary>上個週末在 MOPCON 演講的投影片： /*A_A*/...</b:summary>
				<b:mainContent><p>上個週末在 <a href="http://mopcon.org/2013/">MOPCON</a> 演講的投影片：</p>

<script async="async" class="speakerdeck-embed" data-id="0c7d22d02409013107c55e2c4b81d3ea" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/*A_A*/</script>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000763" baseName="javascript-object-you-dont-know">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-09-16</b:date>
				<b:time>20:47:28</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>你所不知道的 JavaScript Object</b:title>
			<b:content>
				<b:summary>以前在寫 VB 時，看到物件有 set/get 可以用，你可以用簡單的存取方式設定或取得物件的某個屬性，但是實際上存取時做一些操作和運算，對物件外來說，就和一般屬性一樣的，當時覺得這個特性還蠻方便的，不過這不是所有程式語言都有的，像是當年的 JavaScript 就沒有，不過時光飛逝，歲月如梭，其實現在 JavaScript 也支援 get/set 了，只是要用 defineProperty 來設定，沒辦法用 Good Part 裡面建議的，單純用 object literal notation，當然比較舊的 IE 也不支援，寫起來如下： var square = { side: 1 }; Object.defineProperty(square, 'area', { get: function () { return Math.pow(this.side, 2); }, set:...</b:summary>
				<b:mainContent><p>以前在寫 VB 時，看到物件有 set/get 可以用，你可以用簡單的存取方式設定或取得物件的某個屬性，但是實際上存取時做一些操作和運算，對物件外來說，就和一般屬性一樣的，當時覺得這個特性還蠻方便的，不過這不是所有程式語言都有的，像是當年的 JavaScript 就沒有，不過時光飛逝，歲月如梭，其實現在 JavaScript 也支援 get/set 了，只是要用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty</a> 來設定，沒辦法用 Good Part 裡面建議的，單純用 object literal notation，當然比較舊的 IE 也不支援，寫起來如下：</p>

<pre><code>var square = {
    side: 1
};

Object.defineProperty(square, 'area', {
    get: function () {
        return Math.pow(this.side, 2);
    },
    set: function (val) {
        this.side = Math.pow(val, 0.5);
    }
});
</code></pre>

<p>不過，defineProperty 的功能可不止於此，它提供了更改更為底層設定的能力，包括 configurable、enumerable 和 writable 三個設定。configurable 表示這個屬性的設定是否可以再次用 defineProperty 更改，writable 比較簡單就是表示這個屬性的值是否可以修改，enumerable 則是設定這個屬性在列舉的時候會不會被列出，物件的列舉其實就是用 <code>for in</code>：</p>

<pre><code>for (attr in obj) {
    obj[attr] = 'foo';
}
</code></pre>

<p>如果有在用 JSLint 可能會看過這樣寫的話都會跳出下面的錯誤訊息：</p>

<blockquote>
  <p>The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype</p>
</blockquote>

<p>這是因為用 <code>for in</code> 的話，會把 prototype 裡面的屬性也列舉出來，這樣會有什麼問題呢，以前在做陣列的新 method 的 polyfill 時，會有個狀況就是，我們手動新增的 method，會在列舉時被列出，所以變成所有的陣列都不能用 <code>for in</code> 來跑，但是現在有 defneProperty 的 enumerable 了，未來在有類似的狀況，可以直接給陣列新增 method 而不會影響 <code>for in</code> 的行為。</p>

<p>除了 defineProperty 之外，還有 defineProperties 可以大量設定屬性，另外也可以在 Object.create 時直接設定好。</p>

<p>第二個要說的是，現在 JavaScript 的物件可以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">封</a>(seal) 起來或是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">凍</a>(freeze) 起來了，seal 做的事情是限制物件屬性的新增或刪除，既有屬性的值還是可以修改，freeze 則是把物件完全凍結住，連修改屬性都不可以。而且這些行為是不可逆的，沒有提供可以 unseal 或是 unfreeze 的方法，不過倒是有 <code>isSealed</code> 和 <code>isFrozen</code> 可以判斷物件狀態。</p>

<p>在 strict mode 下，上面兩個特性有限制的地方在被違反的時候，都會 throw error，普通模式下是不會有錯誤，不過他的行為還是不變，使用時需要注意。</p>

<p>最後要介紹的是還不能使用的 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe">observe</a>，observe 又稱為觀察者，在 Backbone 有利用 set 和事件系統來實做，是在開發應用程式時很有用的 pattern，TC39 有打算把它加進 JavaScript 之中，目前還只有草案就是，要能用應該還要好一陣子就是了。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000753" baseName="phantom-jasmine-and-aladdin">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-07-02</b:date>
				<b:time>00:00:10</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>phantom-jasmine 與阿拉丁</b:title>
			<b:content>
				<b:summary>前陣子開始寫起 JavaScript 的 test，用的是 Jasmine，用瀏覽器跑都正常，只是用 npm 上的 phantom-jasmine 來跑測試結果都不正常。因為想要把專案丟上 Travis CI，所以今天又花了不少時間下去找問題，結果還真是有些意外。 這個問題最大原因就是 npm phantom-jasmine 和原作者的 phantom-jasmine 的是不同 fork，npm module maintainer 是 rlayte，而 phantom-jasmine 作者是 Joshua Carver，雖然 npm 網站上的使用說明和 Joshua 在 Github 上的幾乎都一樣，Joshua 也在 README 說了可以用 npm 裝，但是實際上用 npm install -g...</b:summary>
				<b:mainContent><p>前陣子開始寫起 JavaScript 的 test，用的是 <a href="http://pivotal.github.io/jasmine/">Jasmine</a>，用瀏覽器跑都正常，只是用 npm 上的 <a href="https://npmjs.org/package/phantom-jasmine">phantom-jasmine</a> 來跑測試結果都不正常。因為想要把專案丟上 <a href="https://travis-ci.org/">Travis CI</a>，所以今天又花了不少時間下去找問題，結果還真是有些意外。</p>

<p>這個問題最大原因就是 npm phantom-jasmine 和原作者的 <a href="https://github.com/jcarver989/phantom-jasmine">phantom-jasmine</a> 的是不同 fork，npm module maintainer 是 <a href="https://npmjs.org/~rlayte">rlayte</a>，而 phantom-jasmine 作者是 <a href="https://github.com/jcarver989">Joshua Carver</a>，雖然 npm 網站上的使用說明和 Joshua 在 Github  上的幾乎都一樣，Joshua 也在 <a href="https://github.com/jcarver989/phantom-jasmine#installation">README</a> 說了可以用 npm 裝，但是實際上用 <code>npm install -g phantom-jasmine</code> 裝的卻是 rlayte 的 <a href="https://github.com/rlayte/phantom-jasmine">fork</a>，然而 rlayte 的那版，卻是他改很大的版本，整個行為都已經和說明上寫的不一樣了。</p>

<p>本來的 phantom-jasmine 是使用者丟 HTML 檔案進去，不過 rlayte 改到後來，變成是它會自己去特定的路徑找 js 檔案，丟進 tempalte 產生 html 然後跑測試的，而這個路徑好死不死預設是 <code>exmample/js/**/*.js</code>，雖然測試的 spec 還是預設在 <code>spec/</code> 下找，可是要測試的檔案會在 <code>example/js/</code> 下面找，如果沒有改設定，根本就不會測試到想要測的檔案，這個行為是和原來完全不一樣的，而且也沒寫在文件上。</p>

<p>還好我也有發現，rlayte 其實已經把他的 phantom-jasmine fork 改成 <a href="https://github.com/rlayte/aladdin">aladdin</a> 了，前面講的那些行為該怎樣用，其實都寫在 aladdin 那邊的 README 內。</p>

<p>aladdin 設計的其實蠻無腦的，spec 檔案放在 <code>spec/</code> 目錄下，然後在 spec 目錄下新增一個 config.json：</p>

<pre><code>[ 
  'lib/jquery.js',
  'app/**/*.js'
]
</code></pre>

<p>這個檔案把你要測試的 src 和 dependency 都照順序放好，然後在專案根目錄執行 <code>aladdin</code> 就會開始測試了，連 Jasmine 的檔案都不用自己抓。</p>

<p>要在 Travis CI 上跑測試，只要再加上兩個檔案就可以，一個是 <a href="http://about.travis-ci.org/docs/user/getting-started/#Step-three%3A-Add-.travis.yml-file-to-your-repository">.travis.yml</a>，另外一個是 <a href="https://npmjs.org/doc/json.html">package.json</a>，<code>.travis.yml</code> 只要設成 <a href="http://about.travis-ci.org/docs/user/getting-started/#Node.js">Node.js</a> 的就可以，可以直接拷貝範例，然後內容的 nodejs 版本只留一個。然後再加上 before_script 告訴 Travis CI 要安裝 aladdin：</p>

<pre><code>before_script:
    - npm install -g aladdin
</code></pre>

<p>至於 <code>package.json</code> 就稍微複雜一點，以下是範例：</p>

<pre><code>{
  "name": "robst-video",
  "author": "othree",
  "scripts": {
    "test": "aladdin"
  }
}
</code></pre>

<p>重點是 <strong>scripts</strong> 那一塊，要讓 <code>npm test</code> 執行時會跑 <code>aladdin</code> 來啟動測試。這樣 Travis CI 就可以幫你跑測試了。</p>

<p>回到 phantom-jasmine，現在的狀況是 npm 的 phantom-jasmine 被搞爛了，我必須說 rlayte 搞出這狀況還蠻不負責任的，所以也 report 了個 issue，還好 npm 可以從本地目錄安裝：</p>

<pre><code>sudo npm install -g /path/to/phantom-jasmine/
</code></pre>

<p>只是裝起來後，目前我反而還沒辦法讓原版的 phantom-jasmine 跑起來，可能下次有動力在繼續看問題在哪了吧。 目前我是只有在 <a href="https://github.com/othree/robust-video">robust-video</a> 這個專案跑 Travis CI，有興趣的也可以直接去看看檔案怎樣放。</p>

<p>最後補充一下，不知道有沒有人注意到，迪士尼的阿拉丁電影裡面的公主，就叫做 Jasmine。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="3"></b:comments>


		</b:entry>

		<b:entry entryID="000751" baseName="javascript-primitives-obj">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-30</b:date>
				<b:time>14:24:41</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>JavaScript Primitives Objects</b:title>
			<b:content>
				<b:summary>接續上一篇文章，JavaScript 的資料型別可以分為兩類：基本型別(primitive value)和物件(object)。基本型別包含字串、數值、布林值等，物件除了物件外，還有像是函數、Regular Expression 等。JavaScript 還有一組很特別的 constructor，對應到每種基本型別，所以你可以 new String('blah'); 來產生基本型別的物件： new String('blah'); new Number(42); ner Boolean(true); 如果看最近的書本和教學都會說不要使用這種方法來建立這些基本型別，缺點有效能問題、API 設計不好，會有混淆等等。不過如果是物件的話，不就可以很方便的做一些操作了嗎？ 這兩年很受歡迎的 Ruby 有一個特性就是所有的基本型別都是物件，所以就可以很簡單的用一些串接的方式直接對這些基本型別進行操作： str = 'hello' str.capitalize # Hello str.capitalize! str # Hello str.count('l') # 2 在 JavaScript 中的基本型別其實不需要以物件的形式，也可以做類似的操作： var str =...</b:summary>
				<b:mainContent><p>接續上一篇文章，JavaScript 的資料型別可以分為兩類：基本型別(primitive value)和物件(object)。基本型別包含字串、數值、布林值等，物件除了物件外，還有像是函數、Regular Expression 等。JavaScript 還有一組很特別的 constructor，對應到每種基本型別，所以你可以 <code>new String('blah');</code> 來產生基本型別的物件：</p>

<pre><code>new String('blah');
new Number(42);
ner Boolean(true);
</code></pre>

<p>如果看最近的書本和教學都會說不要使用這種方法來建立這些基本型別，缺點有效能問題、API 設計不好，會有混淆等等。不過如果是物件的話，不就可以很方便的做一些操作了嗎？</p>

<p>這兩年很受歡迎的 Ruby 有一個特性就是所有的基本型別都是物件，所以就可以很簡單的用一些串接的方式直接對這些基本型別進行操作：</p>

<pre><code>str = 'hello'
str.capitalize        #  Hello
str.capitalize!
str                   #  Hello
str.count('l')        #  2
</code></pre>

<p>在 JavaScript 中的基本型別其實不需要以物件的形式，也可以做類似的操作：</p>

<pre><code>var str = 'hello';
str.length;           // 2
str.contains('l');    // true
str.indexOf('l');     // 2
</code></pre>

<p>但是如果想要更進一步的在上面加上屬性或是 method 就會發現行不通：</p>

<pre><code>var str = 'hello';
str.target = 'world';
str.target;            // undefined
</code></pre>

<p>這中間到底是有什麼差異呢？這個問題我想了很久，直到看了 <a href="http://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/">The Secret Life of JavaScript Primitives</a> 這篇文章才瞭解，最後面這個例子，其實等同於：</p>

<pre><code>var str = 'hello';
(new String(str)).target = 'world';
(new String(str)).target;
</code></pre>

<p>當使用物件形式的 <code>.</code> 運算子對基本型別資料操作的時候，會產生一個新的物件，然後用完就丟掉，所以在指派 target 屬性那行操作到的物件，和要取回 target 屬性那行的物件，是完全不一樣的兩個物件，這也就是為什麼這些資料可以用類似物件的方法操作，但是卻不能真的像物件一樣使用。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000750" baseName="javascript-is-untyped">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-30</b:date>
				<b:time>00:08:06</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>JavaScript is Untyped</b:title>
			<b:content>
				<b:summary> 上週去聽 Gias Kay Lee 講 Animation in AngularJS，說到 JavaScript 其實是 untyped language，因為我沒受過 Computer Science 的正統教育，這名詞對我來說是新的，所以回來花了些時間看網路上的文件。 Wikipedia 上的文章不少，不過看起來比較吃力，Stack Overflow 上也有幾則不錯的問答，對我來說幫助很大，這個問題其實也沒很複雜，在 Computer Science 上來說，是不使用 strong type 和 weak type 來形容程式語言的，因為沒有明確的定義，取而代之的，是數個有明確定義的相關特性：type safety、memory safety、static/dynamic type checking、type conversions。 所以我之前 文章 說到 JavaScript 是 weak...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/9167965602/" title="Flickr 上 othree 的 untyped"><img src="//farm6.staticflickr.com/5328/9167965602_d9be012d23_b.jpg" width="674" height="382" alt="untyped" srcset="//farm6.staticflickr.com/5328/9167965602_d9be012d23.jpg 768w, //farm6.staticflickr.com/5328/9167965602_d9be012d23_b.jpg 768w 2x" /></a></p>

<p>上週去聽 <a href="https://twitter.com/gsklee">Gias Kay Lee</a> 講 <a href="http://slid.es/gsklee/animation-in-angularjs">Animation in AngularJS</a>，說到 JavaScript 其實是 <a href="http://en.wikipedia.org/wiki/Talk%3ATyped_and_untyped_languages#.22Untyped_Language.22">untyped language</a>，因為我沒受過 Computer Science 的正統教育，這名詞對我來說是新的，所以回來花了些時間看網路上的文件。</p>

<p>Wikipedia 上的文章不少，不過看起來比較吃力，Stack Overflow 上也有幾則不錯的<a href="http://stackoverflow.com/questions/964910/is-javascript-an-untyped-language">問答</a>，對我來說幫助很大，這個問題其實也沒很複雜，在 Computer Science 上來說，是不使用 strong type 和 weak type 來形容程式語言的，因為沒有明確的定義，取而代之的，是數個有明確定義的相關特性：type safety、memory safety、static/dynamic type checking、type conversions。</p>

<p>所以我之前 <a href="https://blog.othree.net/log/2013/06/01/dependency-injection-of-angularjs/">文章</a> 說到 JavaScript 是 weak type 那段其實應該要說是 untyped 會比較好。其實講到 type 的問題，就會想到 JavaScript 的效能問題，Brendan Eich 說過 JavaScript 引擎很難跑得快的原因就是因為它是 untyped 的。在 <a href="http://www.html5rocks.com/en/tutorials/speed/v8/">Performance Tips for JavaScript in V8</a> 這篇文章有提到，V8 引擎其中有一個提升速度的設計是給變數 hidden class，這個 hidden class 其實就是隱藏的變數型別，如果你的變數從頭到尾都維持同樣的型別，例如整數永遠是整數、字串永遠是字串，而不會有中間換型別的情形，那 V8 引擎就可以利用 hidden class 的資訊來提升運算速度，我覺得這個 tip 很不錯，不只是 V8 可以跑比較快，即使其他引擎沒有受益，作為寫程式時的 good practice 也很受用，減少了程式內的不可預期性。</p>

<p>另外一個我覺得很相似的例子是這兩年新的 <a href="http://asmjs.org/spec/latest/">asm.js</a>，asm.js 是一個 JavaScript 的子集，設計上可以直接做一些比較低階的操作，像是直接 allocate 記憶體還有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">Typed Array</a> 等，而其中還定義了一組相容於普通 JavaScript 的寫法來宣告變數的型別：</p>

<pre><code>function f(x, y) {
    x = x|0;      // int parameter
    y = +y;       // double parameter

    return;
}
</code></pre>

<p>只是 asm.js 會直接手寫的應該很少，像 asm.js 有名的例子： Unreal Engine 就是用工具 compile 過去的。</p>

<p>PS: 我還找不到上面那張圖片的投影片出處，有人知道的話麻煩告訴我，感謝。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="2"></b:comments>


		</b:entry>

		<b:entry entryID="000746" baseName="options-object">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-19</b:date>
				<b:time>01:35:15</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Options Object</b:title>
			<b:content>
				<b:summary> 上一篇文章 DOM Event Module 有講到 function API 設計收 option 物件比不同設定的值分開接收還好，這篇就要介紹一下這個 pattern，其實這個 pattern 我看過好幾篇文章講了，想不到等我現在要寫文章時卻找不太到，因為關鍵字有點太通用，不過剛好最近看完的 Effective JavaScript 也有說到這個 pattern，所以就拿他當參考文獻了~~ 這種設計的優點第一個當然就是前一篇有說到的，使用時的程式碼，用看的就知道不同的參數是什麼意義，直接偷 Effective JavaScript 的範例來，先看看不是 options object 的： var alert = new Alert(100, 75, 300, 200, "Error", messaage, "blue", "white", "black", "error", true);...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="http://www.flickr.com/photos/othree/9074497361/" title="Flickr 上 othree 的 Options Object"><img src="//farm4.staticflickr.com/3829/9074497361_5298d2643e_b.jpg" width="1024" height="683" alt="Options Object" srcset="//farm4.staticflickr.com/3829/9074497361_5298d2643e.jpg 768w, //farm4.staticflickr.com/3829/9074497361_5298d2643e_b.jpg 768w 2x, //farm4.staticflickr.com/3829/9074497361_013ef7e2be_k.jpg 2x" /></a></p>

<p>上一篇文章 <a href="https://blog.othree.net/log/2013/06/18/dom-event-module/">DOM Event Module</a> 有講到 function API 設計收 option 物件比不同設定的值分開接收還好，這篇就要介紹一下這個 pattern，其實這個 pattern 我看過好幾篇文章講了，想不到等我現在要寫文章時卻找不太到，因為關鍵字有點太通用，不過剛好最近看完的 <a href="http://effectivejs.com/">Effective JavaScript</a> 也有說到這個 pattern，所以就拿他當參考文獻了~~</p>

<p>這種設計的優點第一個當然就是前一篇有說到的，使用時的程式碼，用看的就知道不同的參數是什麼意義，直接偷 Effective JavaScript 的範例來，先看看不是 options object 的：</p>

<pre><code>var alert = new Alert(100, 75, 300, 200, 
                      "Error", messaage,
                      "blue", "white", "black",
                      "error", true);
</code></pre>

<p>這個例子比我前一篇的例子還要複雜許多，相信更能夠感覺到這些參數分別的意義很難判斷吧，所以改成用 options object 的：</p>

<pre><code>var alert = new Alert({
    x: 100, y: 75,
    width: 300, height: 200,
    title: "Error", message: message,
    titleColor: "blue", bgColor: "white", textColor: "black",
    icon: "error", modal: "true"
});
</code></pre>

<p>雖然其實我覺得全部的參數都塞到 options object 也不好，不過這問題不是這篇文章的重點，接下來要說的是另外一個優點，就是 API 介面可以和參數的數量脫勾（decouple），在未來更新改版增加新選項時也不用改參數的設計，這個優點要舉的例子是 <a href="http://api.jquery.com/jQuery.ajax/">jQuery.ajax</a>，他的第二個參數就是 options object，可以看文件有詳細的介紹所有的可以用選項，然後有一些選項，像是 headers、converts 就是後來才新增的，而 jQuery.ajax 本身收的參數則是從 1.0 之後就沒有變化了。</p>

<p>收了參數之後，通常第一步要做的是填預設值，很多的 JavaScript Library 都有提供 extend 可以利用，以 jQuery.ajax 為例，它用的是特製的 <a href="https://github.com/jquery/jquery/blob/2.0.2/src/ajax.js#L117">ajaxExtend</a>，當然 jQuery 也有提供 <a href="http://api.jquery.com/jQuery.extend/">jQuery.extend</a> 給一般的 case 使用，undersocre 也有 <a href="http://underscorejs.org/#extend">extend</a>，不過它還有一個填預設值專用的 <a href="http://underscorejs.org/#defaults">defaults</a>，兩者的差別在當初 propose 的 <a href="https://github.com/documentcloud/underscore/issues/106">issue</a> 上介紹的蠻清楚，基本上就是用 defaults 你可以這樣寫：</p>

<pre><code>_.defaults(options, defaultOptions);
</code></pre>

<p>但是如果用 options 要達成一樣的效果，你要寫成：</p>

<pre><code>options = _.extend({}, defaultOptions, options);
</code></pre>

<p>因為 extend 會讓後者的屬性覆蓋掉前者的，所以 defaultOptions 要放在 options 前面，但是 extend 回傳的是前面那個物件，所以要取代原本的 options 還要多一個 assign，至於 defaults 則是會改原來的 options 物件，所以不需要多那個 assign，也不需要先丟一個空物件給它，如果要讓 options 是可省略的參數，用 CoffeeScript 還可以在定義 function 時給它預設值，整個程式碼就漂亮很多：</p>

<pre><code>mylib.ajax = (url, options = {}) -&gt;
    _.default(options, defaultOptions)
</code></pre>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="1"></b:comments>


		</b:entry>

		<b:entry entryID="000745" baseName="dom-event-module">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-18</b:date>
				<b:time>16:51:19</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Native DOM Event Module</b:title>
			<b:content>
				<b:summary>我是在看 tap.js 的程式碼時，才真的注意到 DOM 的 event module （事件模組）其實我們已經可以拿來用了，關鍵在於比較少人注意到的 dispatchEvent 這個 method，這個 method 可以讓你對任意的 DOM Node 觸發任意事件，不管是 click 事件、mousemove 事件，還是 keydown 事件都可以，所以理論上你可以用 JS 模擬所有使用者做的操作，要做 integration 測試也沒問題，不過像是滑鼠拖拉要模擬就有點辛苦了。而除了原生有的事件外，其實 dispatchEvent 還支援自訂事件，對於自訂事件用途還不清楚的可以先看看以前的文章。 dispatchEvent 的用法和一般 JavaScript Library 的 trigger event 不太一樣，要先建立一個 event 物件給他： var event =...</b:summary>
				<b:mainContent><p>我是在看 <a href="http://alxgbsn.co.uk/2012/03/12/tap-js-a-lightweight-tap-event-javascript-plugin/">tap.js</a> 的程式碼時，才真的注意到 DOM 的 event module （事件模組）其實我們已經可以拿來用了，關鍵在於比較少人注意到的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.dispatchEvent">dispatchEvent</a>  這個 method，這個 method 可以讓你對任意的 DOM Node 觸發任意事件，不管是 click 事件、mousemove 事件，還是 keydown 事件都可以，所以理論上你可以用 JS 模擬所有使用者做的操作，要做 integration 測試也沒問題，不過像是滑鼠拖拉要模擬就有點辛苦了。而除了原生有的事件外，其實 dispatchEvent 還支援自訂事件，對於自訂事件用途還不清楚的可以先看看以前的<a href="https://blog.othree.net/log/2010/05/20/jquery-events/">文章</a>。</p>

<p>dispatchEvent 的用法和一般 JavaScript Library 的 trigger event 不太一樣，要先建立一個 event 物件給他：</p>

<pre><code>var event = document.createEvent('Event');
event.initEvent(type, true, true);

domnode.dispatchEvent(event);
</code></pre>

<p>其中的 type 才是你想要觸發的事件名稱，而第一個 createEvent 收的參數，除了 "Event" 這個最通用的之外，還有很多種<a href="https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent">原生事件</a>，如果是要自訂事件的話，可以用最通用的 "Event"。不過其實，還有一個比較新的 API：</p>

<pre><code>var event = new CustomEvent(type, {bubbles: true, cancelable: true});
</code></pre>

<p>這是 DOM Level 4 裡面提出來的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">Custom Event Constructor</a>，在這之前的 Level 3 就可以用第一個範例的方法產生 custom event，要先 create 再 init。這邊岔題一下，應該有人會注意到，createEvent 後 initEvent 那邊的 API 設計和 CustomEvent 不一樣，initEvent 收三個值，後面兩個都傳了 true，可是這樣的 API 設計近年來都被認為是不好的，因為你看程式碼，你完全不知道這兩個 true 是什麼意思，所以都是建議用第二種 API 的設計，收一個 options 物件，其實，initEvent 那兩個 true 分別就是 CustomEvent 後面的 bubbles 和 cancelable，但是後者的設計就可以讓程式碼看一眼就知道那兩個 true 是什麼用途的，看到這種不止開發者的程式在進化，連標準也跟著一起演進的現象還蠻有趣的~</p>

<p>Custom Event Constructor 目前 IE 的支援還比較差，所以還不能直接使用，還是要做一下 feature detection。至於哪些物件可以使用這些 method，除了 DOM Node，外，其實一般瀏覽器都還有一些物件可以聽事件，像是 window、document、 XMLHttpRequest instance 等，很可惜不是任意物件都可以，事實上，這些可以使用 DOM Event Module 的物件都是實作了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget</a> 這個介面，不過又要再說一次很可惜的，目前沒辦法把瀏覽器內的這些實作偷出來給其它物件使用，幸好 Andrea Giammarchi 有做了 <a href="https://github.com/WebReflection/event-target">一個</a> 放在 Github 上，可以給一般物件繼承去用。</p>

<p>我曾經寫過一篇文章介紹 <a href="https://blog.othree.net/log/2007/02/06/third-argument-of-addeventlistener/">addEventListener 的第三個參數</a>，這篇文章的最後我要來介紹第二個參數，第二個參數一般都是丟 function 進去，不過他其實也可以丟 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener">EventListener</a> 進去，基本上就是一個物件有 handleEvent 來當事件的 callback 而已，不過像 tap.js 就有很有趣的用法，它不管是什麼事件，在<a href="https://github.com/alexgibson/tap.js/blob/f6a3eef75e448de5ce2a659570cfd4511570f672/tap.js#L35">加上 addEventListener 時</a>丟進去的都是 this 物件，實際上則是統一在 handleEvent 裡面在<a href="https://github.com/alexgibson/tap.js/blob/f6a3eef75e448de5ce2a659570cfd4511570f672/tap.js#L97">根據事件的不同去作不同的事情</a>：</p>

<pre><code>Tap.prototype.handleEvent = function (e) {
    switch (e.type) {
        case 'touchstart': this.start(e); break;
        case 'touchmove': this.move(e); break;
        case 'touchend': this.end(e); break;
        case 'touchcancel': this.cancel(e); break;
        case 'mousedown': this.start(e); break;
        case 'mousemove': this.move(e); break;
        case 'mouseup': this.end(e); break;
    }
};
</code></pre>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="0"></b:comments>


		</b:entry>

		<b:entry entryID="000744" baseName="dependency-injection-of-angularjs">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2013-06-01</b:date>
				<b:time>01:56:48</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Dependency Injection of AngularJS</b:title>
			<b:content>
				<b:summary>在公開 javascript-libraries-syntax.vim 之後，我收到的第一個 Issue 就是支援 AngularJS，因為我一直都沒寫過，所以就花了些時間下去研究，然後就看到一個很有趣的名詞：Dependency Injection AngularJS 有一些很特別的參數，像是 $scope、$http 之類的，只要你的 function 是在 AngularJS 的 framework 內，然後接收的參數用到這些名字，例如： function($http, $q) { // do something with $http and $q } 這個 function 執行的時候，你不用管怎麼把正確的 $http 和 $q 傳給他，AngularJS 自己會幫你把他處理好，而這個特色就被稱為 Dependency Injection，當然除了內建的那些模組外，也可以自己註冊新的名稱對應到你開發的模組。 其實一開始看到這個特性的時候覺得有點神奇，很好奇怎麼做的，因為我想的到的就只有一個方法可以辦到，就是 Function.prototype.toString，這個...</b:summary>
				<b:mainContent><p>在公開 <a href="https://github.com/othree/javascript-libraries-syntax.vim">javascript-libraries-syntax.vim</a> 之後，我收到的第一個 Issue 就是支援 <a href="http://angularjs.org/">AngularJS</a>，因為我一直都沒寫過，所以就花了些時間下去研究，然後就看到一個很有趣的名詞：<strong>Dependency Injection</strong></p>

<p>AngularJS 有一些很特別的參數，像是 <code>$scope</code>、<code>$http</code> 之類的，只要你的 function 是在 AngularJS 的 framework 內，然後接收的參數用到這些名字，例如：</p>

<pre><code>function($http, $q) {
    // do something with $http and $q   
}
</code></pre>

<p>這個 function 執行的時候，你不用管怎麼把正確的 $http 和 $q 傳給他，AngularJS 自己會幫你把他處理好，而這個特色就被稱為 Dependency Injection，當然除了內建的那些模組外，也可以自己註冊新的名稱對應到你開發的模組。</p>

<p>其實一開始看到這個特性的時候覺得有點神奇，很好奇怎麼做的，因為我想的到的就只有一個方法可以辦到，就是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString">Function.prototype.toString</a>，這個 method 會把整個 function 的定義從第一行開始輸出成字串，然後分析字串把參數抓出來，這樣就可以在執行前知道需要哪些模組，本來一直期待是不是有什麼神奇技巧，而不是用 toString 辦到的，結果去看了看原始碼，發現真的就是這樣做的，一下子神秘感就消失了～～</p>

<p>Merrick 有一篇 <a href="http://merrickchristensen.com/articles/javascript-dependency-injection.html">JavaScript Dependency Injection</a>，有比較清楚的介紹到 AngularJS 這塊是怎麼做的。不過其實我對於 AngularJS 的這個特性是不是能稱為 Dependency Injection 一直存疑。</p>

<p>在看介紹 Dependency Injection 的文章時，幾乎舉的例子都是在有 Interface 的語言下，程式內的的相依性都相依在 Interface 上，而不相依在實做的 instance 上，等到實際上跑的時候才根據情況丟不同的實做（implement），而 JavaScript 並沒有這層 interface 的設計，AngularJS 自然也沒有，為此我想了很久，也一直在找網路上的資源，直到昨天終於想通了。</p>

<p>Dependency Injection 的重點不在於用程式語言的 Interface 特性來把相依性抽離，而是利用這樣的設計，讓你的程式不要直接相依於實際的實體（instance），由於 JavaScript 是弱型別的語言，所以其實在定義 function 時，並不需要指定輸入參數的型別，利用這個特性，其實就已經可以達成 Depedency Injection 了，只要實際執行程式時，根據狀況丟入應該丟入的 instance 即可。</p>

<p>AngularJS 則是在這特性之上，利用參數名稱來當成相依的 Interface，實際上程式執行時會是那個模組的實體傳入，就要看是哪一個模組註冊到對應的名稱了。</p>

<p>在我終於想通之後，發現到其實 <a href="http://requirejs.org/">RequireJS</a> 也是很相似的架構，所以就搜尋了一下，果然也有人利用 RequireJS 來做 Dependency Injection，Eric Feminella 寫了 <a href="http://www.ericfeminella.com/blog/2012/12/15/basic-dependency-injection-with-requirejs/">Basic Dependency Injection with RequireJS</a> 這篇文章，裡面的例子很不錯，假設開發一個 Web Applicaiotion，同時需要支援 Desktop 和 Mobile，兩種環境要不同的介面，但是核心的程式運作是一樣的，和 UI 相關的東西則要有 Mobile 用和 Desktop 用，這時候就可以用 Dependency Injection 來根據不同環境，決定要丟 Mobile 版的 UI 模組還是 Desktop 版的，核心的模組則不需要考慮到不同環境的差異，只要確保不同的 UI 模組的介面是一樣的就可以了。</p>

<p>最後還要講的是 RequireJS 的一個語法：</p>

<pre><code>define(function (require) {
    var core = require('core'),
        ui = require('ui');

    // do something with core and ui
});
</code></pre>

<p>我第一次看到這種寫法時就覺得：「不對吧，這樣沒辦法確保這個模組執行時，裡面需要的 core 和 ui 已經有了啊。」因為除了去解析程式碼外，這樣子寫從外面根本不知道 function 裡面 require 了什麼東西，而且現在也不可能讓程式跑到某行暫時停下等其他模組準備好，所以看了 RequireJS 原始碼的結論是，它就是去分析程式碼裡面 require 了什麼東西，然後自動加到這個模組的相依性清單裡面這樣，一樣是用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/toString">Function.prototype.toString</a> 辦到的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>

			<b:comments commentCount="1"></b:comments>


		</b:entry>

	</b:entries>
</b:blog>
