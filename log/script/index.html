<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cmn-Hant-TW" prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8"/>
    <title>script : O3noBLOG</title>
    <meta name="description" content="本網站是othree的個人部落格，主要內容為網路標準、網頁設計，穿插些ACG心得和敗家紀錄"/>
    <meta name="keywords" content="othree, ooo, blog, acg, html, css, javascript, vim, web page design"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
    <link rel="preconnect" href="https://fonts.bunny.net" crossorigin="anonymous"/>
    <link href="https://fonts.bunny.net/css?family=jetbrains-mono:400|press-start-2p:400" rel="stylesheet"/>
    <link rel="stylesheet" type="text/css" lazyload="lazyload" href="/stylesheets/all.css"/>
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="https://feeds.feedburner.com/othree"/>
    <link rel="made" href="mailto:othree@gmail.com"/>
    <link rel="prev" title="其他" href="/log/others/"/>
    <link rel="next" title="Server Side" href="/log/server/"/>
    <link rel="up" title="上一層" href="../"/>
    <link rel="top" title="首頁" href="/"/>
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:creator" content="@othree"/>
    <meta property="og:title" content="O3noBLOG"/>
    <meta property="og:description" content="本網站是othree的個人部落格，主要內容為網路標準、網頁設計，穿插些ACG心得和敗家紀錄"/>
    <meta property="og:url" content="https://blog.othree.net/log/script/"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://blog.othree.net/images/O3-240x240.png"/>
    <meta property="og:image:width" content="240"/>
    <meta property="og:image:height" content="240"/>
    <meta name="twitter:widgets:csp" content="on"/>
    <meta property="fb:admins" content="582724207"/>
  </head>
  <body itemscope="itemscope" itemtype="http://schema.org/Blog">
    <nav>
      <div class="nav-inner">
        <form method="get" id="nav-search" class="navbar-search o-hidden" action="https://duckduckgo.com/" role="search">
          <input id="search" type="search" name="q" size="20" tabindex="8" aria-label="搜尋" placeholder="搜尋" required="required" aria-required="true" class="search-query input-medium"/>
          <input type="hidden" name="sites" value="blog.othree.net"/>
        </form>
        <div class="pure-menu pure-menu-horizontal">
          <a href="/" class="pure-menu-item">
                    首頁
                </a>
          <a href="/log/" accesskey="3" class="pure-menu-item pure-menu-selected" id="pure-menu-selected">
                    彙整
                </a>
          <a href="/blogroll/" title="BLOGROLL" class="pure-menu-item">
                    部落滾
                </a>
          <a href="/about/me/" class="pure-menu-item">
                    About
                </a>
          <a href="https://github.com/othree" target="_blank" class="pure-menu-item icon github" title="GitHub">
            <img src="/images/github.svg" width="24" height="24" alt="GitHub"/>
          </a>
        </div>
      </div>
    </nav>
    <div id="container" class="container">
      <header role="banner" class="pure-g">
        <h1 class="pure-u-1">
          <a href="/" accesskey="1" title="O3noBLOG">O3noBLOG</a>
        </h1>
      </header>
      <div class="pure-g">
        <div id="page-info" class="span9">
          <div class="row">
            <div class="span6">
              <h2>SCRIPT</h2>
            </div>
            <div id="page-nav" class="span2"><a title="其他" href="/log/others/">« 其他</a> | <a href="../">上一層</a> | <a title="Server Side" href="/log/server/">Server Side »</a><!--fix for ie--></div>
          </div>
        </div>
        <main id="content" role="main" class="pure-u-1 pure-u-lg-3-4">
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-csp-for-lambdaedge">
            <header>
              <time itemprop="datePublished dateModified" datetime="2021-08-12T11:59:16" id="date-2021-08-12">
                <span class="mon">08月</span>
                <span class="day">12日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2021/08/12/csp-for-lambdaedge/">CSP for Lambda@Edge</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" class="thumbnail" href="https://www.flickr.com/photos/othree/51371732481/" title="CSP by othree, on Flickr"><img itemprop="url image" src="https://live.staticflickr.com/65535/51371732481_5335b8d3f0_b.jpg" width="710" height="305" alt="CSP" srcset=""><meta itemprop="width" content="710"/><meta itemprop="height" content="305"/></img></a></p>
<p>之前工作上主要是用 AWS，AWS 放靜態網站有過 CloudFront CDN 時，如果需要調整 header 的話，官方的解決方案是用 Lambda@Edge，寫 AWS Lambda function 的時候，其實我個人有一個偏好，就是能不用第三方 module 就不用，主要原因有兩個，第一個原因是，如果程式碼太大包，會無法在 AWS console 上直接看（或修改）程式碼；第二個原因是發佈流程會比較麻煩，因為還要去安裝 module，然後再全部打包起來上傳。</p>
<p>要調整 header 的一個主要原因就是為了 security headers，大部分的 security header 都還算單純，但是 CSP（Content Security Policy）就複雜很多了，如果沒有用結構化的資料，其實很難維護，但是針對 Lambda function 我又不想要用第三方 module，最後我想到的解決方案，就是設計一個很簡短的工具函式來把結構化的資料轉成 CSP header 的值，這就是我最近趁 COSCUP 2021 會議期間整理好的新的 open source 專案：<a href="https://github.com/othree/csp">CSP</a>。</p>
<p>這個專案內容就只是一個簡單的 function：</p>
<pre><code class="language-javascript">const CSP = (directives) =&gt; {
  return directives
    .map((directive) =&gt; {
      return `${directive.name} ${directive.value.join(' ')};`;
    })
    .join(' ');
};
</code></pre>
<p>不過為了好好設計這個 function 其實我也是花不少功夫，首先就是輸入參數的結構要長怎樣，其實一般比較常見的是用物件 property 直接就作為 directive name 的形式，像是 Google 的 <a href="https://github.com/google/csp-evaluator">CSP Evaluator</a>：</p>
<pre><code class="language-json">{
  "default-src": ["'none'"],
  "script-src": ["'self'"],
  "connect-src": ["blah", "blah"]
}
</code></pre>
<p>這種結構比較精簡，但是問題就是無法保證順序，考慮再三之後，決定還是用陣列的形式：</p>
<pre><code class="language-json">[
  {
    "name": "default-src",
    "value": ["'none'"]
  },
  {
    "name": "script-src"",
    "value": ["'self'"]
  }
]
</code></pre>
<p>這樣就可以讓開發人員確保輸出的順序，其實大部分時候我也不會那麼在意順序，不過要是 <code>default-src</code> 如果不是第一個感覺就很不舒服。確定主要的資料結構後，再來就是屬性名稱要用什麼好的問題了，為了找到正確的名稱，我去翻了 <a href="https://w3c.github.io/webappsec-csp/#framework-policy">CSP spec</a> 找到關於 parsing 相關的說明，確定了 spec 定義的結構是這樣的（使用 TypeScript 語法）：</p>
<pre><code class="language-typescript">type Source = string;

type Directive = {
  name: string;
  value: Source[];
};

type Policy = {
  source: "header" | "meta";
  disposition: "enforce" | "report";
  directiveSet: OrderedSet&lt;Directive&gt;;
};

type Policies = Policy[];
</code></pre>
<p>在輸入資料的陣列中，每個元素都是 <code>Directive</code>，<code>Directive</code> 的兩個屬性分別是 <code>name</code> 和 <code>value</code>，<code>value</code>  則是 <code>Source</code> 的陣列集合，當然 <code>Source</code> 還有更嚴謹的定義，不過這邊就簡化成字串就好。確定完輸入資料的結構後，就是要想盡辦法簡化 function 的內容了，但是也不希望太難讀懂，調整了幾次變成現在的樣子，我還提供了精簡的版本：</p>
<pre><code class="language-javascript">const CSP = p =&gt; p.map(d =&gt; `${d.name} ${d.value.join(' ')};`).join(' ');
</code></pre>
<p>其實我對於那個 <code>map</code> 接 <code>join</code> 一直耿耿於懷，很想要用 <code>reduce</code> 解決，但是要避免頭尾多空白，會需要多判斷式，就算不予理會，程式碼長度其實還是比現在這個版本長，結果還是 <code>map</code> 接 <code>join</code> 看起來比較漂亮，所以最後的版本就維持這樣了。</p>
<p>然後我還寫了測試和提供了兩個 <a href="https://github.com/othree/csp/tree/master/examples">example</a>，分別是 Lambda@Edge 和 Cloudflare Workers 的，不確定還有沒有類似的服務，如果有發現會再加上。最後就是，因為這個 function 設計就是要給人複製貼上的，所以並沒有發布到 npm 上，然後使用 MIT-0 license 所以也不用 attribution，覺得有興趣使用的就請直接複製貼上吧～</p>
<p>PS. 如果有其他需求，可以看看 <a href="https://www.npmjs.com/package/csp-header">csp-header</a>，例如 Express 使用，我覺得介面設計得很不錯。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-circleci-terraform-aws-deploy">
            <header>
              <time itemprop="datePublished dateModified" datetime="2019-08-22T23:02:19" id="date-2019-08-22">
                <span class="mon">08月</span>
                <span class="day">22日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2019/08/22/circleci-terraform-aws-deploy/">Circle CI run Terraform and AWS deployment</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p>最近花很多時間在 CI，其中一個比較大的目標是跑 Terraform 加上用它輸出的 S3 name 來作為後面發佈步驟的發佈目標，然後加上不想要用第三方的 docker image 和 orbs，不過網路上都沒看到有這樣子做的範例，所以花了些時間嘗試、看文件和範例，這篇就是把一些目前的結論記錄下來：</p>
<p>Terraform 是用 hashicorp 官方的 <a href="https://hub.docker.com/r/hashicorp/terraform/">image</a>，基本上就是 alpine + go + terraform 而已，shell 只有 sh 沒有 bash，不過其實 Circle CI 的一些文件看起來，他們應該是建議要使用 bash 為主，其中一個主要原因就是 <a href="https://circleci.com/docs/2.0/env-vars/#setting-an-environment-variable-in-a-shell-command">BASH_ENV</a> 這個環境變數有沒有支援，支援的話就可以很輕鬆的在不同 command 間傳遞環境變數了，不過還好我在 Terraform 這邊只需要寫入，還不需要讀出，所以就是 Terraform 執行完之後加一個 command 執行：</p>
<pre><code class="language-sh">echo "export S3_ID=`terraform output s3_bucket_name`" &gt;&gt; $BASH_ENV
</code></pre>
<p>當然你的 terraform module 要有定義好 output。</p>
<p>第二個是重點是 <code>$BASH_ENV</code> 的值，個人建議是設定絕對路徑，直接寫出完整路徑，不要用其它環境變數來組合，然後位置要放在 working directory 內，好方便能  <code>persist_to_workspace</code>，這樣才能夠跨 job 使用，另外就是檔名建議不要用 <code>.</code> 開頭的隱藏檔名，我遇到過各種找不到檔案的錯誤訊息，然後 working directory 建議不要放在 home 目錄下，一來 <code>$BASH_ENV</code> 去用 <code>$HOME</code> 組合出來我遇到錯誤過，用 <code>~</code> 來寫路徑也是遇到錯誤過，二來不同 image 的 home 目錄路徑不同，如果要在 config 內直接寫死絕對路徑，建議直接定一個固定的位置，我現在是用：</p>
<pre><code>/tmp/workspace
</code></pre>
<p>然後這樣後面就可以用官方的 s3 orb 下指令了：</p>
<pre><code class="language-yaml">- aws-s3/sync:
    from: build
    to: "s3://${S3_ID}"
    aws-region: "ap-northeast-1"
</code></pre>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-glob">
            <header>
              <time itemprop="datePublished dateModified" datetime="2019-04-30T23:32:23" id="date-2019-04-30">
                <span class="mon">04月</span>
                <span class="day">30日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2019/04/30/glob/">glob</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p>最近在搞 jsctags-oasis 這個專案，因此認真的研究了一下 glob，glob 這東西其實有在使用 CLI 的話，一定是使用過的，例如：</p>
<pre><code class="language-sh">ls *.js
</code></pre>
<p>後面的 <code>*.js</code> 就是 glob，應該可以稱為一種表達式吧，沒有正規表示式（Regular Expression）強大，是專用於匹配檔案的，現在也已經是內建於 Linux shell 內的功能了，所以其實只要 <code>man glob.7</code> 或是 <code>man 7 glob</code> 就可以找到<a href="http://man7.org/linux/man-pages/man7/glob.7.html">官方文件</a>了（不過 macOS 上沒有），然後 glob 和正規表示式相比，有個很關鍵的差異就是 glob 是有判斷路徑階層的，也就是其實 <code>?</code> 和 <code>*</code> 雖然是任意字元，但是 <code>/</code> 不屬於任意字元，<code>/</code> 又被稱為 path separator，如果要找不同層子目錄的檔案，就要把路徑寫好，不然比對時不會如願找到想要的目標，而這個差異其實也說明了為什麼 <code>ls subfolder/*</code> 只會印出該層子目錄下的檔案，而不是把第二第三層子目錄下的東西也都印出來，雖然有 <code>**</code> 這個寫法，不過我是在 nodejs 開始蓬勃發展之後才在 node-glob 文件上看到的。</p>
<p>其實我第一次看到 <strong>glob</strong> 這個單字也是 <a href="https://github.com/isaacs/node-glob">node-glob</a>，不過當時以為 node-glob 和命令列的那套不相容，只是借用名字而已，因為那個 <code>**/*.js</code> 的語法我以前沒看過，一直以為是 node-glob 自己做的，直到這次研究才發現其實 <code>**</code> 是 <a href="http://man7.org/linux/man-pages/man1/bash.1.html">bash</a> 提供的擴充語法，bash 的 extglob 提供了一些更接近正規表示式的語法：</p>
<pre><code>?(pattern-list)
       Matches zero or one occurrence of the given patterns
*(pattern-list)
       Matches zero or more occurrences of the given patterns
+(pattern-list)
       Matches one or more occurrences of the given patterns
@(pattern-list)
       Matches one of the given patterns
!(pattern-list)
       Matches anything except one of the given patterns
</code></pre>
<p>另外還有很多設定可以調整 glob 的行為，其中一樣叫做 <code>globstar</code> 的，就是讓 <code>**</code> 可以 recursive 的 match 子目錄的檔案，這個功能是在 <a href="https://github.com/bminor/bash/blob/3185942a5234e26ab13fa02f9c51d340cec514f8/CHANGES#L524">bash 4.0 alpha</a> 版的時候新增的，到今天其實也已經超過十年了。</p>
<p>至於為什麼會研究起 glob 呢？是因為我在做 jsctags-oasis 時，要盡量的支援 <a href="http://ctags.sourceforge.net/">Exuberant Ctags</a> 支援的參數，其中做到 <code>exclude</code> 的時候，一開始偷懶用了 node-glob 的 ignore，但是實際上要拿 <a href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a> 來用時卻行為不如預期，為了能正確支援就研究起這實際上怎麼串起來的，首先是 vim-gutentags 會拿 Vim 那邊的 <a href="https://vimhelp.org/options.txt.html#%27wildignore%27">wildignore</a> 送給 ctags，wildignore 使用的表達式是 Vim 自己的 <a href="https://vimhelp.org/autocmd.txt.html#file-pattern">filepattern</a>，和 glob 有點接近，像是 <code>*</code> 都是正規表示式的 <code>.*</code>，還有 <code>?</code> 都是正規表示式的 <code>.</code>，不過 <code>*</code> 有特別說到：</p>
<blockquote>
<p>Unusual: includes path separators</p>
</blockquote>
<p>這行為就和 glob 不一樣了，所以假設 ctags 的 <code>exclude</code> 也是用 glob 表示式，那是不是表示 vim-gutentags 這邊實做有不正確呢？結果我發現 Exuberant Ctags 的文件是這樣說的：</p>
<blockquote>
<p>each <em>pattern</em> specified using this
option will be compared against both the complete path (e.g.
some/path/base.ext) and the base name (e.g. base.ext) of the
file, thus allowing patterns which match a given file name
irrespective of its path, or match only a specific path. If
appropriate support is available from the runtime library of
your C compiler, then <em>pattern</em> may contain the usual
shell wildcards (not regular expressions) common on Unix (be
sure to quote the option parameter to protect the wildcards
from being expanded by the shell before being passed to
<strong>ctags</strong>; also be aware that wildcards can match the
slash character, '/').</p>
</blockquote>
<p>這時候就要感謝那時期的文件都有寫得很詳細，不用花時間去看程式碼，這邊的說明就是說會比對 basename （檔名加附檔名）和完整的 pathname，另外對於 wildcard 的支援則是看系統，是用 <a href="http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm">shell wildcards</a>，其實就是 glob 表達式，不過照這樣說，應該就和 Vim filepattern 不一樣了，研究許久才注意到關鍵的地方就在上面那段文件的最後一句，提到 wildcards 也會 match 到 <code>/</code> 字元，也就是最前面提到的 path separator，結果就是， Vim filepattern 和 Exuberant Ctags 的 <code>exclude</code> 用的表示式基本上是相容的，但是也因為特性就無法用 node-glob 的 <code>ignore</code> 來支援了。所以我就照著說明自己實做了比對的部分，然後有用到一個叫 <a href="https://www.npmjs.com/package/globrex">globrex</a> 的 npm package，這個是 <a href="https://www.npmjs.com/package/tiny-glob">tiny-glob</a> 底層用的工具，算是個偷吃步，不管 path separator 直接把 glob 轉成正規表示式的作法，根據原始碼，它會直接把 <code>*</code> 轉換成 <code>.*</code>，這樣就會 match 到 <code>/</code> 字元了，本來是偷吃步的作法，卻意外的剛好合用，理論上這樣就可以正確的支援 ctags 的 <code>exclude</code> 才是吧。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-third-argument-of-addeventlistener-2">
            <header>
              <time itemprop="datePublished dateModified" datetime="2019-03-20T23:52:39" id="date-2019-03-20">
                <span class="mon">03月</span>
                <span class="day">20日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2019/03/20/third-argument-of-addeventlistener-2/">addEventListener 的第三個參數</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" class="thumbnail" href="https://www.flickr.com/photos/othree/40460552953/" title="addEventListener by othree, on Flickr"><img itemprop="url image" src="https://farm8.staticflickr.com/7917/40460552953_4c7f15c64c_b.jpg" intrinsicsize="1024x787" width="1024" height="787" alt="addEventListener" srcset="https://farm8.staticflickr.com/7917/40460552953_4c7f15c64c_b.jpg 1024w, https://farm8.staticflickr.com/7917/40460552953_f337cc854a_h.jpg 1600w"><meta itemprop="width" content="1024"/><meta itemprop="height" content="787"/></img></a></p>
<p>2007 年我寫過一篇一樣標題的 <a href="https://blog.othree.net/log/2007/02/06/third-argument-of-addeventlistener/">addEventListener 的第三個參數</a>，介紹了事件發生時， DOM Node 的 capture 和 bubbling，事隔十多年，前陣子定睛一看，發現 DOM spec 有變，第三個參數除了可以收 boolean 型別的 useCapture 之外，還可以收 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters">options</a> 物件，又稱為 <a href="https://github.com/WICG/EventListenerOptions">EventListenerOptions</a>，而這個 options 物件現在支援三個屬性，分別是：</p>
<ul>
<li><code>capture</code>－就是以前的第三個參數 useCapture，Boolean 型別。</li>
<li><code>once</code>－新的選項，也是 Boolean 型別，用途就像是 jQuery 的 <a href="https://api.jquery.com/one/">one</a> 一樣，想不到現在也直接在 DOM 層原生支援了</li>
<li><code>passive</code>－也是新選項，一樣是 Boolean 型別，用途是告訴瀏覽器，這個事件 handler function 會不會呼叫 <code>event.preventDefault</code> 來停止瀏覽器的原生行為，我最初其實是在 Google 的關於 <a href="https://developers.google.com/web/updates/2016/06/passive-event-listeners">scroll performance 的文件</a> 看到的，就是如果你是 scroll event，以前會因為瀏覽器要判斷會不會被 <code>preventDefault</code>，所以讓 scroll 的效能變差，加上這個選項可以直接告訴瀏覽器說沒有要 preventDefault 後，原生的事件行為就可以不管 event handler 直接處理了，如果裡面硬是執行 <code>event.preventDefault</code> 的話，那就會被忽略掉，然後根據使用的瀏覽器的話，有的會有警告訊息出現在 console。</li>
</ul>
<p>Passive Event 的效果也有人做了影片可以看（<a href="https://medium.com/@devlucky/about-passive-event-listeners-224ff620e68c">來源</a>）：</p>
<div class="embed_16_9">
  <iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/NPM6172J22g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen"/>
</div>
<p>EventListenerOptions 這個東西大概是在 2015 開始討論的，然後 <a href="https://discourse.wicg.io/t/eventlisteneroptions-and-passive-event-listeners-move-to-wicg/1386">2016</a> 進到 WICG 討論，瀏覽器開始實做，一開始就是只有 <code>passive</code> 和 <code>capture</code>，<code>once</code> 則是後來才加上的，所以可以看到 MDN 的瀏覽器支援度表格，<code>once</code> 還要比較新一點的瀏覽器才支援，像是 Chrome 51 就支援 <code>passive</code>，然後要到 55 才支援 <code>once</code>，如果再仔細看，會發現最後一列是 <code>touchstart</code>、<code>touchmove</code> 事件如果是在 document 層的話，預設改為 passive 事件，這是 2017 年 Chrome 主導修改的行為，Firefox 也有跟進，主要就是希望能讓這些事件處理預設效能好一點，這部分的行為修改其實到現在都還沒標準化，目前還是在 WICG 那邊有個 <a href="https://github.com/WICG/interventions/issues/18">open issue</a>，除了 touch 事件外，其實連 document 層的 wheel 事件也在 <a href="https://developers.google.com/web/updates/2019/02/scrolling-intervention">Chrome 73</a>，也就是現在的穩定版本也預設改為 passive 事件了，然後也是有 WICG  的 <a href="https://github.com/WICG/interventions/issues/64">open issue</a>，MDN 的表則是還沒有。</p>
<p>EventListenerOptions 也是有 polyfill 和工具 package 的，首先來說一下 polyfill 吧，我知道的有 <a href="https://github.com/WebReflection/dom4">dom4</a>，其實搜尋一下還蠻容易找到其它的，不過差異沒很大，feature detection 的方式幾乎都是用 Object 的 getter 來看送進去的 options 物件的 <code>passive</code> 屬性有沒有被讀取過，有的話就表示瀏覽器有支援，然候 polyfill 其實也只有行為上的補完，不會真的讓效能提升，不過 polyfill 在現在的支援度下來看也是不太需要了。Package 的話有個 <a href="https://www.npmjs.com/package/default-passive-events">default-passive-events</a> 會幫忙把 scroll、wheel、mouse、touch 等等有需要的事件都改為預設 <code>passive: true</code>，如果是新專案先加一下似乎不錯，不過感覺上 Google 是很想都改掉的樣子，現在其實也只差 mouse 事件而已，應該是還怕影響太大不敢下手吧。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-async-await-try-catch">
            <header>
              <time itemprop="datePublished dateModified" datetime="2019-01-26T17:21:51" id="date-2019-01-26">
                <span class="mon">01月</span>
                <span class="day">26日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2019/01/26/async-await-try-catch/">async, await and try catch</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" class="thumbnail" href="https://www.flickr.com/photos/othree/27075072839/" title="New Zeland by othree, on Flickr"><img itemprop="url image" src="https://farm5.staticflickr.com/4536/27075072839_b123075b6f_b.jpg" intrinsicsize="1024x683" width="1024" height="683" alt="New Zeland" srcset="https://farm5.staticflickr.com/4536/27075072839_b123075b6f_b.jpg 1024w, https://farm5.staticflickr.com/4536/27075072839_ef2586e741_h.jpg 1600w"><meta itemprop="width" content="1024"/><meta itemprop="height" content="683"/></img></a></p>
<p>這篇想說一下 <code>async</code>﹑<code>await</code> 語法的一些小細節，首先從 <code>async</code> 來說吧，一般來說，async function 是在內部有需要用 <code>await</code> 等 Promise 結果的時候才使用，也由於這個特性，async function 的回傳值都會是個 Promise，意思就是你回傳非 Promise 的值，會<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-async-functions-abstract-operations">自動被包成 Promise</a>，所以像下面的程式：</p>
<pre><code class="language-js">async function wow () {
    return Promise.resolve(100);
}

wow().then(v =&gt; { console.log(v); });
</code></pre>
<p>就等同於：</p>
<pre><code class="language-js">async function wow () {
    return 100;
}

wow().then(v =&gt; { console.log(v); });
</code></pre>
<p>和直接回 Promise value 比起來，效能上不會有什麼顯著差異，從建議的實做方法來看就是多一個判斷。再來看看 <code>await</code> 吧，首先一樣，<code>await</code> 一般是用來接 Promise 的，不過其實也是可以接非 Promise value 的</p>
<pre><code class="language-js">async function wow () {
  var r = await 1;
  console.log(1);
}

wow();
console.log(2);
</code></pre>
<p>所以這樣的程式碼也可以正確執行，不過 await 那邊的執行方式還是會維持非同步的（實際上應該是後面的東西都會用 Promise 包起來一次），所以這段程式碼的輸出會是先輸出 <code>2</code> 再輸出 <code>1</code>。</p>
<p>再來這點可能比較多人知道，就是連續的多個 <code>await</code> 不會讓這些非同步操作同時開始：</p>
<pre><code class="language-js">async function wow () {
  const a = await fetch('/a');
  const b = await fetch('/b');
  const c = await fetch('/c');

  return [a, b, c];
}
</code></pre>
<p>這樣其實三個請求會照順序執行，<code>a</code> 有結果了才去要 <code>b</code>，<code>b</code> 有結果了才去要 <code>c</code>，而不是同時處理，如果要同時發出請求則還是需要用 <code>Promise.all</code>，然後不用 <code>async</code> 了：</p>
<pre><code class="language-js">function wow () {
  return Promise.all([
    fetch('/a'),
    fetch('/b'),
    fetch('/c')
  ]);
}
</code></pre>
<p>不要  <code>await</code> 的話，也是可以先 assign 給變數的：</p>
<pre><code class="language-js">function wow () {
  const a = fetch('/a');
  const b = fetch('/b');
  const c = fetch('/c');

  return Promise.all([a, b, c]);
}
</code></pre>
<p>然後其實 <code>Promise.all</code> 是要所有的 Promise 都 fulfilled 時才會 resolve，另外一個角度來看，就是其中只要一個 rejected 的話，就不會 resolve，實際上使用起來變化有點少，而且要做忽略錯誤的 <code>fetch</code> 也有點麻煩，所以現在 TC39 還有個新的草案叫 <a href="https://docs.google.com/presentation/d/1fWK9kMsvn2o66Lk6QUw3yITEfsE87yjZdTngoLTsUQ0/edit#slide=id.g41da6c5107_0_0">Promise.allSettled</a>，不管是 resolve 還是 reject，只要所有參數內的 Promise 都結束了，<code>allSettled</code> 就會 resolve，目前這草案還在 stage 1，過幾天的會議有望升到 stage 2，不過這是題外話。</p>
<p>最後一個想說的就是 <code>await</code> 處理 rejected Promise 的問題，如果是從 jQuery 時期就開始寫 Deferred/Promise 的人，可能會很習慣的把 Promise 的兩種狀態拿來當成值的一部份，事實上這也是 <code>jQuery.ajax</code> 的設計，如果用這種想法來寫 <code>await</code> 接值的時候，就會覺得很難處理 <code>rejected</code> 的狀態，因為要用 <code>try...catch</code>：</p>
<pre><code class="language-js">async function wow () {
  try {
    const a = await fetch('/a');     
  } catch (error) {
    // deal with non-ok fetch
  }
}
</code></pre>
<p>要這樣寫還不如用舊的 <code>.then</code> 來接看起來還漂亮一點。不過實際上，這是錯誤的理解 Promise，Promise 不是用來取得兩種狀態用的，而是用來非同步取得單一個數值用的機制，而所謂 <code>rejected</code> 的狀態，其實就是發生非預期狀況（unexpected exception）的情形，這也就是為什麼 ECMAScript 版的 Promise 是用 <code>throw Error</code> 的方式來 reject Promise。</p>
<p>我一直覺得用 HTTP 請求來比較這兩種設計蠻好理解的，使用 jQuery 的 <code>ajax</code>，server 端回非 200 的 status 的話，就會被當成是錯誤，然後回傳的 Promise 就會被 reject，但是在使用 ECMAScript Promise 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">fetch</a> 中，不管 server 端回應的 status code，fetch 都會 resolve，而會 reject 的情形，就只有網路有問題的時候，像是網路斷線、存取被拒絕（CORS）等完全碰不到遠端主機的情形，也就是對於一個 HTTP 請求來說，真正的非預期狀況，所以如果你有兩種狀況要處理，那應該是回傳值的一部份，後面再用 <code>if...else</code> 來做分支。</p>
<p>回來看 <code>await</code> 的使用，究竟應該什麼時候來用 <code>try...catch</code> 呢，我自己有一個很簡單的初步判斷條件，就是這個取值的程式碼，如果不是非同步，沒有使用 <code>await</code> 的話，你會不會用 <code>try...catch</code> 包起來，不會的話，那改成非同步操作的程式碼應該也不用 <code>try...catch</code>。不過現實世界當然還是比較難一點，非同步的取值風險和狀況還是比較多的，例如 <code>fetch</code> 遇到網路問題會 reject，但是還是需要處理這種狀況，不用 <code>try...catch</code> 的話，怎樣寫比較好呢？我的想法是，用 <code>.then/catch</code> 處理好需要處理的情形，然後把結果包起來傳回去，所以要處理 <code>fetch</code> 的非預期狀況的話，就可以改成：</p>
<pre><code class="language-js">async function wow () {
  const a = await fetch('/a').catch(error =&gt; {
    return {
      ok: false,
      status: -1,
      error: error,  
    };
  });
  
  if (a.status === -1) {
    // exception error handling
  }
}
</code></pre>
<p>這邊我設計成有非預期狀況時，status code 為 <code>-1</code>，並且把 error 資訊也傳回去，然後後面就可以直接拿來判斷是不是非預期狀況，當然也可以把這個處理包成一個自己的 <code>myFetch</code>：</p>
<pre><code class="language-js">const myFetch = (url, options) =&gt;
  fetch(url, options)
    .catch(error =&gt; {
      ok: false,
      status: -1,
      error: error,  
    });
</code></pre>
<p>然後原來的程式就可以直接拿 <code>myFetch</code> 取代 <code>fetch</code> 了。</p>
<p>如果要通用一點的，其實有一個叫 <a href="https://www.npmjs.com/package/await-to-js">await-to-js</a> 的套件我覺得蠻不錯的，直接拿官方的範例看吧：</p>
<pre><code class="language-js">import to from 'await-to-js';

async function asyncTaskWithCb(cb) {
  let [err, user] = await to(UserModel.findById(1));
  if (!user) return cb('No user found');
}
</code></pre>
<p>它可以包裝 Promise 物件，然後不管那個 Promise 成功還是失敗，它自己都會 resolve，resolve 的值就是 <code>[error, value]</code> 這樣形式的陣列，一來符合 node 的 <a href="https://nodejs.org/api/errors.html#errors_error_first_callbacks">error-first callbacks</a>，再來就是配合 destructuring assignment 其實程式碼是蠻漂亮的。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-esm-for-npm-package">
            <header>
              <time itemprop="datePublished dateModified" datetime="2019-01-10T22:27:07" id="date-2019-01-10">
                <span class="mon">01月</span>
                <span class="day">10日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2019/01/10/esm-for-npm-package/">ES Module for NPM Package</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" class="thumbnail" href="https://www.flickr.com/photos/othree/38820559832/" title="Queenstown by othree, on Flickr"><img itemprop="url image" src="https://farm5.staticflickr.com/4560/38820559832_4124a4cb13_b.jpg" intrinsicsize="1024x683" width="1024" height="683" alt="Queenstown" srcset="https://farm5.staticflickr.com/4560/38820559832_4124a4cb13_b.jpg 1024w, https://farm5.staticflickr.com/4560/38820559832_998d7ad575_h.jpg 1600w"><meta itemprop="width" content="1024"/><meta itemprop="height" content="683"/></img></a></p>
<p>For English reader: <a href="https://github.com/othree/til/blob/master/js/esm-package.md">https://github.com/othree/til/blob/master/js/esm-package.md</a></p>
<p>這個問題我卡蠻久了，最近才解決加上找好一些資訊的來源，目標就是要讓一個 NPM package 同時提供 CommonJS module 和 ES module 的版本，現在很多地方可以用 ES module 了，像是 Node.js 自己有經有在測試用 <a href="https://nodejs.org/api/esm.html">mjs</a> 副檔名，webpack 和 rollup 也都支援 ES module 的 bundle，而且要 <a href="https://webpack.js.org/guides/tree-shaking/">tree shaking</a> 的功能也需要使用 ES module，用以前的 CommonJS 是不支援的，不多廢話，直接看怎樣做吧：</p>
<pre><code class="language-js">{
  "name": "smartypants",
  "version": "0.1.1",
  "main": "smartypants",
  "module": "smartypants.es6.js",
  "jsnext:main": "smartypants.es6.js",
  ...
}
</code></pre>
<p>package.json 這樣寫，然後需要提供以下三個檔案：</p>
<pre><code class="language-sh">-rw-r--r--  1 othree  staff  21874 Jul 14 10:38 smartypants.es6.js
-rw-r--r--  1 othree  staff  24885 Jan  9 17:12 smartypants.js
-rw-r--r--  1 othree  staff  21874 Jul 14 10:38 smartypants.mjs
</code></pre>
<p>這段是我從 <a href="https://github.com/othree/smartypants.js">smartypants.js</a> 那邊拿來的，重點在：</p>
<ol>
<li><code>main</code> 裡面的檔名不寫副檔名，該檔名要同時提供 <code>js</code> 和 <code>mjs</code> 兩種</li>
<li>多加上 <code>module</code> 這筆設定</li>
</ol>
<p>說明一下，Node.js 現在判斷是哪種模組格式的方式是看副檔名，所以一定要 <code>mjs</code> 的檔案才會當成 ES module，然後剛好解析 <code>main</code> 檔案時的副檔名會自動補，所以就乾脆拿掉，同時提供 <code>smartypants.js</code> 和 <code>smartypants.mjs</code> 兩個檔案，其實都是 <code>main</code> 用的；再來是 <code>module</code> 這個設定和 Node.js 以及 NPM 無關，其實是 <a href="https://rollupjs.org/guide/en">rollup</a> 提出來的 <a href="https://github.com/rollup/rollup/wiki/pkg.module">pkg.module</a>，rollup 如果在解析模組實有看到這個設定，就可以把這個檔案拿來用，當時設計是這個設定 ES module，以前的 main 則是 CommonJS module，雖然是 rollup 提出的，不過 webpack 現在也支援了，範例中還有一筆 <code>jsnext:main</code> 則是比較早期用的 key。</p>
<p>再更進階一點，還有目標對象的問題，就是產出是瀏覽器用的還是 server 端用的，以前這問題不太常見，不過隨著 server side rendering 越來越普及，這問題就開始比較多人關注了，webpack 就有支援 bundle 的目標對象，也有支援 <a href="https://github.com/defunctzombie/package-browser-field-spec">pkg.browser</a> 設定，webpack 的 <a href="https://github.com/webpack/webpack/issues/5673">issue #5673</a> 有不少討論，有興趣的可以參考看看，不過要注意的是 <code>browser</code> 似乎是第一順位，設定的時候要小心點。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-ecmascript-2015-rel-of-features">
            <header>
              <time itemprop="datePublished dateModified" datetime="2018-09-17T00:28:27" id="date-2018-09-17">
                <span class="mon">09月</span>
                <span class="day">17日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2018/09/17/ecmascript-2015-rel-of-features/">ECMAScript 2015 新功能間的關係</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" class="thumbnail" href="https://www.flickr.com/photos/othree/29781972467/" title="ECMAScript 2015 by othree, on Flickr"><img itemprop="url image" src="https://farm2.staticflickr.com/1845/29781972467_06b6deb358_b.jpg" width="1024" height="622" alt="ECMAScript 2015, " srcset="https://farm2.staticflickr.com/1845/29781972467_06b6deb358_b.jpg 1024w, https://farm2.staticflickr.com/1845/29781972467_e79243c585_h.jpg 1600w"><meta itemprop="width" content="1024"/><meta itemprop="height" content="622"/></img></a></p>
<p>這篇想說的是 2015 年的那個 ECMAScript 6（後面簡稱 ES6），也就是之前 ECMAScript Harmony 計畫的主要成果，那版 ES6 其實是這幾年來改動最多的一版，新增了很多的新功能和語法，而這一堆新功能很多是環環相扣的，我以前曾經在 Facebook 上提過，不過那邊的東西容易就消失在網路上，所以還是另開一篇文章來記錄，剛好也可以做為下一篇文章的參考資料。</p>
<p>首先要從 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a> 這兩個新的資料型態說起，ECMAScript 一直以來都只有少少的資料型態，直到 ES6 才加了些新的，其中比較容易注意到的就是 Map 和 Set 了，其實這兩種資料型態以前就是直接用 object 來 array 來做，兩邊蠻接近的，最主要的差異則是 Map 的 key 可以是任意型態， 而以前 object 的 key 只能是字串，Set 是 unique 的，array 則否，另外就是在適合的情境下，現在 Map/Set 的效能不一定會比較差。</p>
<blockquote class="twitter-tweet" data-lang="zh-tw"><p lang="en" dir="ltr">???? Jest reduced their test runner time by 20% by switching from plain JavaScript objects to Maps where it made sense. <a href="https://t.co/ZrtgeJIwOU">https://t.co/ZrtgeJIwOU</a><br/><br/>In general, don't be afraid to use modern features! Focus on writing idiomatic code, and let JS engines worry about making it fast.</p> -- V8 (@v8js) <a href="https://twitter.com/v8js/status/1040219491358179328?ref_src=twsrc%5Etfw">2018年9月13日</a></blockquote>
<script async="async" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
<p>Map、Set 其實都算是 collection 的資料，所以會需要有個方法可以遍歷所有元素，像是 array 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">forEach</a> 或是 for...in 語法，不過 for...in 先拿到的東西是 key，還需要拿 key 去取元素實際的值：</p>
<pre><code class="language-javascript">for (let k in arr) {
  let v = arr[k];
}
</code></pre>
<p>一直以來，其實開發者社群都希望有個語法能直接取 collection 內的元素，所以像是 CoffeeScript 就是把 <code>for...in</code> 換成直接拿到 value，於是 ES6 就有了個 <code>for...of</code> 語法，可以遍歷 collection 類型的資料並直接取得值：</p>
<pre><code class="language-javascript">for (let v of arr) {
    
}
</code></pre>
<p>ES6 的這個語法，其實底層是透過 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iteration protocols</a> 這些內部協定來運作的，包括了 iterable protocol 和 iterator protocol，<code>for...of</code> 其實就是透過 iterable protocol 去拿物件的 iterator，利用 iterator 來遍歷元素，所以自己寫的物件也可以實做 iterable protocol，然後就可以讓該物件支援 <code>for...of</code> 語法了；除此之外，iterator 是不能重複使用的，所以其實每次 <code>for..of</code>，都是拿一個該物件的新的 iterator，而為了可以簡單產生這個 iterator，又有了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator function</a>，generator function 每次執行都會回傳一個新的 iterator（精確一點說是 generator object，同時是 iterator 也是 iterable），正好適合這個情境。</p>
<p>Iterable protocol 的定義其實很簡單，就是定義怎樣把 generator function 放在物件裡的方式，實際上是利用 ES6 另一個新的資料型態： <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> 來達成的，為什麼不直接定個屬性名稱給它呢？最主要就是不要讓這些內部 protocol 的東西在 <code>for...in</code> 操作的時候被遍歷到，所以定義了新的 Symbol 型別，利用它的特性來把內部 protocol 做了一定程度的保護，iterable protocol 就是把 generator function 用一個預先定義好的 Symbol 來儲存，這個 Symbol 又稱為 <code>Symbol.iterator</code>，這種預先定義好的 Symbol 則統稱為 Well-Known Symbols，ES6 其實定義了<a href="http://exploringjs.com/es6/ch_symbols.html#_well-known-symbols">好幾個</a>，不是只有 iterable 用的到，透過定義這些 Well-Known Symobls，可以介入改變一些 JavaScript 比較基礎的運作。</p>
<p>Well-Known Symobls 可以做到的事情，其實有點像是改變程式語言的運作，而這種類型的機制又稱為 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming">meta programming</a>，除了 Well-Known Symobls 之外，ES6 其實還提供了 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a>，這兩個東西應該比較多人知道 Proxy 是幹嘛的，對 Reflect 比較陌生，其實 Reflect 有點像是為了 JavaScript 一些設計不好的地方，想了解詳細一點推薦可以看主要的 polyfill [harmony-reflect][] 的 Wiki 頁：<a href="https://github.com/tvcutsem/harmony-reflect/wiki">Why should I use this library?</a></p>
<p>最後總結一下，這串從 Map/Set 開始，接著連到 <code>for...of</code> 語法、Iterator、Generator、Symbol、Well-Known Symobls 最後到 meta programming 的 Proxy 和 Reflect，其實也差不多佔了 1/4 的 ES6 新功能。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-eslint-plugin-pep8-blank-lines">
            <header>
              <time itemprop="datePublished dateModified" datetime="2018-09-08T10:24:24" id="date-2018-09-08">
                <span class="mon">09月</span>
                <span class="day">08日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2018/09/08/eslint-plugin-pep8-blank-lines/">eslint-plugin-pep8-blank-lines</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" class="thumbnail" href="https://www.flickr.com/photos/othree/43805736994/" title="eslint-plugin-pep8-blank-lines by othree, on Flickr"><img itemprop="url image" src="https://farm2.staticflickr.com/1855/43805736994_ed80198c0b_b.jpg" width="1024" height="768" alt="eslint-plugin-pep8-blank-lines, " srcset="https://farm2.staticflickr.com/1855/43805736994_ed80198c0b_b.jpg 1024w, https://farm2.staticflickr.com/1855/43805736994_84b2fc4977_h.jpg 1600w"><meta itemprop="width" content="1024"/><meta itemprop="height" content="768"/></img></a></p>
<p>我的第二個 ESLint plugin 終於進 beta 了，這是我自己期望很久的檢查規範，上一次介紹 ESLint plugin 的時候就有說到接下來想處理空行，其實 ESLint 內建的 rule 已經有蠻多是用來檢查空行的了，不過沒有一個能符合我想要的規範，我想要的規範其實很簡單，就是希望能在大一點的物件中間能多一點空行，比較有段落的感覺，這樣閱讀起來感覺也比較好（如上圖），剛好我這兩年寫了一點 Python，有用 Flake8 做語法檢查，其中的 <a href="https://www.python.org/dev/peps/pep-0008/#blank-lines">PEP8 coding style 中關於空行</a>的規範，就符合我想要的樣子，而且很簡單，這個規範是在大部分地方都允許最多一行空行，但是最上層（top level）的 function, class 前後要兩行空行。</p>
<p>於是這個 ESLint plugin 的主要目標，就是把 PEP8 這部分的規範搬過來，一開始想的實做方式有兩個，其一是參考 <a href="https://github.com/eslint/eslint/blob/master/lib/rules/padding-line-between-statements.js">padding-line-between-statements</a> 的作法，比較兩個相鄰 token/node 間的 line number，另一個則是用 <a href="https://eslint.org/docs/developer-guide/working-with-rules#contextgetsourcecode">sourceCode</a> 來一行一行看，不過同時也要知道該行的 context 是什麼才能判斷，所以也是跑不掉要進去看 AST，加上我想要玩玩看 JavaScript 的 AST，所以最終我是選擇第一種作法，不過不是用 ESLint 內建的 walker，而是在 <code>Program:exit</code> 的時候才用自己寫的 walker 進去看 AST；而經過一輪重構後，現在的架構其實是靈活度很高的，我實際上做出了一個比 padding-line-between-statements 還要更多功能的<a href="https://github.com/othree/eslint-plugin-pep8-blank-lines/blob/master/lib/guides/pep8.js">規範定義格式</a>，然後根據這個格式寫出我想要的空行規範，只是目前還沒開介面出來給使用者輸入自訂的空行規範就是了；其實我自己覺得這個 plugin 實做的理想型式應該還是要用實做方案二，並搭配使用 ESLint 的 AST walker，實際上  padding-line-between-statements 也就是這樣做，會這樣想最主要的原因是現在的實做只看 AST，但是 AST 其實不能 100% 表達原來的程式碼，這也是這次開發經驗中我最大的體悟，所以其實一些奇怪地方的空行就會很難抓到，例如 <code>await 1</code> 這兩個 token 中間如果有空行就會跳過，不過會在這種地方放空行的情形應該都是蠻少見的，所以目前也沒打算繼續改下去，短期內都會以處理 bug 為主，過陣子應該會試著加上 fix 的功能，總之歡迎測試並回報問題，雖然有寫測試，不過還沒什麼實際跑在真實的程式碼上，目前唯一的就是它自己的 code base 本身是有用吧，另外就是使用時如果是搭配其它 style 可能會需要把其它 style 的空行規則關掉，例如搭配 <a href="https://standardjs.com/">standardjs</a> 時的 <code>.eslintrc</code> 範例：</p>
<pre><code class="language-json">{
  "extends": "standard",
 
  "plugins": [
    "pep8-blank-lines",
    "no-parameter-e"
  ],
 
  "rules": {
    "semi": [2, "always"],
    "no-extra-semi": 2,
    "comma-dangle": ["error", "always-multiline"],
    "no-multiple-empty-lines": 0,
    "pep8-blank-lines/pep8-blank-lines": 2,
    "no-parameter-e/no-parameter-e": 2
  }
}
</code></pre>
<p>這組其實也是我目前在用的設定啦～</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-tern-022-released">
            <header>
              <time itemprop="datePublished dateModified" datetime="2018-09-02T17:41:32" id="date-2018-09-02">
                <span class="mon">09月</span>
                <span class="day">02日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2018/09/02/tern-022-released/">Tern 0.22 released</a>
              </h3>
            </header>
            <section itemprop="articleBody"><blockquote class="twitter-tweet" data-lang="zh-tw"><p lang="en" dir="ltr">First Tern release in a year and a half today <a href="https://t.co/1Ws7zYEJSd">https://t.co/1Ws7zYEJSd</a> . All thanks to <a href="https://twitter.com/othree?ref_src=twsrc%5Etfw">@othree</a> picking up maintenance!</p>--	 Marijn Haverbeke (@MarijnJH) <a href="https://twitter.com/MarijnJH/status/1034328203026984961?ref_src=twsrc%5Etfw">2018年8月28日</a></blockquote>
<script async="async" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
<p>大約七月初的時候，我開始接手幫忙維護 <a href="http://ternjs.net/">Tern</a>，Tern 是一個獨立的 JavaScript inference engine，用於協助撰寫 JavaScript 程式碼，就和之前介紹過的 Microsoft 的 LSP 後面的 Language Server 一樣，都是獨立於編輯器/IDE之外，不過 TernJS 是 2013 年就有開始發展的，所以是走自己的溝通介面；其實我幾年前也有幫忙貢獻過 TernJS，以前弄過我還有印象的有 Promise 支援、fetch 的定義、CoffeeScript plugin。</p>
<p>後來作者 <a href="https://github.com/marijnh">Marijn</a>暫停維護 Tern 跑去弄其他東西像是 <a href="https://github.com/acornjs/acorn">Acorn</a>、<a href="https://codemirror.net/">CodeMirror</a> 還有 ProseMirror 等（這位很厲害，改天再來介紹），並公開找人接手，在一些文字內有找到他的說法是說現在這個架構有些問題處理不了，很難再發展下去了，總之所以就停了一年多沒更新了，我也是斷斷續續注意到這個狀況，不過在研究 LSP 的時候發現其實還蠻多東西是依賴 TernJS 的，讓他這樣荒廢下去好像有點可惜，認真考慮了一兩週後決定接手維護工作，考慮的點主要在於不知道能不能順利接手處理問題，因為 TernJS 的 code base 實在不容易理解，尤其是我沒有相關的 compiler、工具的訓練和開發經驗，以前那些貢獻其實都是花很大心力下去才弄出來的，幾乎是處於那種「程式碼會動了，但是我不知道為什麼」的狀態，不過這兩年相關的知識補了不少，還玩了好一陣子的 JavaScript AST，有覺得比較看的懂 TernJS 的程式碼了，就心一橫報名說要幫忙維護了，Marijn 看到我過去有發過一些 PR 後，很迅速的就開協作者權限給我了。</p>
<p>正式開始接手後，我就開始把要做的事情整理出來，我的目標是在保持現有架構之下，盡可能的繼續支援新語法，直到真的這個架構撐不住為止，所以一開始就是把一些落後的語法支援和定義補上，這次發佈的 <a href="http://ternjs.net/#releases">0.22 版</a>就是包括 0.21 之後的一些小 bugfix，還有我加入之後開始弄的 async/await、async iteration(包括 <code>for await of</code>) 以及 <code>**</code> 支援，下一版我會開始一些內部的修改、還有看看 bug，不過 Emacs 相關的我現在是真的無法處理。</p>
<p>最後一段來說說目前感想吧，Tern 真是我目前為止看過最難理解的 code 了，不知道是不是會寫 compiler 的人腦袋都會轉換到常人無法理解的形狀，我目前為止看的第二辛苦的 code base 是 Kibana 的，不過 Kibana 單純只是東西很多，找入口找很久，Tern 難的點在於它用了很多 side effect 來做事，而且 code 內沒什麼文件說明，所以像下面這行我就花了很多時間才看懂實際上做什麼事：</p>
<pre><code class="language-js">infer(node.right, scope, new HasMethodCall(":Symbol.iterator", [], null,
                                           new HasMethodCall("next", [], null,
                                                             new GetProp("value", target))))
</code></pre>
<p>這行程式碼是先拿 <code>node.right</code> 的 <code>:Symbol.iterator</code> method 的執行結果，再看它的 <code>next</code> method 的執行結果，然後取最後這個結果的 <code>value</code> property 的資訊（可能的 type 之類的）塞給 target 物件，然後這行下面你又看不到 target 做何用，因為 target 物件是在上面已經有和其它會回傳的物件有建立關聯的；除此之外，這裡有個 <code>new GetProp</code>，其它地方還有個 <code>AVal.getProp</code> 又是不同功能，一開始看的真的是黑人問號...</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <article itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" id="entry-naming-1">
            <header>
              <time itemprop="datePublished dateModified" datetime="2018-07-21T23:12:15" id="date-2018-07-21">
                <span class="mon">07月</span>
                <span class="day">21日</span>
              </time>
              <h3 itemprop="name headline">
                <a href="/log/2018/07/21/naming-1/">命名記錄 1</a>
              </h3>
            </header>
            <section itemprop="articleBody"><p><a itemprop="image" itemscope="itemscope" itemtype="http://schema.org/ImageObject" title="By Thorin Oakenshield II [CC BY-SA 4.0  (https://creativecommons.org/licenses/by-sa/4.0 )], from Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:%D0%9A%D0%B0%D1%80%D1%82%D0%B0_%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D0%BA%D0%BE%D0%B9_%D0%93%D0%BE%D1%80%D1%8B_.jpg"><img itemprop="url image" width="512" alt="Карта Одинокой Горы " src="https://upload.wikimedia.org/wikipedia/commons/b/b3/%D0%9A%D0%B0%D1%80%D1%82%D0%B0_%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D0%BA%D0%BE%D0%B9_%D0%93%D0%BE%D1%80%D1%8B_.jpg"><meta itemprop="width" content="512"/><meta itemprop="height" content=""/></img></a></p>
<p>記錄一下這兩年自己覺得還不錯的命名，本來是想累積更多再貼的。</p>
<h4>Herculus</h4>
<p><a href="https://zh.wikipedia.org/zh-tw/%E8%B5%AB%E6%8B%89%E5%85%8B%E5%8B%92%E6%96%AF">海克力士</a>，用在測試服務名稱上，是希臘神話中的大力士，曾經完成十二偉業，這兩年還有部電影，取名源由其實是 Fate/stay night 中，他做為 Berserk 的 Servant 所持有的寶具，稱為 <strong>十二の試練</strong>，試練就聯想到 test ～</p>
<h4>Erebor</h4>
<p>用在資料庫相關的服務，哈比人歷險記的<a href="https://en.wikipedia.org/wiki/Lonely_Mountain">孤山</a>的精靈語，因為孤山裡面有很多矮人的寶物，資料庫內的資料某種層面來說也算是個寶物。</p>
<h4>Olympus</h4>
<p>應該不用介紹來源了，用在 client 端自己寫的 API helper，取這個名字的原因是覺的客戶端跟 server 端要資料就如同在跟眾神請求一樣。</p>
</section>
            <footer>
              <a href="/log/script/" rel="tag">SCRIPT</a>
            </footer>
          </article>
          <hr/>
          <a id="prev-link" href="/log/script/all/" class="center">此類別所有文章</a>
        </main>
        <aside role="complementary" class="pure-u-1 pure-u-lg-1-4">
          <hr/>
          <h2>其它資訊</h2>
          <form method="get" id="search-form" class="form-search" action="https://duckduckgo.com/" role="search">
            <input accesskey="4" id="search-input" type="search" name="q" size="20" tabindex="8" aria-label="搜尋" placeholder="搜尋" required="required" aria-required="true" class="search-query input-medium"/>
            <input type="hidden" name="sites" value="blog.othree.net"/>
          </form>
          <hr/>
          <div role="contentinfo"> </div>
          <h3>關於本網誌</h3>
          <address itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person">
            <p class="vcard">本網誌是<a itemprop="name" href="https://twitter.com/othree" class="fn nickname" rel="me">othree</a>的個人部落格，主要內容為網路標準、網頁設計，穿插些ACG心得和敗家紀錄，更詳細的資訊請見<a href="http://blog.othree.net/about/here/">關於這</a>，如要聯絡我請寄信到 <a itemprop="email" href="mailto:othree@gmail.com" class="email">othree@gmail.com</a></p>
          </address>
          <h3>分類彙整</h3>
          <ul>
            <li><a href="/log/about/">關於這裡</a> <span>(43)</span></li>
            <li><a href="/log/acg/">動畫、漫畫、遊戲</a> <span>(40)</span></li>
            <li><a href="/log/books/">與書相關</a> <span>(38)</span></li>
            <li><a href="/log/buy/">敗家</a> <span>(51)</span></li>
            <li><a href="/log/css-html/">CSS &amp; HTML</a> <span>(109)</span></li>
            <li><a href="/log/diary/">日記</a> <span>(132)</span></li>
            <li><a href="/log/mac/">蘋果蘋果</a> <span>(17)</span></li>
            <li><a href="/log/others/">其他</a> <span>(23)</span></li>
            <li><a href="/log/script/">SCRIPT</a> <span>(147)</span></li>
            <li><a href="/log/server/">Server Side</a> <span>(16)</span></li>
            <li><a href="/log/software/">軟體推薦、TIP</a> <span>(82)</span></li>
            <li><a href="/log/unix/">UNIX</a> <span>(20)</span></li>
            <li><a href="/log/vim/">VIM</a> <span>(46)</span></li>
            <li><a href="/log/web/">Web</a> <span>(201)</span></li>
          </ul>
          <h3>訂閱本網誌</h3>
          <ul id="feeds">
            <li>
              <a href="https://feeds.feedburner.com/othree">
                    FeedBurner
                  </a>
            </li>
          </ul>
          <h3>貼紙</h3>
          <p id="stickers">
            <a href="https://sites.google.com/site/happybusy/">
              <img src="/images/busy_banner.png" width="200" height="40" alt="時間がない"/>
            </a>
            <a href="https://developer.mozilla.org/en/JavaScript" title="JavaScript Reference, JavaScript Guide, JavaScript API, JS API, JS Guide, JS Reference, Learn JS, JS Documentation">
              <img src="/images/240x480-1.2v2.png" height="240" width="120" alt="JavaScript Reference, JavaScript Guide, JavaScript API, JS API, JS Guide, JS Reference, Learn JS, JS Documentation"/>
            </a>
          </p>
        </aside>
      </div>
      <footer class="pure-g">
        <h2 class="pure-u-1">使用技術、規範、服務</h2>
        <p class="pure-u-1">
          <a href="http://creativecommons.org/licenses/by/4.0/deed.zh_TW">CC BY 4.0</a>
          <a itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization" href="https://othree.net">
            <span itemprop="name">othree.net</span>
            <span itemprop="logo" itemscope="itemscope" itemtype="http://schema.org/ImageObject">
              <link itemprop="url image" content="https://blog.othree.net/images/logo-amp-google.png"/>
              <meta itemprop="width" content="600"/>
              <meta itemprop="height" content="60"/>
            </span>
          </a>
        </p>
      </footer>
    </div>
    <script async="async" src="/scripts/all.js"/>
    <script async="async" src="/scripts/prism.js"/>
  </body>
</html>
