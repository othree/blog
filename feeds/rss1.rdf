<?xml version="1.0" encoding="utf-8"?>

<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:admin="http://webns.net/mvcb/"
xmlns:cc="http://web.resource.org/cc/"
xmlns="http://purl.org/rss/1.0/">

<channel rdf:about="https://blog.othree.net/">
<title>O3noBLOG</title>
<link>https://blog.othree.net/</link>
<description></description>
<dc:creator></dc:creator>
<dc:date>2016-11-18T00:00:52+08:00</dc:date>
<admin:generatorAgent rdf:resource="http://www.movabletype.org/?v=4.381" />

<cc:license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/1.0/" />


<items>
<rdf:Seq>
<rdf:li rdf:resource="https://blog.othree.net/log/2016/11/18/20k-for-of/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/10/29/vim-filename-complete/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/10/17/sbb-mobile/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/10/14/acclerated-mobile-pages/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/10/03/native-true-color-vim/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/09/21/safari-10/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/09/17/git-mrt/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/09/11/input-event/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/08/25/modern-html-email-develop/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/08/13/json-web-token/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/16/hkoscon-2016/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/14/web-push/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/04/22/nginx-fcgiwrap/" />
</rdf:Seq>
</items>

</channel>


<item rdf:about="https://blog.othree.net/log/2016/11/18/20k-for-of/">
<title>20K for...of</title>
<link>https://blog.othree.net/log/2016/11/18/20k-for-of/</link>
<description><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a> 是 ECMAScript 2016 的新語法，有了他之後，要用迴圈跑過陣列不用像以前一樣先用 <code>for...in</code> 或是用傳統的取長度，然後 <code>i++</code> 的方法：</p>

<pre><code>var arr = [1, 2, 3];
var i, v, len;

for (i in arr) {
    v = arr[i];
    console.log(v);
}

for (i = 0, len = arr.length; i &lt; len; i++) {
    v = arr[i];
    console.log(v);
}
</code></pre>

<p>現在只要用簡單的 <code>for...of</code> 就可以了：</p>

<pre><code>var arr = [1, 2, 3];

for (let v of arr) {
    console.log(v);
}
</code></pre>

<p>不過目前還是需要考慮只有 ECMAScript 5 的環境，例如 IE11，所以一般都還是會用像是 <a href="https://babeljs.io/">Babel</a> 之類的 transpiler 來把 ES2015 的 syntax 轉成 ES5 的 code，結果轉出來如下：</p>

<pre><code>"use strict";

var arr = [1, 2, 3];

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
    for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;

        console.log(v);
    }
} catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
} finally {
    try {
        if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
            _iterator.return();
        }
    } finally {
        if (_didIteratorError) {
            throw _iteratorError;
        }
    }
}
</code></pre>

<p>結果其實有點意外，一個簡單的 <code>for...of</code> 竟然變的這麼長，事實上是因為 <code>for...of</code> 其實沒想像中簡單，因為它可以用的地方其實不只是陣列，而是 <a href="https://blog.othree.net/log/2014/05/24/es6-iterable/">iterable 物件</a>，不過為了要完整的支援 <code>for...of</code>，就變成需要有 iterator, generator, symbol 等等的支援，當然上面的程式碼不能在 ES5 環境下執行，而 Babel 依靠的是 <a href="https://babeljs.io/docs/usage/polyfill/">babel-polyfill</a>，裡面其實就是 <a href="https://github.com/zloirock/core-js">core-js</a> 和 <a href="https://facebook.github.io/regenerator/">regenerator</a>，不過這一整包，其實有點龐大，要 228KB，即使最小化之後也還要 95KB，所以，就想著是不是能夠只捆包進需要的部分就好了，研究過後，發現有 Babel plugin 叫做 <a href="https://babeljs.io/docs/plugins/transform-runtime/">transform-runtime</a>，套用上去後：</p>

<pre><code>import _getIterator from "babel-runtime/core-js/get-iterator";
var arr = [1, 2, 3];

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = _getIterator(arr), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var v = _step.value;

    console.log(v);
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}
</code></pre>

<p>可以看到原來用 <code>Symbol</code> 取 iterator 的地方變成用 <code>_getIterator</code> 了，而且還有一行：</p>

<pre><code>import _getIterator from "babel-runtime/core-js/get-iterator";
</code></pre>

<p>如果要真的把這部分也打包進來，則需要讓 bundler 處理，我個人是偏好 <a href="http://rollupjs.org/">rollup</a>，搭配以下兩個 plugin：</p>

<ul>
<li><a href="https://github.com/rollup/rollup-plugin-node-resolve">rollup-plugin-node-resolve</a> 用來尋找 <code>node_modules</code> 目錄裡的模組</li>
<li><a href="https://github.com/rollup/rollup-plugin-commonjs">rollup-plugin-commonjs</a> 用來解析 CommonJS 型式的模組</li>
</ul>

<p>然後用以下的設定：</p>

<pre><code>babel({
  exclude: 'node_modules/**',
  plugins: ['transform-runtime'],
  presets: ['es2015-loose-rollup'],
  runtimeHelpers: true
}),
nodeResolve({ jsnext: true }),
commonjs({
  include: 'node_modules/**'
})
</code></pre>

<p>結果，就可以得到夢寐以求的 20KB 的<a href="https://github.com/othree/20k-for-of/blob/master/out/bundle-all.js">程式碼</a>了，當然 20KB 的部分不是預期的啦，相較於一開始的程式碼只有 72Bytes，為了一個 <code>for...of</code> 變成 20KB 好像有點本末倒置，畢竟我只有要在 Array 上用，難道不能只是簡單的轉成 <code>for...in</code> 型式嗎。</p>

<p>事實上是有辦法的，第一個就是改寫 <a href="https://www.typescriptlang.org/">TypeScript</a>，TypeScript 對於 <code>for...of</code> 只有兩種處理方法，而且結果都不會如此膨脹，第一種就是變成 <code>for...in</code>，第二種則是不變動，保留 <code>for...of</code> 的語法，後者是在 target 設定成 ES6 的時候使用的，官網也有相關的<a href="https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html#targeting-es5-and-es3">說明</a>。</p>

<p>第二種方法則是用 <a href="https://buble.surge.sh/">Bublé</a> 取代 Babel 做為 transpiler，Bublé 是 rollup 的作者 <a href="http://www.rich-harris.co.uk/">Rich Harris</a> 的另外一個作品，我個人是蠻喜歡他的哲學的，Bublé 的哲學則是對於 code 做簡單、直接明瞭的轉換，所以 <code>for...of</code> 就只會轉成 <code>for...in</code> 的型式，不過也因此無法支援 iterable 物件，所以預設是不開啟支援的，歸類在 <a href="https://buble.surge.sh/guide/#dangerous-transforms">dangerious transofrm 之下</a>，另外 Bublé 也還不支援 Async/Await，因為要做出支援 ES3/5 的同樣效果的 code 會增加太多的<a href="https://gitlab.com/Rich-Harris/buble/issues/71">複雜度</a>，不符合他的哲學理念，所以目前還沒有計畫支援，這點倒是 TypeScript 支援比較完整，目前的 <a href="https://github.com/Microsoft/TypeScript/wiki/Roadmap#21-november-2016">2.1 RC</a> 已經支援把 Async/Await 轉成 ES3/5 的版本了。</p>

<p>最後結論，基本上就是個取捨，Babel、TypeScript、Bublé 各自有它們的優缺點，所以只能看情況選擇了，如果要 Map/Set 也要在這些物件上用 <code>for...of</code> 語法然後也要 Async/Await，那就只能用 Babel 加上 babel-polyfill；如果可以不要 Map, Set 或是可以接受不在這些物件上使用 <code>for...of</code> 語法（還可以用 forEach），那可以選擇 TypeScript，然後加上 Map/Set 的 polyfill，如果不用 Async/Await，也不用 Map/Set 的話，可以考慮用個 Bublé 看看。不過如果完全不需要考慮 ES3/5 的環境的話（Edge, Firefox, Chrome 都已經對 ES2015 支援很完整了），好像問題突然就小很多了XD，最後附上這篇文章提到的各種作法產生的檔案參考，目前都放在 github 上的 <a href="https://github.com/othree/20k-for-of/">20k-for-of</a> 這個專案。</p>
]]></description>
<dc:subject>script</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-11-18T00:00:52+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/10/29/vim-filename-complete/">
<title>Vim Filename Complete</title>
<link>https://blog.othree.net/log/2016/10/29/vim-filename-complete/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/30545367351/" title="Vim Filename Complete by othree, on Flickr"><img src="https://farm6.staticflickr.com/5750/30545367351_b09ec693f5_b.jpg" width="659" height="452" alt="Vim Filename Complete, " srcset="https://farm6.staticflickr.com/5750/30545367351_b09ec693f5_b.jpg 1024w" /></a></p>

<p>Vim 有一個內建的自動補完功能是針對<a href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-filename">檔案名稱</a>的，使用的方法是 <code>&lt;C-X&gt;&lt;C-F&gt;</code>，我目前在維護的 <a href="https://github.com/othree/vim-autocomplpop">autocomplpop</a> 也有支援這種補完模式，只要輸入 <code>./</code> 後就會自動幫忙觸發，不過我比較有機會觸發到是在使用 ECMAScript 6 的 import 和 CSS 的 import 時，不過常常就是發現他查看的路徑不太對，不是拿目前編輯檔案的位置做為起點的，研究過後發現是因為 Vim 找檔案的起點是看他的工作目錄(<code>$PWD</code>)，加上我會使用 <a href="https://github.com/kien/ctrlp.vim">ctrlp</a> 這種工具，所以實際上在編輯的檔案通常是不在工作目錄下，對於這個問題，其實我覺得最理想的解決方式是 Vim 應該要提供兩種模式來決定要從那邊開始找，不過目前似乎沒這個計畫，唯一在文件是有提到的是未來可能會支援 <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27path%27"><code>path</code></a> 的設定，理論上，如果有支援的話，應該就可以解決問題了，因為預設的 <code>path</code> 值包括了 <code>.</code>，不過目前還沒有相關時程，就只能自救了。</p>

<p>最簡單的方法，其實就是開啟 <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27autochdir%27"><code>autochdir</code></a>，這個選項打開後就會自動在切換 window 時也更改工作目錄，不過這個選項是為了相容早期系統才提供的，文件也有說可能會和部分 Vim Script 不相容，實際上我也有找到一些不相容的 Vim Script，所以想避免，就搜尋了一下其它可能的解決方法，在 StackOverflow 上有看到<a href="http://superuser.com/questions/604122/vim-file-name-completion-relative-to-current-file">一篇</a>，裡面有兩個人提供了解法，第一個是用 <code>autocmd</code>，然後在進入 insert mode (在這時候才有機會用到檔名補完的功能)時自動開啟 <code>autochdir</code>，離開時自動關閉 <code>autochdir</code>，不過這樣的方式（感覺上）還是不太安全，因為還是用到 <code>autochdir</code>，所以下面有另外一個方法改用 <a href="http://vimdoc.sourceforge.net/htmldoc/editing.html#:lcd"><code>lcd</code></a>，作法是改成修改 Key Mapping 的方式，改的 mapping 是 <code>./&lt;C-X&gt;&lt;C-F&gt;</code>，不過這樣對我來說又不合用，因為我用 autocomplpop 的話，不會真的打 <code>&lt;C-X&gt;&lt;C-F&gt;</code>，所以基本上觸發不到這事件，所以我就決定把這兩種解法合併起來，改成用 <code>autocmd</code> 加上 <code>lcd</code>：</p>

<pre><code>:autocmd InsertEnter * let save_cwd = getcwd() | execute 'lcd %:p:h'
:autocmd InsertLeave * execute 'lcd' fnameescape(save_cwd)
</code></pre>

<p>進入 insert mode 時改變該 window 的工作目錄，離開 insert mode 時把工作目錄還原。這是我目前認為影響最小的調整方式，不過其實可能執行一次 <code>lcd</code> 換工作目錄就夠了，沒深入研究 autochdir 所產生的問題，不過我推測是影響到 Vim Script 建立的 window 的工作目錄，像是 NERD Tree 之類的側邊欄那種，總之目前這樣運作還算正常，接下來就是等 Vim 加上 <code>path</code> 的支援吧（或是有人送 patch）。</p>
]]></description>
<dc:subject>vim</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-10-29T15:36:02+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/10/17/sbb-mobile/">
<title>SBB Mobile</title>
<link>https://blog.othree.net/log/2016/10/17/sbb-mobile/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/30359519555/" title="SBB Mobile by othree, on Flickr"><img src="https://farm6.staticflickr.com/5656/30359519555_a5d6568752_b.jpg" width="360" height="640" alt="SBB Mobile, " srcset="https://farm6.staticflickr.com/5656/30359519555_a5d6568752_b.jpg 576w, https://farm6.staticflickr.com/5656/30359519555_cca63b01fe_h.jpg 900w" /></a></p>

<p>之前去瑞士的時候，主要的交通工具是靠火車，所以就下載了瑞士國鐵的 Android App：<a href="https://www.sbb.ch/en/timetable/mobile-timetables/sbb-mobile.html?WT.ac=sbb-mobile-weitere-en.html">SBB Mobile</a>，用過後覺得真是很棒，首先上面的畫面就是一開始進去看到的，很直接了當的就是最重要的功能，查詢路線和時間，畫面很乾淨，就是起點、目的地、出發或到達時間，還可以加上中間站，而且時間會自動更新到現在時間，然後隨便查一下就可以看到下面的畫面：</p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-10-17T22:51:45+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/10/14/acclerated-mobile-pages/">
<title>Acclerated Mobile Pages</title>
<link>https://blog.othree.net/log/2016/10/14/acclerated-mobile-pages/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/23867356862/" title="O2 DAC + AMP by othree, on Flickr"><img src="https://farm2.staticflickr.com/1704/23867356862_071e6b9bb2_b.jpg" width="1024" height="683" alt="O2 DAC + AMP, " srcset="https://farm2.staticflickr.com/1704/23867356862_071e6b9bb2_b.jpg 1024w, https://farm2.staticflickr.com/1704/23867356862_a16568cdac_h.jpg 1600w" /></a></p>

<p><a href="https://www.ampproject.org/">Acclerated Mobile Pages</a> 簡稱 AMP，是 Google 所推出，為了提升行動網路體驗的一個專案，我一開始對於這種（看似）偏離網路標準的方案其實不太有興趣，不過在瞭解其技術原理後，覺得相當有趣，而且其實沒有想像中的偏離標準，整個架構也比 Facebook 的 Instant Article 還要來的開放，雖然我覺得這個解決方案（只說是 Framework 或是 Library 都不夠完整），其實只算是個暫時的解法，但是 AMP 本身的實做方式，其實是架構在一堆網路標準的發展之上的，相當出人意料，可以說是 <a href="https://extensiblewebmanifesto.org/">Extensible Web 宣言</a>以來，第一個重要的里程碑。</p>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-10-14T22:14:08+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/10/03/native-true-color-vim/">
<title>Native True Color Vim</title>
<link>https://blog.othree.net/log/2016/10/03/native-true-color-vim/</link>
<description><![CDATA[<p>因為最近 Vim 8 發佈了，所以就又研究一下現在最新的 True Color Vim 安裝方法，結果發現已經併進 master branch 許久了，然後從 <a href="https://github.com/vim/vim/commit/8e9eb3a6a1e589949f1c878c839528d917fdfc4a">7.4.1784</a> 開始，也不用加特別參數來編譯，只要 <code>--with-features</code> 的值是 <code>big</code> 或是更大的 <code>huge</code> 就會把這功能編譯進去，所以現在就不用 ZyX 維護的版本了，目前用的編譯指令為：</p>

<pre><code>git clone https://github.com/vim/vim.git

cd vim
cd src &amp;&amp; make autoconf &amp;&amp; cd ..

./configure \
  --enable-gui=no \
  --without-x \
  --enable-multibyte \
  --with-tlib=ncurses \
  --enable-cscope \
  --with-features=huge \
  --disable-nls \
  --enable-perlinterp \
  --enable-pythoninterp \
  --enable-rubyinterp

make
make install
</code></pre>

<p>然後現在也不需要 <code>guicolors</code> 的設定，好像直接就生效了，顏色畫出來和之前的 ZyX 的版本似乎有一點差異，我想應該現在新的版本是比較正確才是。追蹤這功能追了這麼久，總算也是告一段落了，感覺...好像也沒什麼特別的感覺...</p>
]]></description>
<dc:subject>vim</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-10-03T23:44:12+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/09/21/safari-10/">
<title>Safari 10 for Developer</title>
<link>https://blog.othree.net/log/2016/09/21/safari-10/</link>
<description><![CDATA[<p>Safari 10 跟著 macOS 一起出來了，這次更新了不少東西（對於網頁開發者來說），Apple 也依舊放了一份<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html">文件</a>在他們的 Developer Library 裡面，以下列出我覺得比較有趣的：</p>

<h4>CSP 2.0</h4>

<p>CSP 2.0 和之前的版本相比，最主要是多了非常多可以控制的權限，也有幾個名稱有改掉，不過基本上格式是相容的。</p>

<h4>Shadow DOM</h4>

<p>Shadow DOM 1.0 標準，這也讓 Web Component 的理想又往前賣進一步了。</p>

<h4>ES 6</h4>

<p>號稱支援度 100%，看起來是依據 <a href="http://kangax.github.io/compat-table/es6/#safari10">ECMAScript compatable table</a> 的，不過在 module 的面前，還沒有真的 100% 的啊，另外主流瀏覽器其實支援度都蠻高了，之前 Edge 還放話說領先的，沒想到現在就已經被 Safari 10 和 Chrome 超過了，而 Chrome 看來也之差 tail call 而已，接下來應該又要開始效能比拼了吧。</p>

<h4>Inline and Auto Video Playback in iOS</h4>

<p>這也是等很久的功能，之前就有先開放靜音影片能直接在 iOS Safari 上自動播放，主要的考量是，gif 和 mp4 相比，還是 gif 比較吃資源啊。</p>

<h4>ES Internationalization</h4>

<p>ECMA-402 支援，這也是希望快點普及的東西啊，不然數字、日期什麼的搞本地化實在很麻煩。</p>

<h4>WOFF 2.0 Support</h4>

<p>令人意外的有點慢，不過還算很有誠意的把很新的 <a href="https://drafts.csswg.org/css-font-loading/">CSS Font Loading Module Level 3</a> 的 API 做好了。</p>

<h4>#RRGGBBAA</h4>

<p>新的 CSS color 格式，也是前陣子才 propose 出來而已，這樣以後就可以讓 CSS 裡的顏色格式統一點了。</p>

<h4>Right-to-Left Language Support</h4>

<p>主要是 RTL 頁面 scrollbar 的位置終於會換邊了。</p>

<h4>Media Query for Wide Color Gamut Support</h4>

<p>廣色域的 CSS media query，主要是因為最新的 iMac 和 iPhone 7 都有支援 P3 色域了。</p>

<h4>WebDriver Support</h4>

<p>主流瀏覽器最後一個支援的...</p>

<h4>Apple Pay for the Web</h4>

<p>這真的蠻兇狠的，不過 Google 也有在 Android 做類似的<a href="https://android.googleblog.com/2016/09/tap-pay-yes-android-pay-welcomes-chase.html">事</a>就是了。</p>

<p>大概就這些了，其實也列出超過一半的項目了，Safari 這種更新頻率其實比起其它幾家來說吃虧不少，不過還是一直有跟上最新進度，其實也蠻厲害的，更何況現在 Google 都把人拉到 Blink 去，有回到 Webkit 的貢獻似乎比例上不高。</p>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-09-21T23:57:08+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/09/17/git-mrt/">
<title>MRT &amp; GIT</title>
<link>https://blog.othree.net/log/2016/09/17/git-mrt/</link>
<description><![CDATA[<script async="async" class="speakerdeck-embed" data-id="a6c9e72eb4b44e16b5862fc3e7c84153" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>

<p>今年 COSCUP Lightening Talk 分享的主題是 GIT &amp; MRT，主題就是紀錄我之前用 GIT 線圖畫台北捷運路線圖的過程，投影片在上面，這篇文章是補充一下被省略的部分和講不完的部分，當天我有用 Ricoh Theta 錄影，也丟上 YouTube 了：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/OBadluXaJi8?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
]]></description>
<dc:subject>software</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-09-17T11:41:49+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/09/11/input-event/">
<title>Input Event</title>
<link>https://blog.othree.net/log/2016/09/11/input-event/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/acerriteno/4111105424/" title="Playtime Credit Card by Alberto+Cerriteño, on Flickr"><img src="https://farm3.staticflickr.com/2487/4111105424_0fbd64cbd9_z.jpg?zz=1" width="640" height="427" alt="Playtime Credit Card, " srcset="https://farm3.staticflickr.com/2487/4111105424_0fbd64cbd9_z.jpg?zz=1 640w" /></a></p>

<p>今天做了一個特殊的 input 欄位，其實目標只是做成類似像輸入信用卡號那樣，輸入 <code>1234</code> 完，準備要輸入 <code>5</code> 的時候，會在 <code>4</code> 後面補上一個 <code>-</code>，變成 <code>1234-5</code>，不過我預期做的完美一點，所以考慮了很多狀況，例如：</p>

<ul>
<li>複製貼上沒有 <code>-</code> 的資料後會自動格式化</li>
<li>已經輸入一部分資料後，游標移到前面插入資料也會正確格式化</li>
<li>直接用 <code>DEL</code> 或 <code>Backspace</code> 來刪除資料，要讓使用者感覺不到 <code>-</code></li>
<li>先選取一些字元然後用 <code>DEL</code> 或 <code>Backspace</code> 甚至是剪下來刪除資料後會重新格式化</li>
<li>以上幾種操作都不會讓游標亂跳</li>
</ul>

<p>簡單看過目前一些信用卡相關的 library，在卡號輸入的部分是沒有全部達到的，要達成這些目標，幾乎是等於每個使用者的操作都要攔截下來，然後要抓到當欄位內的值，會用到的事件包括了 keyup、keydown、paste 和 input，等，其中本來我對於一般使用者敲打鍵盤輸入的事件是用 keyup，keyup 事件後會判斷游標位置和輸入的內容，如果需要的話就加上 <code>-</code>，然後調整游標位置，通常是 +1，弄好後測試一陣，發現如果按鍵輸入很快的話，游標位置會亂掉，應該要 +1 的卻錯過了，深入除錯一陣子之後發現，keyup 事件其實和欄位內的 value 變更是非同步的，所以不能確保 keyup 事件拿到的欄位值是正確的，能確保欄位值正確的，其實是 <a href="https://developer.mozilla.org/zh-TW/docs/Web/Events/input">input 事件</a>，不過 input 事件沒有 keyCode，所以只能自己判斷輸入了什麼，另外刪除內容時也不會觸發 input，還好 <code>DEL</code> 和 <code>Backspace</code> 是用 keydown 事件來處理，兩邊剛好錯開了。</p>

<p>雖然 input 事件似乎很好用，不過其實它在早期的時候支援度是不太好的，算是比較新的事件，有類似狀況的還有一個是 change 事件，我的印象中是某些瀏覽器的行為會不太正確，所以其實我一直都還不太使用，至於 input 事件，我則是需要在不支援的瀏覽器中 fallback 到 keyup 事件，所以就會需要偵測，找了一下在 Modernizr 有<a href="https://github.com/Modernizr/Modernizr/blob/master/feature-detects/event/oninput.js">支援</a>，仔細看一下內容其實可以發現不是很好偵測，然後我也不是很喜歡 Modernizr 的介面，所以目前用的是在 Modernizr <a href="https://github.com/modernizr/modernizr/issues/210#issuecomment-1325576">Issue 210</a> 裡面 AndyE 提供的版本，稍微精簡一些：</p>

<pre><code>var inputSupport = "oninput" in document.body || checkEvent(document.body);
/*
   The following function tests an element for oninput support in Firefox.  Many thanks to
        http://blog.danielfriesen.name/2010/02/16/html5-browser-maze-oninput-support/
*/
function checkEvent(el) {
    // First check, for if Firefox fixes its issue with el.oninput = function
    el.setAttribute("oninput", "return");
    if (typeof el.oninput == "function")
        return true;

    // Second check, because Firefox doesn't map oninput attribute to oninput property
    try {
        var e  = document.createEvent("KeyboardEvent"),
            ok = false,
            tester = function(e) {
                ok = true;
                e.preventDefault();
                e.stopPropagation();
            }
        e.initKeyEvent("keypress", true, true, window, false, false, false, false, 0, "e".charCodeAt(0));
        document.body.appendChild(el);
        el.addEventListener("input", tester, false);
        el.focus();
        el.dispatchEvent(e);
        el.removeEventListener("input", tester, false);
        document.body.removeChild(el);
        return ok;
    } catch(e) {}
}
</code></pre>

<p>測試困難的主因是 Firefox 4 有 bug，所以需要真的建立一個 input 元件，然後用完整模擬 input 事件。然後雖然這個版本的比較精簡好懂，不過之後還是會因為 license 的關係改用 Modernizr 的版本吧。至於我做的 input field 呢，現在當然還是公司資產，大概要等我有空在假日重寫一個 Credit Card 的版本才會放出來吧。</p>
]]></description>
<dc:subject>script</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-09-11T00:21:40+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/08/25/modern-html-email-develop/">
<title>Modern HTML Email Development</title>
<link>https://blog.othree.net/log/2016/08/25/modern-html-email-develop/</link>
<description><![CDATA[<p>今天在 Modern Web 分享的主題</p>

<script async="async" class="speakerdeck-embed" data-id="17350d3dd0d14841ba8dd055400bd96f" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"><!-- A_A --></script>

<p>其實最主要是想介紹 <a href="https://mjml.io/">MJML</a> 這個工具，不過最後介紹的篇幅有些不夠，有些可惜，話說今天設備也有些狀況，一是投影機解析度和預期的不一樣，二是無線麥克風聲音會延遲，對於講者來說還蠻干擾的，最後時間還剩的比預期多，覺得愧疚啊。</p>

<p>最後附上這次介紹的一些資源的連結，方便取用：</p>

<ul>
<li><a href="http://emailmarketingreactions.tumblr.com/">Email Marketing Reactions</a></li>
<li><a href="https://stackoverflow.com/questions/14376783/list-of-mso-attributes">List of mso attributes</a></li>
<li><a href="https://medium.com/cm-engineering/coding-mobile-first-emails-1513ac4673e#.ksru1wvbm">Coding Mobile First Emails</a></li>
<li><a href="https://www.campaignmonitor.com/css/">The Ultimate Guide to CSS</a></li>
<li><a href="https://www.campaignmonitor.com/dev-resources/will-it-work/">Will It Work</a></li>
<li><a href="https://litmus.com/conference">The Email Design Conference</a></li>
<li><a href="https://www.dropbox.com/s/qkh68xkz3vp5yvr/eis-design-innovation.pdf?dl=0">Innovations in Email Design</a></li>
<li><a href="https://emailclientmarketshare.com/">Email Client Market Share</a></li>
</ul>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-08-25T23:12:54+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/08/13/json-web-token/">
<title>JSON Web Token</title>
<link>https://blog.othree.net/log/2016/08/13/json-web-token/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/14015411664/" title="大丸百貨 by othree, on Flickr"><img src="https://farm3.staticflickr.com/2895/14015411664_8cebe3a88c_b.jpg" width="1024" height="683" alt="大丸百貨" srcset="https://farm3.staticflickr.com/2895/14015411664_8cebe3a88c_b.jpg 1024w, https://farm3.staticflickr.com/2895/14015411664_aa01b9bc05_h.jpg 1600w" /></a></p>

<p>之前的 <a href="https://blog.othree.net/log/2016/01/11/json-universe/">JSON Universe</a> 那篇文章在寫的時候，還沒發現到有這東西，直到上個月才發現到 <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a>(JWT) 這個標準，研究過後覺得要單獨介紹一下，不過由於相關的標準有好幾個，花了些時間才搞清楚各個標準之間的關係；這一系列標準是由 <a href="https://datatracker.ietf.org/wg/jose/charter/">JOSE(JSON Object Signing and Encryption) Working Group</a> 所制訂的 RFC 標準，目前包括了：</p>

<ul>
<li><a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature</a></li>
<li><a href="https://tools.ietf.org/html/rfc7516">JSON Web Encryption</a></li>
<li><a href="https://tools.ietf.org/html/rfc7517">JSON Web Key</a></li>
<li><a href="https://tools.ietf.org/html/rfc7518">JSON Web Algorithms</a></li>
<li><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a></li>
</ul>

<p>共五個 RFC 標準，事實上，JSON Web Token 是要最後談到的；這一系列標準的目的是提供一個標準的協定，用在傳輸 JSON 資料時提供可靠性（簽章、signature）和安全性（加密、encryption），眼尖的人可能發現了，怎麼沒有 JOSE 的文件呢？事實上是真的沒有，而且也沒官方文件清楚解釋 JOSE 到底是什麼，最常看到的詞就是 JOSE Header 了，思考許久後才理解，JOSE 其實包括了兩種格式，分別是 JSON Web Signature(JWS) 和 JSON Web Encryption(JWE)，JWS 只是加上驗證用的簽章，其實內容是明碼的，JWE 才是真的有把傳輸的資料加密過，至於簽章和加密用的演算法則是用 JWA 格式來紀錄，然後需要用到的 key，例如用非對稱加密保護加密內容的 key 給收信端，這時則是用 JWK 格式來記錄要使用的 public key，而這些資訊就是 JOSE Header 的內容了，JWK 和 JWA 都是很簡單的格式，基本上就是一個物件，然後有定義好的屬性：</p>

<pre><code>{
  "kty":"EC",
  "crv":"P-256",
  "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU",
  "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0",
  "kid":"Public key used in JWS spec Appendix A.3 example"
}
</code></pre>

<p>例如這個 JWK 文件範例中的 <code>kty</code> 代表的是 Key Type；<code>crv</code>、<code>x</code> 和 <code>y</code> 則是橢圓曲線加密（ECC）類演算法會用到的參數；<code>kid</code> 則是自訂的 Key ID，用來在一堆 JWK 當中尋找所要的 key 使用；其它還有像是 X.509 憑證驗證會需要的資訊，各種加密演算法會用到的 Initialization Vector、Salt 等，都有定義好的屬性名稱。</p>

<p>JWS 和 JWK 就比較複雜些了，以 JWS 來說，你會先有要傳輸的資料 payload，然後一組 meta data，又稱為 JOSE Header，內容基本上就是 JWA + JWK + 一些基本的屬性，像是 <code>cty</code>、<code>typ</code>：</p>

<pre><code>{
  "typ":"JWT",
  "alg":"HS256"
}
</code></pre>

<p>這就是一個最簡單的 JOSE Header，它說明傳輸的資料內容和簽名用的 HMAC 演算法，然後這個 JOSE Header 和 payload 要分別轉成 <a href="https://tools.ietf.org/html/rfc7515#appendix-C">base64url</a> 編碼，其實和 base64 沒差很多，就先把 JSON String 轉成 base64 encoding string 後，把 padding 的 <code>=</code> 都拿掉，然後 <code>+</code> 用 <code>-</code> 取代，<code>/</code> 用 <code>_</code> 取代。例如 <code>ab?ab</code> 這個 ASCII 字串，用 base64 encoding 就會變成：</p>

<pre><code>YWI/YmE=
</code></pre>

<p>用 base64url 的話就變成：</p>

<pre><code>YWI_YmE
</code></pre>

<p>然後現在我們有一個 JOSE Header 和一個要傳輸的 JSON payload，以 base64url 編碼呈現並且用 <code>.</code> 接起來：</p>

<pre><code>BASE64URL(UTF8(JOSE Header)) || '.' || 
BASE64URL(JWS Payload))
</code></pre>

<p>接著把這個字串拿去用 JOSE Header 裡面指定的 HMAC 演算法搭配一組 key 來算出簽章（signature），至此我們就有了 JWS 三樣必須的元素了：</p>

<ul>
<li>JOSE Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>

<p>JWS 文件中定義了兩種格式可以用來傳輸這三個元素，第一種是精簡格式（Compact Serialization Syntax），格式很簡單，就和上面算 signature 用的格式一樣，只是現在多加了 signature 在後面，一樣用 base64url 形式：</p>

<pre><code>BASE64URL(UTF8(JWS Protected Header)) || '.' ||
BASE64URL(JWS Payload) || '.' ||
BASE64URL(JWS Signature)
</code></pre>

<p>長的會看起來像是：</p>

<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>

<p>另外一種則是 JSON 格式（JSON Serialization Syntax）：</p>

<pre><code>{
  "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
  "signatures":[
     {"protected":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
      "signature":"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"}]
}
</code></pre>

<p>這種形式其實是最完整的版本，還可以加上 public header （沒 signature 驗證）和多個 signature；另外也有 flatten 版，只能放一個 signature：</p>

<pre><code>{
  "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
  "protected":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
  "signature":"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"
}
</code></pre>

<p>雖然有 JSON 格式的 JWS，不過 精簡格式目前應該是最廣為通行的，一來是它資料量比較小，二是它比較方便在不同環境下傳輸使用，例如後面會提到的，放在 HTTP Header 內，如果沒有特殊需求要多個 signature，實在很沒有用 JSON 格式的需求。</p>

<p>最後，JWS 還有一個特殊的 case，就是它其實允許不加上簽章的，使用這組 JOSE Header：</p>

<pre><code>{"alg":"none"}
</code></pre>

<p>然後 signature 是空字串，所以精簡格式的就會變成：</p>

<pre><code> eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
</code></pre>

<p>最後是 <code>.</code> 結尾。</p>

<p>JWE 和 JWS 的狀態其實也很像，只是三個元素變成五個，包括了:</p>

<ul>
<li>JOSE Header</li>
<li>Encrypted Key</li>
<li>Initialization Vector</li>
<li>Ciphertext</li>
<li>Authentication Tag</li>
</ul>

<p>其中 JOSE Header 和 JWS 的內容差不多，Encrypted Key 和 Initialization Vector(IV) 是加密時的輸入，這邊的 Encrypted Key 是一把加密過的 Key，被加密保護的 Key 又稱為 Content Encryption Key(CEK)，是實際上用來加密保護內容時所使用的 Key，這把 CEK 和 IV 都是亂數產生的，那又有一個問題是，用什麼 Key 加密 CEK 來產生 Encrypted Key 呢？這邊建議的是用非對稱加密，拿收信方的 public key 來加密，當然 JOSE Header 裡面也可以塞進 x.509 的相關資訊用來確保 public key 的正確性；最後兩個，Ciphertext 和 Authentication Tag 則是加密的輸出，Authentication Tag 是 authentication encryption 會產生的，用來驗證內容正確性的資訊，就像是 JWS 的 signature 一樣用途，主要也是避免 Ciphertext 被用中間人攻擊替換掉，不過我還不太清楚如果可以偷到 key 偽造出 Ciphertext，是怎樣會沒法同時有另外一組 Authentication Tag 就是了。</p>

<p>然後一樣有精簡格式和 JSON 格式，精簡格式看起來就如下：</p>

<pre><code> eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ
</code></pre>

<p>注意找的話就可以發現四個 <code>.</code> 把資料切成五段。</p>

<p>最後終於要來介紹 JSON Web Token（JWT）了，JWT 是什麼呢，它其實就是一個 JOSE 的應用，一句話來說，就是使用 JWS 或 JWE 來做現在網路服務的身分認證協定中常見的 token（權杖）的傳遞。所以 JWT 其實就是規範了一組 JSON 資料的屬性（claim），和身分認證相關，然後要求這個 JSON 資料要用 JWS 或 JWE 來傳輸提供保護，這些預先定義好的屬性有：</p>

<ul>
<li><code>iss</code>, Issuer</li>
<li><code>sub</code>, Subject</li>
<li><code>aud</code>, Audience</li>
<li><code>exp</code>, Expiration Time</li>
<li><code>nbf</code>, Not Before</li>
<li><code>iat</code>, Issued At</li>
<li><code>jti</code>, JWT ID</li>
</ul>

<p>都是非常 meta 的 token 屬性，這些名稱基本上是從 <a href="http://openid.net/specs/openid-connect-core-1_0.html#IDToken">OpenID Connect</a> 那邊來的，除了這些定義好的屬性之外，還可以加上其它自訂的資料，只是這些已經被定義且<a href="http://www.iana.org/assignments/jwt/jwt.xhtml">註冊</a>好的名稱不能另做他用，OpenID Connect 也有不少個人資料的屬性已經註冊上 IANA 了，像是 <code>first_name</code>、<code>country</code> 之類的 profile 資訊，有一種使用 JWT 的方法就是直接把個人 profile 存在客戶端，server 只要驗證簽名是否正確，這樣一個好處是 server 不用保存 session 資訊，減少很多資源的需求，實做起來其實複雜度也比較低。另外由於是用作 token 之用，自然也可以當成 OAuth 的 token 使用，這部分資訊在 <a href="https://tools.ietf.org/html/rfc7523">RFC-7523</a> 這份文件有說明，至於要如何使用 OAuth token 則是在 <a href="https://tools.ietf.org/html/rfc6750">RFC-6750</a> 有介紹，比較常見的是放在 HTTP Auth Header 裡面：</p>

<pre><code>Authorization: Bearer eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
</code></pre>

<p>之前鴨七也有整理過中文的<a href="https://blog.yorkxin.org/2013/09/30/oauth2-6-bearer-token">說明</a>，看起來比較輕鬆，而且說明很完整（不過我承認我沒有從頭看到尾）。</p>

<p>目前搜尋 JWT 一定會看到一個網站 <a href="https://jwt.io/">jwt.io</a>，這個網站用淺顯易懂的方式來<a href="https://jwt.io/introduction/">介紹</a> JWT，把比較複雜的關係，像是 JWS、JWE 等等都隱藏起來幫助瞭解，還有一個線上除錯工具和不同語言的 library 整理，不過除錯工具只有支援 JWS，另外也有和一些其它類似標準做比較，還蠻值得看一看的，這個網站是由 <a href="https://auth0.com/">Auth0</a> 提供的，他們其實就是一家專門提供身分認證服務的公司，似乎都已經轉到使用 JWT 了，在 jwt.io 有提到他們似乎是把他用作 stateless 的 token 來用，我對這間公司之前印象是還不錯，一來是 API 文件看起來還蠻不錯的，另外有不少的開放原碼<a href="https://auth0.com/opensource">專案</a>，當然有一些是串接他們家服務用的 library 啦。</p>

<p>PS. 對密碼學還沒很熟悉，有誤歡迎指正～</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-08-13T18:46:54+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/">
<title>7 Bit Encoding and Email</title>
<link>https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/</link>
<description><![CDATA[<p>最近工作上比較常接觸到 email 的東西，然後比較認真的看了 HTML email 信件的內容，以前我以為都要用 base64 編碼來處理，可是用 base64 來處理 HTML email 我一直覺得很不合理，一來大小會變 1.33 倍，二來整個 HTML 原始碼傳送時會變的幾乎無法辨識，收信軟體還要先解碼一次才可以 parse HTML，感覺完全不需要多此一舉，總之就是覺得為什麼要做這麼愚蠢的事情，明明看起來 <a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 就沒這樣限制，所以我應該可以這樣寫：</p>

<pre><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>然後內文直接放 HTML 原始碼，可是不知道為什麼沒人這樣做，事實上也不 work；最近多看了一些郵件原始碼才發現其實還有個 Quoted-Printable encoding 也很常用，看起來比 Base64 的結果還要接近原始碼許多了，所以就研究了一下它到底是什麼格式。</p>

<p>Quoted-Printable encoding 的基本原理就是用 <code>=</code> 作為 escape 字元，然後可以把要轉換的字元轉成 <code>=字碼</code> 的形式，例如 Big5 中文的 <code>我</code> 就要轉成 <code>=A7=DA</code>，規範上要轉換的是除了可見（printable）<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a> 字元以外的字元都要轉，而 ASCII 是個 7bit 編碼，字碼只有從 0 到 127 而已，而 email 要用 Quoted-Printable encoding 的主要原因其實就是為了讓文件內的每個字元編碼都維持在 7bit 編碼範圍內，現在大家常用的編碼像是 UTF-8 和以前常用的 Big5 等都是 8bit 編碼，兩者差別就在於每個傳輸的 byte 中有沒有使用到第 8 個 bit，轉成二進位的時候，7bit 系統編碼不會用到最左（higher-order）邊的那個 bit。</p>

<p>為什麼需要用 7bit 的文字編碼呢？主因是計算機和電信網路早期很多系統是只支援 7bit 編碼的，SMTP 的<a href="https://tools.ietf.org/html/rfc821#page-44">規範</a>就直接要求 TCP 傳輸時，每個 byte 最左邊的 higher-order bit 要填 0：</p>

<blockquote>
  <p>The TCP connection supports the transmission of 8-bit bytes.
The SMTP data is 7-bit ASCII characters.  Each character is
transmitted as an 8-bit byte with the high-order bit cleared to
zero.</p>
</blockquote>

<p>當然這規範很落後時代，所以在 <a href="https://tools.ietf.org/html/rfc2045#section-6">MIME（Multipurpose Internet Mail Extensions）</a> 規範其實也有 <code>Content-Transfer-Encoding</code> 可以指定傳輸用的是什麼編碼：</p>

<pre><code>Content-Transfer-Encoding: 8bit
</code></pre>

<p>不過為了相容舊系統，還是很少真的這樣使用的信件在傳遞，因為要是傳到了 7bit 系統，小則亂碼、大則程式當機。不過這就帶出另外一個問題了，難道 7bit 系統只能傳輸 ASCII 字集嗎？因為我還蠻常看到日文的純文字郵件，就去找了一些來看看，結果發現到有的是用 <code>ISO-2022-JP</code>，而且是使用 7bit 的傳輸：</p>

<pre><code>Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit
</code></pre>

<p>信件內容的文字也都很正確，沒有亂碼：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27751195323/" title="iso-2022-jp by othree, on Flickr"><img src="https://farm8.staticflickr.com/7684/27751195323_a423fd4cb4_b.jpg" width="708" height="558" alt="iso-2022-jp" srcset="" /></a></p>

<p>於是就看一下 <a href="https://zh.wikipedia.org/wiki/ISO/IEC_2022">ISO-2022</a> 的介紹，發現原來是個很早就有的 7bit 編碼方法，後來根據這方法有訂出了 CN、JP、KR 等語言的編碼，不過比較通行的看來只有 ISO-2022-JP，然後我也找到 HTML email 用 ISO-2022-JP 的：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28366990615/" title="ISO-2022-JP by othree, on Flickr"><img src="https://farm9.staticflickr.com/8572/28366990615_bc76dcce70_b.jpg" width="708" height="558" alt="ISO-2022-JP" srcset="" /></a></p>

<p>看起來就像是我理想中的 HTML email 原始碼啊，所以問題的癥結其實是，大家為了相容於舊系統，所以都用 7bit 傳輸，要 7bit safe 的 encoding 選擇有限，除了比較通行的 ISO-2022-JP 可以給日文用、字元太少只能給英文用的 ASCII 之外，其它語言就只能用 Base64 encoding 和 Quoted-Printable encoding 了，所以事實上其它 7bit 編碼的內容，也是可以直接透過 SMTP 協定來傳輸的，只是要看收信端的軟體能不能支援解碼，像是已經不太有人用的 <a href="https://zh.wikipedia.org/zh-tw/UTF-7">UTF-7</a> 就是 7bit 的 unicode 編碼。</p>

<p>最後，就是假設我們已經不用擔心老舊系統的時候，其實只要這樣寫在 MIME header 裡就可以直接傳 UTF-8 的 HTML source，不用再經過任何編碼處理了：</p>

<pre><code>Content-Transfer-Encoding: 8bit
Content-Type: text/html; charset=utf-8
</code></pre>

<p>不過距離這一步不知道還有多遠就是了。</p>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-19T13:28:23+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/16/hkoscon-2016/">
<title>HKOSCON 2016</title>
<link>https://blog.othree.net/log/2016/07/16/hkoscon-2016/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27315015884/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7526/27315015884_dd95e637b1_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7526/27315015884_dd95e637b1_b.jpg 1024w, https://farm8.staticflickr.com/7526/27315015884_5f8f452616_h.jpg 1600w" /></a></p>

<p>今年有幸可以參與<a href="https://2016.opensource.hk/">香港的 Open Source Conference</a>，這趟還承蒙 Mozilla 贊助交通費用，另外因為是講者的關係，住宿的部分則是 HKOSCON 幫忙。其實至少去年就想去了，不過去年因為事情比較多就放棄了，今年還乾脆的投稿分享，不過因為工作的關係，只有參加週六的議程，週五的部分就沒參加到了，聽的議程如下：</p>

<ul>
<li>回顧台灣自由開源軟體發展 by Jim Huang</li>
<li>Interactive Dashboard Development with Plotly by Mart van de Ven</li>
<li>Fluentd: Unified Logging Layer by Masahiro Nakagawa by Andy Shu</li>
<li>Optimizing Chinese Webfont &amp; Typography by Andy Shu</li>
<li>Mozilla Eir - Bring medical devices into the world of webby Kevin Hu</li>
<li>From Open Source to Open Media by Hsin-Chan Chien</li>
<li>My Mozilla Contributing Journey by Irvin Chen</li>
</ul>

<p>第一場就是 Jserv 介紹台灣以前的自由開源軟體的發展，我到會場的時候已經開始講的，介紹的比較是早期的發展，是我有參與到這個圈子前的時期，對我來說大部分都是，照我印象比在台灣之前說到的還要詳細些，不過我的聽幾次 Jserv 的分享感覺下來，就是大概進入 COSCUP 開始辦之後，參與發展在地化的自由開源軟體的人卻越來越少，當然我自己也是沒參與啦，其實曾經我本來要幫忙新酷音的網站（目前是 <a href="http://blog.kidwm.net/">WM</a> 維護），不過因為一些奇妙的原因我就沒幫上了。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27850155241/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7351/27850155241_5c22604d7e_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7351/27850155241_5c22604d7e_b.jpg 1024w, https://farm8.staticflickr.com/7351/27850155241_5f052102f4_h.jpg 1600w" /></a></p>

<p><a href="https://plot.ly/">Plotly</a> 則是一個 plot library，我是沒很注意聽，有興趣可以自己研究一下優缺點，目前這市場似乎有點飽和，可能等真的有需求時再來研究吧。</p>

<p><a href="http://www.fluentd.org/">Fluentd</a> 是最近蠻多人會用的 log 收集中間人，我目前工作上雖然沒有直接接觸，到是有間接使用到，不過我到來聽這場的這時候才知道，原來作者是日本人，不得不說有點意外，來講的是 Masahiro Nakagawa，是目前專案上排第二的開發者。</p>

<p>Optimizing Chinese Webfont &amp; Typography 這場的重點其實就是動態組字形技術，以前台灣這邊也有人在弄，有商業化的就是 <a href="http://www.justfont.com/">justfont</a> 了吧，不過沒想到這技術現在也有開源專案提供了，這場 Andy 介紹的是 <a href="https://github.com/aui/font-spider">font-spider</a> 這個專案，有興趣的可以自己玩玩看。PS: 我覺得 justfont 不斷拓展方向的策略還蠻正確的，不然單靠 Webfont 就蠻危險的。</p>

<p><a href="https://wiki.mozilla.org/Eir">Mozilla Eir</a> 則是第一場 Mozilla 相關的主題，主要是介紹 Mozilla 參與醫療器材平台發展的專案，目前還在蠻初期的，個人感覺還在規劃和討論的階段，所以還沒有實際的成果或是可以 demo 的東西。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27927183155/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7421/27927183155_b62eedb67d_b.jpg" width="683" height="1024" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7421/27927183155_b62eedb67d_b.jpg 683w, https://farm8.staticflickr.com/7421/27927183155_8da1d310a3_h.jpg 1067w" /></a></p>

<p>From Open Source to Open Media 則是 HC 從 OSDC 到現在<a href="https://www.twreporter.org/">報導者</a>之間的歷程，聽完之後覺得經濟動能推升方案那支<a href="https://www.youtube.com/watch?v=RAbD3AGFX6I">廣告</a>，當時看覺得是什麼鬼，現在看覺得效用真的很大啊(?)，然後就讓我想到 g0v 有一個推人入坑的方法，就是先弄一個糟糕的版本推上線，然後就會有人受不了出來修改。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27648624360/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7414/27648624360_588fb64815_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7414/27648624360_588fb64815_b.jpg 1024w, https://farm8.staticflickr.com/7414/27648624360_fd2c5e426e_h.jpg 1600w" /></a></p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27648621990/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7448/27648621990_061e86fb62_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7448/27648621990_061e86fb62_b.jpg 1024w, https://farm8.staticflickr.com/7448/27648621990_221a77e794_h.jpg 1600w" /></a></p>

<p>My Mozilla Contributing Journey 這場則是 <a href="https://reps.mozilla.org/u/irvin/">Irvin</a> 自己從開始參與 Moztw 社群到現在一路的歷程，因為參與 Moztw 而有了什麼收穫等等，我印象中有這樣明確整理出因為參與開源社群而獲得的收穫的分享，好像是沒有，有興趣的話，他在 SITCON 夏令營還會再講一次，有興趣的或許...報名好像結束了就是。</p>

<p>除了上面聽的兩場和 Mozilla 相關的題目之外，還有一場我沒聽的是 Gary 的演講，題目是之前講過的 Fuzzy Test，不過是 2016 年版，Fuzzy Test 我覺得真的是自動化整合測試最後一關了，基本上就是把所有正常的操作都測試完之後，就來測個不正常的操作吧，那怎樣產生不正常的操作流程呢，就是可以用 Fuzzy 的方法來產生，不過他自己有說今年 Mozilla 在這邊的資源變少了；其實我覺得 Mozilla 最近方向實在是不太明確，我印象中的整個轉捩點大概是 Brendan Eich 下台開始，然後 Firefox OS 的市佔率也起不來，Firefox 的發展也越來越跟不上 Chrome，像是 e10s 就一直都還不太行，真的是蠻讓人擔心的，好在是短時間還<a href="http://www.recode.net/2016/7/7/12116296/marissa-mayer-deal-mozilla-yahoo-payment">不需要擔心資金問題</a>的樣子。</p>

<p>然後還有一場間接相關的就是我的<a href="https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/">分享</a>了，這個題目本來是有考慮投 COSCUP 的，後來還是投到 HKOSCON 這邊，也是我第一次嘗試用英文演講，可惜我練習不夠，講的實在不好，很多地方都覺得好像沒正確的講清楚，下次還有機會用英文演講的話應該還是會再試一次，希望下次練習更充分，表現正常些，不然就要上場前喝罐啤酒試試看了，根據我之前的試驗結果，好像喝過酒的情況下，講的會比較流暢XD。</p>

<p>除了演講外，還有一區有廠商攤位，還有一個 Job Board 版面可以給人貼徵才資訊，攤位的部分，IBM、VLC、Google、HKLUG﹑自由香港字型等是我比較有印象的，IBM 是介紹他們的 AI as Service 的服務，紀念品當中還有一些 for Dummies 系列叢書：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27927181435/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7609/27927181435_4acfb018f0_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7609/27927181435_228502eb76_k.jpg 2x" /></a></p>

<p>Google 不知道怎麼會願意來擺攤，沒跟他們聊聊，台灣 Google 好像還沒在社群擺過攤的樣子，如果有錯還請幫忙更正，不過總之我拿到 Chrome 貼紙了，這樣曾經的五大瀏覽器，Chrome、IE、Firefox、Opera 的紀念品我都有拿到過了，只差一個台灣實在很難碰到的 Apple 的 Safari 而已。</p>

<p>自由香港字型則是一群人要造屬於香港字的自由字型而聚集起來的社群，主因是因為香港漢字其實有一些字的寫法、筆畫和台灣日本的不一樣，例如下圖中間的「周」：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27315002094/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7408/27315002094_4a9bd2c75a_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7408/27315002094_38e0b5baee_k.jpg 2x" /></a></p>

<p>然後過去又沒有可以自由使用的字型可以用，所以開始了這個計畫，相信大家也都知道要造一套字型有多大難度，所以這社群有些成果出來真的是很厲害。</p>

<p>整個 HKOSCON 規模比台灣常參加的研討會還要小一些，不過參與的外國人比例感覺比較高，英文議程也多一些，相較來說是對外國會眾友善不少，當然我想英文在香港比較流通也是主因之一，在台灣要做到國際化的研討會實在不太容易，目前比較常見的問題包括：翻譯問題，雖然可以靠口譯解決，不過成本瞬間提升，光靠贊助很難，所以幾乎是要全商業化的形式才比較有可能，票價也會因此和國際接軌；入境問題，中國人要到台灣困難度很高（好像還有幾個國家要來也很困難，一時忘了），這也造成一些國際研討會亞洲場不考慮台灣的原因，這問題很難靠主辦解決就是。</p>

<p>最後還是要感謝 Mozilla 的贊助，還有 HKOSCON 大會和 Sammy Fung 的協助讓這趟行程可以很順利的完成，Sammy 也是 COSCUP 的常客，前陣子還開始了 <a href="http://opensource.asia/">opensource.asia</a> 這個網站，收集亞洲相關的 Open Source 活動，大家有興趣可以 COSCUP 活動時找他聊聊。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27315009874/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7415/27315009874_b5eec57431_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7415/27315009874_96c3e64b8c_k.jpg 2x" /></a></p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-16T16:55:13+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/14/web-push/">
<title>Web Push</title>
<link>https://blog.othree.net/log/2016/07/14/web-push/</link>
<description><![CDATA[<p>前兩天要研究一下 Chrome 接 GCM 的實做，發現到 Google 又出一個新的服務叫 Firebase，然後新的 cloud messaging 服務就叫 <a href="https://firebase.google.com/docs/cloud-messaging/">Firebase Cloud Messaging(FCM)</a>，隨便看了一下 Google 官方的文件，結果發現有提到另外一個正在制訂中的 <a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-07">Web Push Protocol</a>，照文件的說法，FCM 也只是個過渡時期的方案，最終目標還是用這個 Web Push Protocol，於是我就研究了一下他的設計，發現設計的還蠻漂亮的。</p>

<p>整個 Web Push Protocol 的基本架構如下圖：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28277091075/" title="Web Push Protocol by othree, on Flickr"><img src="https://farm8.staticflickr.com/7633/28277091075_ecdf54fc60_b.jpg" width="493" height="263" alt="Web Push Protocol" srcset="" /></a></p>

<p>User Agent(UA) 通常是行動端的應用程式、Application 則是自家服務的後台；整個流程首先是 UA 透過 HTTP/1.1 POST 去跟 Push Service 訂閱（第一條橫線 Subscribe），然後會拿到一個 subscription resource，可能長成：</p>

<pre><code>https://push.example.net/subscription/LBhhw0OohO-Wl4Oi971UG
</code></pre>

<p>另外還會拿到一個發訊息用的 push resource：</p>

<pre><code>https://push.example.net/push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV
</code></pre>

<p>可以注意到兩個 resource 後面的 token 是不一樣的，兩者之間的 mapping 就是 Push Service 來負責；然後 UA 拿到這兩個網址後，發訊息用的 push resource 要交給自家服務的後台，也就是圖上第三條橫線 Distribute Push Resource，另外一個 subscription resource 則是要自己使用，UA 用 HTTP/2 打 GET 到 subscription resource，然後 push service 會把連線保持住不關掉，這就是圖上的第二條橫線 Monitor；自家服務後台的要送訊息的時候，就打 POST 去 push resource，也就是第四條橫線，從 Application 到 Push Service 間的 Push Message，push service 收到這個訊息時，就利用 HTTP/2 的 Server Push 機制主動傳送訊息，最後這個動作就是第五條橫線的 Push Message 了。</p>

<p>就這樣很漂亮的用 HTTP/1.1 + HTTP/2 把一個基本的 Cloud Message Service 的協定建構起來，而除了這最基本的訊息傳遞外，這份文件還有定義像是訊息重要度、訊息回條、群組訊息等等的方法，設計都還蠻漂亮的，安全性的部分則是限制走 HTTPS over TLS，還有 operation 相關的說明，像是實際上要跑起這個服務，需要大量的 TCP connection 等等（因為都走 HTTP 了），有興趣的可以加減看一下。</p>

<p>補充：Firefox 目前實做的似乎就是這個協定更早版本的草案</p>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-14T12:40:19+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/">
<title>YAJS.vim and Vim Syntax Highlight</title>
<link>https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/</link>
<description><![CDATA[<p>上個週末在<a href="https://2016.opensource.hk/">香港 Open Source Conference</a> 分享的主題，第一次使用英文分享，結果表現不太好，不知道上場前喝點啤酒會不會比較好就是...</p>

<p>這個主題本來是想要投 COSCUP 的，主要是想介紹一下之前在做 <a href="https://github.com/othree/yajs.vim">yajs.vim</a> 時遇到的比較有印象的問題，在這之前先介紹一下 Vim Syntax Highlight 的機制，因為這些問題很多都和 Vim 的 Syntax Highlight 機制的設計關係很大，然後最後就是有一個還沒辦法解的問題，這個問題就是 yajs.vim 目前還沒辦法完美的 highlight 有 default parameter 的 arrow function。</p>

<script async="async" class="speakerdeck-embed" data-id="3294147a503d4079a6238296fc991a76" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]></description>
<dc:subject>vim</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-01T17:05:37+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/04/22/nginx-fcgiwrap/">
<title>nginx &amp; fcgiwrap</title>
<link>https://blog.othree.net/log/2016/04/22/nginx-fcgiwrap/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/23099768130/" title="菲貓 by othree, on Flickr"><img src="https://farm1.staticflickr.com/621/23099768130_3caf60c59d_b.jpg" width="1024" height="683" alt="菲貓, " srcset="https://farm1.staticflickr.com/621/23099768130_3caf60c59d_b.jpg 1024w, https://farm1.staticflickr.com/621/23099768130_d3a13dc95b_h.jpg 1600w" /></a></p>

<p>雖然很久以前就想換到 nginx 試試看，不過直到最近這次更新才換成功，最早單純只是想要輕量一點的 HTTP server，後來則是因為和 Apache 相比，nginx 明顯開發更新比較快，最近有很多想要嘗試各種新功能都是 nginx 先做，像是 HTTP/2，還有最近這次的 brotli 支援，而以前沒辦法換過去的最主要原因，其實是 nginx 沒有 CGI 的支援，跑 MovableType 會有困難，雖然 MovableType 可以用 FastCGI，不過很難設定，我安裝過 n 次大概也只有成功過一兩次，所以其實一直都不太考慮這個選項。</p>

<p>不過認真研究了一下，終於發現其實可以透過 <a href="https://github.com/gnosek/fcgiwrap">FCGI Wrap</a> 這個工具來達成 nginx 對 CGI script 的支援，它的作法其實就是一個中間人，把 FCGI 介面轉到 CGI 介面過去，我大概設定了一下跑 MovableType 的 nginx conf 如下：</p>

<pre><code>location ~ ^/path/to/mt/mt.*\.cgi {
    gzip off;
    fastcgi_index index.cgi;
    fastcgi_split_path_info ^(.+?\.cgi)(/.*)$;
    if (!-e $document_root$fastcgi_script_name) {
        return 404;
    }
    include fastcgi.conf;

    ## MT-related
    fastcgi_param PERL5LIB $document_root/mt/lib;
    fastcgi_param MT_HOME $document_root/mt/;
    fastcgi_param MT_CONFIG $document_root/mt/mt-config.cgi;

    fastcgi_param PATH_INFO $fastcgi_path_info;
    fastcgi_param PATH_TRANSLATED $fastcgi_path_info;
    fastcgi_pass unix:/var/run/fcgiwrap.sock;
}
</code></pre>

<p>然後主機上要開好 FCGI Wrap 的服務，我是用 ArchLinux 的 pacman 直接裝套件，然後參考<a href="https://wiki.archlinux.org/index.php/nginx#fcgiwrap">官方文件</a>，有寫說設定檔位置 <code>/usr/lib/systemd/system/fcgiwrap.socket</code> ，cat 出來就可以看到 UNIX Socket 檔案位置 <code>ListenStream=/run/fcgiwrap.sock</code> ，這個路徑的位置其實就指到上面設定最後一行的 <code>/var/run/fcgiwrap.sock</code>，<code>/run</code> 和 <code>/var/run</code> 兩邊其實有 Symbolic Link 起來，所以兩個 sock 檔案其實是同一個。</p>

<p>最後要說一下 conf 裡的這行：</p>

<pre><code>    include fastcgi.conf;
</code></pre>

<p>這個 <code>fastcgi.conf</code> 檔案其實是 nginx 內建好方便大家使用的，內容如下：</p>

<pre><code>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;

fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
fastcgi_param  REQUEST_URI        $request_uri;
fastcgi_param  DOCUMENT_URI       $document_uri;
fastcgi_param  DOCUMENT_ROOT      $document_root;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;
fastcgi_param  REQUEST_SCHEME     $scheme;
fastcgi_param  HTTPS              $https if_not_empty;

fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;

fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  REMOTE_PORT        $remote_port;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;

# PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param  REDIRECT_STATUS    200;
</code></pre>

<p>可以看到其實這個檔案就是把直接走 FCGI 時會遺失的環境變數補回去用的，nginx 還提供很多這類<a href="https://github.com/nginx/nginx/tree/master/conf">檔案</a>，以前都不太清楚怎麼剛裝好的 nginx 會附上一堆沒有用到的 conf 檔，直到這次才瞭解它們其實都很有用啊。</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-04-22T21:52:05+08:00</dc:date>
</item>


</rdf:RDF>