<?xml version="1.0" encoding="utf-8"?>

<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:admin="http://webns.net/mvcb/"
xmlns:cc="http://web.resource.org/cc/"
xmlns="http://purl.org/rss/1.0/">

<channel rdf:about="https://blog.othree.net/">
<title>O3noBLOG</title>
<link>https://blog.othree.net/</link>
<description></description>
<dc:creator></dc:creator>
<dc:date>2016-08-25T23:12:54+08:00</dc:date>
<admin:generatorAgent rdf:resource="http://www.movabletype.org/?v=4.381" />

<cc:license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/1.0/" />


<items>
<rdf:Seq>
<rdf:li rdf:resource="https://blog.othree.net/log/2016/08/25/modern-html-email-develop/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/08/13/json-web-token/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/16/hkoscon-2016/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/14/web-push/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/04/22/nginx-fcgiwrap/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/04/10/360-test/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/04/08/purecss/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/04/05/ssh-agent-forward/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/04/05/kyushu-rail/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/03/21/brotli-gzip-alt/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/02/28/device-pixel-ratio-header/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/02/06/how-to-reduce-pdf-size/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2016/01/11/json-universe/" />
</rdf:Seq>
</items>

</channel>


<item rdf:about="https://blog.othree.net/log/2016/08/25/modern-html-email-develop/">
<title>Modern HTML Email Development</title>
<link>https://blog.othree.net/log/2016/08/25/modern-html-email-develop/</link>
<description><![CDATA[<p>今天在 Modern Web 分享的主題</p>

<script async="async" class="speakerdeck-embed" data-id="17350d3dd0d14841ba8dd055400bd96f" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"><!-- A_A --></script>

<p>其實最主要是想介紹 <a href="https://mjml.io/">MJML</a> 這個工具，不過最後介紹的篇幅有些不夠，有些可惜，話說今天設備也有些狀況，一是投影機解析度和預期的不一樣，二是無線麥克風聲音會延遲，對於講者來說還蠻干擾的，最後時間還剩的比預期多，覺得愧疚啊。</p>

<p>最後附上這次介紹的一些資源的連結，方便取用：</p>

<ul>
<li><a href="http://emailmarketingreactions.tumblr.com/">Email Marketing Reactions</a></li>
<li><a href="https://stackoverflow.com/questions/14376783/list-of-mso-attributes">List of mso attributes</a></li>
<li><a href="https://medium.com/cm-engineering/coding-mobile-first-emails-1513ac4673e#.ksru1wvbm">Coding Mobile First Emails</a></li>
<li><a href="https://www.campaignmonitor.com/css/">The Ultimate Guide to CSS</a></li>
<li><a href="https://www.campaignmonitor.com/dev-resources/will-it-work/">Will It Work</a></li>
<li><a href="https://litmus.com/conference">The Email Design Conference</a></li>
<li><a href="https://www.dropbox.com/s/qkh68xkz3vp5yvr/eis-design-innovation.pdf?dl=0">Innovations in Email Design</a></li>
<li><a href="https://emailclientmarketshare.com/">Email Client Market Share</a></li>
</ul>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-08-25T23:12:54+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/08/13/json-web-token/">
<title>JSON Web Token</title>
<link>https://blog.othree.net/log/2016/08/13/json-web-token/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/14015411664/" title="大丸百貨 by othree, on Flickr"><img src="https://farm3.staticflickr.com/2895/14015411664_8cebe3a88c_b.jpg" width="1024" height="683" alt="大丸百貨" srcset="https://farm3.staticflickr.com/2895/14015411664_8cebe3a88c_b.jpg 1024w, https://farm3.staticflickr.com/2895/14015411664_aa01b9bc05_h.jpg 1600w" /></a></p>

<p>之前的 <a href="https://blog.othree.net/log/2016/01/11/json-universe/">JSON Universe</a> 那篇文章在寫的時候，還沒發現到有這東西，直到上個月才發現到 <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a>(JWT) 這個標準，研究過後覺得要單獨介紹一下，不過由於相關的標準有好幾個，花了些時間才搞清楚各個標準之間的關係；這一系列標準是由 <a href="https://datatracker.ietf.org/wg/jose/charter/">JOSE(JSON Object Signing and Encryption) Working Group</a> 所制訂的 RFC 標準，目前包括了：</p>

<ul>
<li><a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature</a></li>
<li><a href="https://tools.ietf.org/html/rfc7516">JSON Web Encryption</a></li>
<li><a href="https://tools.ietf.org/html/rfc7517">JSON Web Key</a></li>
<li><a href="https://tools.ietf.org/html/rfc7518">JSON Web Algorithms</a></li>
<li><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a></li>
</ul>

<p>共五個 RFC 標準，事實上，JSON Web Token 是要最後談到的；這一系列標準的目的是提供一個標準的協定，用在傳輸 JSON 資料時提供可靠性（簽章、signature）和安全性（加密、encryption），眼尖的人可能發現了，怎麼沒有 JOSE 的文件呢？事實上是真的沒有，而且也沒官方文件清楚解釋 JOSE 到底是什麼，最常看到的詞就是 JOSE Header 了，思考許久後才理解，JOSE 其實包括了兩種格式，分別是 JSON Web Signature(JWS) 和 JSON Web Encryption(JWE)，JWS 只是加上驗證用的簽章，其實內容是明碼的，JWE 才是真的有把傳輸的資料加密過，至於簽章和加密用的演算法則是用 JWA 格式來紀錄，然後需要用到的 key，例如用非對稱加密保護加密內容的 key 給收信端，這時則是用 JWK 格式來記錄要使用的 public key，而這些資訊就是 JOSE Header 的內容了，JWK 和 JWA 都是很簡單的格式，基本上就是一個物件，然後有定義好的屬性：</p>

<pre><code>{
  "kty":"EC",
  "crv":"P-256",
  "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU",
  "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0",
  "kid":"Public key used in JWS spec Appendix A.3 example"
}
</code></pre>

<p>例如這個 JWK 文件範例中的 <code>kty</code> 代表的是 Key Type；<code>crv</code>、<code>x</code> 和 <code>y</code> 則是橢圓曲線加密（ECC）類演算法會用到的參數；<code>kid</code> 則是自訂的 Key ID，用來在一堆 JWK 當中尋找所要的 key 使用；其它還有像是 X.509 憑證驗證會需要的資訊，各種加密演算法會用到的 Initialization Vector、Salt 等，都有定義好的屬性名稱。</p>

<p>JWS 和 JWK 就比較複雜些了，以 JWS 來說，你會先有要傳輸的資料 payload，然後一組 meta data，又稱為 JOSE Header，內容基本上就是 JWA + JWK + 一些基本的屬性，像是 <code>cty</code>、<code>typ</code>：</p>

<pre><code>{
  "typ":"JWT",
  "alg":"HS256"
}
</code></pre>

<p>這就是一個最簡單的 JOSE Header，它說明傳輸的資料內容和簽名用的 HMAC 演算法，然後這個 JOSE Header 和 payload 要分別轉成 <a href="https://tools.ietf.org/html/rfc7515#appendix-C">base64url</a> 編碼，其實和 base64 沒差很多，就先把 JSON String 轉成 base64 encoding string 後，把 padding 的 <code>=</code> 都拿掉，然後 <code>+</code> 用 <code>-</code> 取代，<code>/</code> 用 <code>_</code> 取代。例如 <code>ab?ab</code> 這個 ASCII 字串，用 base64 encoding 就會變成：</p>

<pre><code>YWI/YmE=
</code></pre>

<p>用 base64url 的話就變成：</p>

<pre><code>YWI_YmE
</code></pre>

<p>然後現在我們有一個 JOSE Header 和一個要傳輸的 JSON payload，以 base64url 編碼呈現並且用 <code>.</code> 接起來：</p>

<pre><code>BASE64URL(UTF8(JOSE Header)) || '.' || 
BASE64URL(JWS Payload))
</code></pre>

<p>接著把這個字串拿去用 JOSE Header 裡面指定的 HMAC 演算法搭配一組 key 來算出簽章（signature），至此我們就有了 JWS 三樣必須的元素了：</p>

<ul>
<li>JOSE Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>

<p>JWS 文件中定義了兩種格式可以用來傳輸這三個元素，第一種是精簡格式（Compact Serialization Syntax），格式很簡單，就和上面算 signature 用的格式一樣，只是現在多加了 signature 在後面，一樣用 base64url 形式：</p>

<pre><code>BASE64URL(UTF8(JWS Protected Header)) || '.' ||
BASE64URL(JWS Payload) || '.' ||
BASE64URL(JWS Signature)
</code></pre>

<p>長的會看起來像是：</p>

<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>

<p>另外一種則是 JSON 格式（JSON Serialization Syntax）：</p>

<pre><code>{
  "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
  "signatures":[
     {"protected":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
      "signature":"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"}]
}
</code></pre>

<p>這種形式其實是最完整的版本，還可以加上 public header （沒 signature 驗證）和多個 signature；另外也有 flatten 版，只能放一個 signature：</p>

<pre><code>{
  "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
  "protected":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
  "signature":"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"
}
</code></pre>

<p>雖然有 JSON 格式的 JWS，不過 精簡格式目前應該是最廣為通行的，一來是它資料量比較小，二是它比較方便在不同環境下傳輸使用，例如後面會提到的，放在 HTTP Header 內，如果沒有特殊需求要多個 signature，實在很沒有用 JSON 格式的需求。</p>

<p>最後，JWS 還有一個特殊的 case，就是它其實允許不加上簽章的，使用這組 JOSE Header：</p>

<pre><code>{"alg":"none"}
</code></pre>

<p>然後 signature 是空字串，所以精簡格式的就會變成：</p>

<pre><code> eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
</code></pre>

<p>最後是 <code>.</code> 結尾。</p>

<p>JWE 和 JWS 的狀態其實也很像，只是三個元素變成五個，包括了:</p>

<ul>
<li>JOSE Header</li>
<li>Encrypted Key</li>
<li>Initialization Vector</li>
<li>Ciphertext</li>
<li>Authentication Tag</li>
</ul>

<p>其中 JOSE Header 和 JWS 的內容差不多，Encrypted Key 和 Initialization Vector(IV) 是加密時的輸入，這邊的 Encrypted Key 是一把加密過的 Key，被加密保護的 Key 又稱為 Content Encryption Key(CEK)，是實際上用來加密保護內容時所使用的 Key，這把 CEK 和 IV 都是亂數產生的，那又有一個問題是，用什麼 Key 加密 CEK 來產生 Encrypted Key 呢？這邊建議的是用非對稱加密，拿收信方的 public key 來加密，當然 JOSE Header 裡面也可以塞進 x.509 的相關資訊用來確保 public key 的正確性；最後兩個，Ciphertext 和 Authentication Tag 則是加密的輸出，Authentication Tag 是 authentication encryption 會產生的，用來驗證內容正確性的資訊，就像是 JWS 的 signature 一樣用途。</p>

<p>然後一樣有精簡格式和 JSON 格式，精簡格式看起來就如下：</p>

<pre><code> eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ
</code></pre>

<p>注意找的話就可以發現四個 <code>.</code> 把資料切成五段。</p>

<p>最後終於要來介紹 JSON Web Token（JWT）了，JWT 是什麼呢，它其實就是一個 JOSE 的應用，一句話來說，就是使用 JWS 或 JWE 來做現在網路服務的身分認證協定中常見的 token（權杖）的傳遞。所以 JWT 其實就是規範了一組 JSON 資料的屬性（claim），和身分認證相關，然後要求這個 JSON 資料要用 JWS 或 JWE 來傳輸提供保護，這些預先定義好的屬性有：</p>

<ul>
<li><code>iss</code>, Issuer</li>
<li><code>sub</code>, Subject</li>
<li><code>aud</code>, Audience</li>
<li><code>exp</code>, Expiration Time</li>
<li><code>nbf</code>, Not Before</li>
<li><code>iat</code>, Issued At</li>
<li><code>jti</code>, JWT ID</li>
</ul>

<p>都是非常 meta 的 token 屬性，這些名稱基本上是從 <a href="http://openid.net/specs/openid-connect-core-1_0.html#IDToken">OpenID Connect</a> 那邊來的，除了這些定義好的屬性之外，還可以加上其它自訂的資料，只是這些已經被定義且<a href="http://www.iana.org/assignments/jwt/jwt.xhtml">註冊</a>好的名稱不能另做他用，OpenID Connect 也有不少個人資料的屬性已經註冊上 IANA 了，像是 <code>first_name</code>、<code>country</code> 之類的 profile 資訊，有一種使用 JWT 的方法就是直接把個人 profile 存在客戶端，server 只要驗證簽名是否正確，這樣一個好處是 server 不用保存 session 資訊，減少很多資源的需求，實做起來其實複雜度也比較低。另外由於是用作 token 之用，自然也可以當成 OAuth 的 token 使用，這部分資訊在 <a href="https://tools.ietf.org/html/rfc7523">RFC-7523</a> 這份文件有說明，至於要如何使用 OAuth token 則是在 <a href="https://tools.ietf.org/html/rfc6750">RFC-6750</a> 有介紹，比較常見的是放在 HTTP Auth Header 裡面：</p>

<pre><code>Authorization: Bearer eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
</code></pre>

<p>之前鴨七也有整理過中文的<a href="https://blog.yorkxin.org/2013/09/30/oauth2-6-bearer-token">說明</a>，看起來比較輕鬆，而且說明很完整（不過我承認我沒有從頭看到尾）。</p>

<p>目前搜尋 JWT 一定會看到一個網站 <a href="https://jwt.io/">jwt.io</a>，這個網站用淺顯易懂的方式來<a href="https://jwt.io/introduction/">介紹</a> JWT，把比較複雜的關係，像是 JWS、JWE 等等都隱藏起來幫助瞭解，還有一個線上除錯工具和不同語言的 library 整理，不過除錯工具只有支援 JWS，另外也有和一些其它類似標準做比較，還蠻值得看一看的，這個網站是由 <a href="https://auth0.com/">Auth0</a> 提供的，他們其實就是一家專門提供身分認證服務的公司，似乎都已經轉到使用 JWT 了，在 jwt.io 有提到他們似乎是把，我對這間公司之前印象是還不錯，一來是 API 文件看起來還蠻不錯的，另外有不少的開放原碼<a href="https://auth0.com/opensource">專案</a>，當然有一些是串接他們家服務用的 library 啦。</p>

<p>PS. 對密碼學還沒很熟悉，有誤歡迎指正～</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-08-13T18:46:54+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/">
<title>7 Bit Encoding and Email</title>
<link>https://blog.othree.net/log/2016/07/19/7bit-encoding-and-email/</link>
<description><![CDATA[<p>最近工作上比較常接觸到 email 的東西，然後比較認真的看了 HTML email 信件的內容，以前我以為都要用 base64 編碼來處理，可是用 base64 來處理 HTML email 我一直覺得很不合理，一來大小會變 1.33 倍，二來整個 HTML 原始碼傳送時會變的幾乎無法辨識，收信軟體還要先解碼一次才可以 parse HTML，感覺完全不需要多此一舉，總之就是覺得為什麼要做這麼愚蠢的事情，明明看起來 <a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 就沒這樣限制，所以我應該可以這樣寫：</p>

<pre><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>然後內文直接放 HTML 原始碼，可是不知道為什麼沒人這樣做，事實上也不 work；最近多看了一些郵件原始碼才發現其實還有個 Quoted-Printable encoding 也很常用，看起來比 Base64 的結果還要接近原始碼許多了，所以就研究了一下它到底是什麼格式。</p>

<p>Quoted-Printable encoding 的基本原理就是用 <code>=</code> 作為 escape 字元，然後可以把要轉換的字元轉成 <code>=字碼</code> 的形式，例如 Big5 中文的 <code>我</code> 就要轉成 <code>=A7=DA</code>，規範上要轉換的是除了可見（printable）<a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a> 字元以外的字元都要轉，而 ASCII 是個 7bit 編碼，字碼只有從 0 到 127 而已，而 email 要用 Quoted-Printable encoding 的主要原因其實就是為了讓文件內的每個字元編碼都維持在 7bit 編碼範圍內，現在大家常用的編碼像是 UTF-8 和以前常用的 Big5 等都是 8bit 編碼，兩者差別就在於每個傳輸的 byte 中有沒有使用到第 8 個 bit，轉成二進位的時候，7bit 系統編碼不會用到最左（higher-order）邊的那個 bit。</p>

<p>為什麼需要用 7bit 的文字編碼呢？主因是計算機和電信網路早期很多系統是只支援 7bit 編碼的，SMTP 的<a href="https://tools.ietf.org/html/rfc821#page-44">規範</a>就直接要求 TCP 傳輸時，每個 byte 最左邊的 higher-order bit 要填 0：</p>

<blockquote>
  <p>The TCP connection supports the transmission of 8-bit bytes.
The SMTP data is 7-bit ASCII characters.  Each character is
transmitted as an 8-bit byte with the high-order bit cleared to
zero.</p>
</blockquote>

<p>當然這規範很落後時代，所以在 <a href="https://tools.ietf.org/html/rfc2045#section-6">MIME（Multipurpose Internet Mail Extensions）</a> 規範其實也有 <code>Content-Transfer-Encoding</code> 可以指定傳輸用的是什麼編碼：</p>

<pre><code>Content-Transfer-Encoding: 8bit
</code></pre>

<p>不過為了相容舊系統，還是很少真的這樣使用的信件在傳遞，因為要是傳到了 7bit 系統，小則亂碼、大則程式當機。不過這就帶出另外一個問題了，難道 7bit 系統只能傳輸 ASCII 字集嗎？因為我還蠻常看到日文的純文字郵件，就去找了一些來看看，結果發現到有的是用 <code>ISO-2022-JP</code>，而且是使用 7bit 的傳輸：</p>

<pre><code>Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit
</code></pre>

<p>信件內容的文字也都很正確，沒有亂碼：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27751195323/" title="iso-2022-jp by othree, on Flickr"><img src="https://farm8.staticflickr.com/7684/27751195323_a423fd4cb4_b.jpg" width="708" height="558" alt="iso-2022-jp" srcset="" /></a></p>

<p>於是就看一下 <a href="https://zh.wikipedia.org/wiki/ISO/IEC_2022">ISO-2022</a> 的介紹，發現原來是個很早就有的 7bit 編碼方法，後來根據這方法有訂出了 CN、JP、KR 等語言的編碼，不過比較通行的看來只有 ISO-2022-JP，然後我也找到 HTML email 用 ISO-2022-JP 的：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28366990615/" title="ISO-2022-JP by othree, on Flickr"><img src="https://farm9.staticflickr.com/8572/28366990615_bc76dcce70_b.jpg" width="708" height="558" alt="ISO-2022-JP" srcset="" /></a></p>

<p>看起來就像是我理想中的 HTML email 原始碼啊，所以問題的癥結其實是，大家為了相容於舊系統，所以都用 7bit 傳輸，要 7bit safe 的 encoding 選擇有限，除了比較通行的 ISO-2022-JP 可以給日文用、字元太少只能給英文用的 ASCII 之外，其它語言就只能用 Base64 encoding 和 Quoted-Printable encoding 了，所以事實上其它 7bit 編碼的內容，也是可以直接透過 SMTP 協定來傳輸的，只是要看收信端的軟體能不能支援解碼，像是已經不太有人用的 <a href="https://zh.wikipedia.org/zh-tw/UTF-7">UTF-7</a> 就是 7bit 的 unicode 編碼。</p>

<p>最後，就是假設我們已經不用擔心老舊系統的時候，其實只要這樣寫在 MIME header 裡就可以直接傳 UTF-8 的 HTML source，不用再經過任何編碼處理了：</p>

<pre><code>Content-Transfer-Encoding: 8bit
Content-Type: text/html; charset=utf-8
</code></pre>

<p>不過距離這一步不知道還有多遠就是了。</p>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-19T13:28:23+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/16/hkoscon-2016/">
<title>HKOSCON 2016</title>
<link>https://blog.othree.net/log/2016/07/16/hkoscon-2016/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27315015884/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7526/27315015884_dd95e637b1_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7526/27315015884_dd95e637b1_b.jpg 1024w, https://farm8.staticflickr.com/7526/27315015884_5f8f452616_h.jpg 1600w" /></a></p>

<p>今年有幸可以參與<a href="https://2016.opensource.hk/">香港的 Open Source Conference</a>，這趟還承蒙 Mozilla 贊助交通費用，另外因為是講者的關係，住宿的部分則是 HKOSCON 幫忙。其實至少去年就想去了，不過去年因為事情比較多就放棄了，今年還乾脆的投稿分享，不過因為工作的關係，只有參加週六的議程，週五的部分就沒參加到了，聽的議程如下：</p>

<ul>
<li>回顧台灣自由開源軟體發展 by Jim Huang</li>
<li>Interactive Dashboard Development with Plotly by Mart van de Ven</li>
<li>Fluentd: Unified Logging Layer by Masahiro Nakagawa by Andy Shu</li>
<li>Optimizing Chinese Webfont &amp; Typography by Andy Shu</li>
<li>Mozilla Eir - Bring medical devices into the world of webby Kevin Hu</li>
<li>From Open Source to Open Media by Hsin-Chan Chien</li>
<li>My Mozilla Contributing Journey by Irvin Chen</li>
</ul>

<p>第一場就是 Jserv 介紹台灣以前的自由開源軟體的發展，我到會場的時候已經開始講的，介紹的比較是早期的發展，是我有參與到這個圈子前的時期，對我來說大部分都是，照我印象比在台灣之前說到的還要詳細些，不過我的聽幾次 Jserv 的分享感覺下來，就是大概進入 COSCUP 開始辦之後，參與發展在地化的自由開源軟體的人卻越來越少，當然我自己也是沒參與啦，其實曾經我本來要幫忙新酷音的網站（目前是 <a href="http://blog.kidwm.net/">WM</a> 維護），不過因為一些奇妙的原因我就沒幫上了。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27850155241/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7351/27850155241_5c22604d7e_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7351/27850155241_5c22604d7e_b.jpg 1024w, https://farm8.staticflickr.com/7351/27850155241_5f052102f4_h.jpg 1600w" /></a></p>

<p><a href="https://plot.ly/">Plotly</a> 則是一個 plot library，我是沒很注意聽，有興趣可以自己研究一下優缺點，目前這市場似乎有點飽和，可能等真的有需求時再來研究吧。</p>

<p><a href="http://www.fluentd.org/">Fluentd</a> 是最近蠻多人會用的 log 收集中間人，我目前工作上雖然沒有直接接觸，到是有間接使用到，不過我到來聽這場的這時候才知道，原來作者是日本人，不得不說有點意外，來講的是 Masahiro Nakagawa，是目前專案上排第二的開發者。</p>

<p>Optimizing Chinese Webfont &amp; Typography 這場的重點其實就是動態組字形技術，以前台灣這邊也有人在弄，有商業化的就是 <a href="http://www.justfont.com/">justfont</a> 了吧，不過沒想到這技術現在也有開源專案提供了，這場 Andy 介紹的是 <a href="https://github.com/aui/font-spider">font-spider</a> 這個專案，有興趣的可以自己玩玩看。PS: 我覺得 justfont 不斷拓展方向的策略還蠻正確的，不然單靠 Webfont 就蠻危險的。</p>

<p><a href="https://wiki.mozilla.org/Eir">Mozilla Eir</a> 則是第一場 Mozilla 相關的主題，主要是介紹 Mozilla 參與醫療器材平台發展的專案，目前還在蠻初期的，個人感覺還在規劃和討論的階段，所以還沒有實際的成果或是可以 demo 的東西。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27927183155/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7421/27927183155_b62eedb67d_b.jpg" width="683" height="1024" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7421/27927183155_b62eedb67d_b.jpg 683w, https://farm8.staticflickr.com/7421/27927183155_8da1d310a3_h.jpg 1067w" /></a></p>

<p>From Open Source to Open Media 則是 HC 從 OSDC 到現在<a href="https://www.twreporter.org/">報導者</a>之間的歷程，聽完之後覺得經濟動能推升方案那支<a href="https://www.youtube.com/watch?v=RAbD3AGFX6I">廣告</a>，當時看覺得是什麼鬼，現在看覺得效用真的很大啊(?)，然後就讓我想到 g0v 有一個推人入坑的方法，就是先弄一個糟糕的版本推上線，然後就會有人受不了出來修改。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27648624360/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7414/27648624360_588fb64815_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7414/27648624360_588fb64815_b.jpg 1024w, https://farm8.staticflickr.com/7414/27648624360_fd2c5e426e_h.jpg 1600w" /></a></p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27648621990/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7448/27648621990_061e86fb62_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7448/27648621990_061e86fb62_b.jpg 1024w, https://farm8.staticflickr.com/7448/27648621990_221a77e794_h.jpg 1600w" /></a></p>

<p>My Mozilla Contributing Journey 這場則是 <a href="https://reps.mozilla.org/u/irvin/">Irvin</a> 自己從開始參與 Moztw 社群到現在一路的歷程，因為參與 Moztw 而有了什麼收穫等等，我印象中有這樣明確整理出因為參與開源社群而獲得的收穫的分享，好像是沒有，有興趣的話，他在 SITCON 夏令營還會再講一次，有興趣的或許...報名好像結束了就是。</p>

<p>除了上面聽的兩場和 Mozilla 相關的題目之外，還有一場我沒聽的是 Gary 的演講，題目是之前講過的 Fuzzy Test，不過是 2016 年版，Fuzzy Test 我覺得真的是自動化整合測試最後一關了，基本上就是把所有正常的操作都測試完之後，就來測個不正常的操作吧，那怎樣產生不正常的操作流程呢，就是可以用 Fuzzy 的方法來產生，不過他自己有說今年 Mozilla 在這邊的資源變少了；其實我覺得 Mozilla 最近方向實在是不太明確，我印象中的整個轉捩點大概是 Brendan Eich 下台開始，然後 Firefox OS 的市佔率也起不來，Firefox 的發展也越來越跟不上 Chrome，像是 e10s 就一直都還不太行，真的是蠻讓人擔心的，好在是短時間還<a href="http://www.recode.net/2016/7/7/12116296/marissa-mayer-deal-mozilla-yahoo-payment">不需要擔心資金問題</a>的樣子。</p>

<p>然後還有一場間接相關的就是我的<a href="https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/">分享</a>了，這個題目本來是有考慮投 COSCUP 的，後來還是投到 HKOSCON 這邊，也是我第一次嘗試用英文演講，可惜我練習不夠，講的實在不好，很多地方都覺得好像沒正確的講清楚，下次還有機會用英文演講的話應該還是會再試一次，希望下次練習更充分，表現正常些，不然就要上場前喝罐啤酒試試看了，根據我之前的試驗結果，好像喝過酒的情況下，講的會比較流暢XD。</p>

<p>除了演講外，還有一區有廠商攤位，還有一個 Job Board 版面可以給人貼徵才資訊，攤位的部分，IBM、VLC、Google、HKLUG﹑自由香港字型等是我比較有印象的，IBM 是介紹他們的 AI as Service 的服務，紀念品當中還有一些 for Dummies 系列叢書：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27927181435/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7609/27927181435_4acfb018f0_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7609/27927181435_228502eb76_k.jpg 2x" /></a></p>

<p>Google 不知道怎麼會願意來擺攤，沒跟他們聊聊，台灣 Google 好像還沒在社群擺過攤的樣子，如果有錯還請幫忙更正，不過總之我拿到 Chrome 貼紙了，這樣曾經的五大瀏覽器，Chrome、IE、Firefox、Opera 的紀念品我都有拿到過了，只差一個台灣實在很難碰到的 Apple 的 Safari 而已。</p>

<p>自由香港字型則是一群人要造屬於香港字的自由字型而聚集起來的社群，主因是因為香港漢字其實有一些字的寫法、筆畫和台灣日本的不一樣，例如下圖中間的「周」：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27315002094/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7408/27315002094_4a9bd2c75a_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7408/27315002094_38e0b5baee_k.jpg 2x" /></a></p>

<p>然後過去又沒有可以自由使用的字型可以用，所以開始了這個計畫，相信大家也都知道要造一套字型有多大難度，所以這社群有些成果出來真的是很厲害。</p>

<p>整個 HKOSCON 規模比台灣常參加的研討會還要小一些，不過參與的外國人比例感覺比較高，英文議程也多一些，相較來說是對外國會眾友善不少，當然我想英文在香港比較流通也是主因之一，在台灣要做到國際化的研討會實在不太容易，目前比較常見的問題包括：翻譯問題，雖然可以靠口譯解決，不過成本瞬間提升，光靠贊助很難，所以幾乎是要全商業化的形式才比較有可能，票價也會因此和國際接軌；入境問題，中國人要到台灣困難度很高（好像還有幾個國家要來也很困難，一時忘了），這也造成一些國際研討會亞洲場不考慮台灣的原因，這問題很難靠主辦解決就是。</p>

<p>最後還是要感謝 Mozilla 的贊助，還有 HKOSCON 大會和 Sammy Fung 的協助讓這趟行程可以很順利的完成，Sammy 也是 COSCUP 的常客，前陣子還開始了 <a href="http://opensource.asia/">opensource.asia</a> 這個網站，收集亞洲相關的 Open Source 活動，大家有興趣可以 COSCUP 活動時找他聊聊。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/27315009874/" title="HKOSCON 2016 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7415/27315009874_b5eec57431_b.jpg" width="1024" height="683" alt="HKOSCON 2016" srcset="https://farm8.staticflickr.com/7415/27315009874_96c3e64b8c_k.jpg 2x" /></a></p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-16T16:55:13+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/14/web-push/">
<title>Web Push</title>
<link>https://blog.othree.net/log/2016/07/14/web-push/</link>
<description><![CDATA[<p>前兩天要研究一下 Chrome 接 GCM 的實做，發現到 Google 又出一個新的服務叫 Firebase，然後新的 cloud messaging 服務就叫 <a href="https://firebase.google.com/docs/cloud-messaging/">Firebase Cloud Messaging(FCM)</a>，隨便看了一下 Google 官方的文件，結果發現有提到另外一個正在制訂中的 <a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-07">Web Push Protocol</a>，照文件的說法，FCM 也只是個過渡時期的方案，最終目標還是用這個 Web Push Protocol，於是我就研究了一下他的設計，發現設計的還蠻漂亮的。</p>

<p>整個 Web Push Protocol 的基本架構如下圖：</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28277091075/" title="Web Push Protocol by othree, on Flickr"><img src="https://farm8.staticflickr.com/7633/28277091075_ecdf54fc60_b.jpg" width="493" height="263" alt="Web Push Protocol" srcset="" /></a></p>

<p>User Agent(UA) 通常是行動端的應用程式、Application 則是自家服務的後台；整個流程首先是 UA 透過 HTTP/1.1 POST 去跟 Push Service 訂閱（第一條橫線 Subscribe），然後會拿到一個 subscription resource，可能長成：</p>

<pre><code>https://push.example.net/subscription/LBhhw0OohO-Wl4Oi971UG
</code></pre>

<p>另外還會拿到一個發訊息用的 push resource：</p>

<pre><code>https://push.example.net/push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV
</code></pre>

<p>可以注意到兩個 resource 後面的 token 是不一樣的，兩者之間的 mapping 就是 Push Service 來負責；然後 UA 拿到這兩個網址後，發訊息用的 push resource 要交給自家服務的後台，也就是圖上第三條橫線 Distribute Push Resource，另外一個 subscription resource 則是要自己使用，UA 用 HTTP/2 打 GET 到 subscription resource，然後 push service 會把連線保持住不關掉，這就是圖上的第二條橫線 Monitor；自家服務後台的要送訊息的時候，就打 POST 去 push resource，也就是第四條橫線，從 Application 到 Push Service 間的 Push Message，push service 收到這個訊息時，就利用 HTTP/2 的 Server Push 機制主動傳送訊息，最後這個動作就是第五條橫線的 Push Message 了。</p>

<p>就這樣很漂亮的用 HTTP/1.1 + HTTP/2 把一個基本的 Cloud Message Service 的協定建構起來，而除了這最基本的訊息傳遞外，這份文件還有定義像是訊息重要度、訊息回條、群組訊息等等的方法，設計都還蠻漂亮的，安全性的部分則是限制走 HTTPS over TLS，還有 operation 相關的說明，像是實際上要跑起這個服務，需要大量的 TCP connection 等等（因為都走 HTTP 了），有興趣的可以加減看一下。</p>

<p>補充：Firefox 目前實做的似乎就是這個協定更早版本的草案</p>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-14T12:40:19+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/">
<title>YAJS.vim and Vim Syntax Highlight</title>
<link>https://blog.othree.net/log/2016/07/01/yajs-and-vim-syntax-highlight/</link>
<description><![CDATA[<p>上個週末在<a href="https://2016.opensource.hk/">香港 Open Source Conference</a> 分享的主題，第一次使用英文分享，結果表現不太好，不知道上場前喝點啤酒會不會比較好就是...</p>

<p>這個主題本來是想要投 COSCUP 的，主要是想介紹一下之前在做 <a href="https://github.com/othree/yajs.vim">yajs.vim</a> 時遇到的比較有印象的問題，在這之前先介紹一下 Vim Syntax Highlight 的機制，因為這些問題很多都和 Vim 的 Syntax Highlight 機制的設計關係很大，然後最後就是有一個還沒辦法解的問題，這個問題就是 yajs.vim 目前還沒辦法完美的 highlight 有 default parameter 的 arrow function。</p>

<script async="async" class="speakerdeck-embed" data-id="3294147a503d4079a6238296fc991a76" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>
]]></description>
<dc:subject>vim</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-07-01T17:05:37+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/04/22/nginx-fcgiwrap/">
<title>nginx &amp; fcgiwrap</title>
<link>https://blog.othree.net/log/2016/04/22/nginx-fcgiwrap/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/23099768130/" title="菲貓 by othree, on Flickr"><img src="https://farm1.staticflickr.com/621/23099768130_3caf60c59d_b.jpg" width="1024" height="683" alt="菲貓, " srcset="https://farm1.staticflickr.com/621/23099768130_3caf60c59d_b.jpg 1024w, https://farm1.staticflickr.com/621/23099768130_d3a13dc95b_h.jpg 1600w" /></a></p>

<p>雖然很久以前就想換到 nginx 試試看，不過直到最近這次更新才換成功，最早單純只是想要輕量一點的 HTTP server，後來則是因為和 Apache 相比，nginx 明顯開發更新比較快，最近有很多想要嘗試各種新功能都是 nginx 先做，像是 HTTP/2，還有最近這次的 brotli 支援，而以前沒辦法換過去的最主要原因，其實是 nginx 沒有 CGI 的支援，跑 MovableType 會有困難，雖然 MovableType 可以用 FastCGI，不過很難設定，我安裝過 n 次大概也只有成功過一兩次，所以其實一直都不太考慮這個選項。</p>

<p>不過認真研究了一下，終於發現其實可以透過 <a href="https://github.com/gnosek/fcgiwrap">FCGI Wrap</a> 這個工具來達成 nginx 對 CGI script 的支援，它的作法其實就是一個中間人，把 FCGI 介面轉到 CGI 介面過去，我大概設定了一下跑 MovableType 的 nginx conf 如下：</p>

<pre><code>location ~ ^/path/to/mt/mt.*\.cgi {
    gzip off;
    fastcgi_index index.cgi;
    fastcgi_split_path_info ^(.+?\.cgi)(/.*)$;
    if (!-e $document_root$fastcgi_script_name) {
        return 404;
    }
    include fastcgi.conf;

    ## MT-related
    fastcgi_param PERL5LIB $document_root/mt/lib;
    fastcgi_param MT_HOME $document_root/mt/;
    fastcgi_param MT_CONFIG $document_root/mt/mt-config.cgi;

    fastcgi_param PATH_INFO $fastcgi_path_info;
    fastcgi_param PATH_TRANSLATED $fastcgi_path_info;
    fastcgi_pass unix:/var/run/fcgiwrap.sock;
}
</code></pre>

<p>然後主機上要開好 FCGI Wrap 的服務，我是用 ArchLinux 的 pacman 直接裝套件，然後參考<a href="https://wiki.archlinux.org/index.php/nginx#fcgiwrap">官方文件</a>，有寫說設定檔位置 <code>/usr/lib/systemd/system/fcgiwrap.socket</code> ，cat 出來就可以看到 UNIX Socket 檔案位置 <code>ListenStream=/run/fcgiwrap.sock</code> ，這個路徑的位置其實就指到上面設定最後一行的 <code>/var/run/fcgiwrap.sock</code>，<code>/run</code> 和 <code>/var/run</code> 兩邊其實有 Symbolic Link 起來，所以兩個 sock 檔案其實是同一個。</p>

<p>最後要說一下 conf 裡的這行：</p>

<pre><code>    include fastcgi.conf;
</code></pre>

<p>這個 <code>fastcgi.conf</code> 檔案其實是 nginx 內建好方便大家使用的，內容如下：</p>

<pre><code>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;

fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
fastcgi_param  REQUEST_URI        $request_uri;
fastcgi_param  DOCUMENT_URI       $document_uri;
fastcgi_param  DOCUMENT_ROOT      $document_root;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;
fastcgi_param  REQUEST_SCHEME     $scheme;
fastcgi_param  HTTPS              $https if_not_empty;

fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;

fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  REMOTE_PORT        $remote_port;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;

# PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param  REDIRECT_STATUS    200;
</code></pre>

<p>可以看到其實這個檔案就是把直接走 FCGI 時會遺失的環境變數補回去用的，nginx 還提供很多這類<a href="https://github.com/nginx/nginx/tree/master/conf">檔案</a>，以前都不太清楚怎麼剛裝好的 nginx 會附上一堆沒有用到的 conf 檔，直到這次才瞭解它們其實都很有用啊。</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-04-22T21:52:05+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/04/10/360-test/">
<title>360 Test</title>
<link>https://blog.othree.net/log/2016/04/10/360-test/</link>
<description><![CDATA[<p><a data-flickr-embed="true" data-vr="true"  href="https://www.flickr.com/photos/othree/25933704672/in/dateposted-public/" title="摩茲工寮"><img src="https://farm2.staticflickr.com/1478/25933704672_4e4641723f_b.jpg" width="1024" height="512" alt="摩茲工寮" /></a></p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-04-10T19:21:34+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/04/08/purecss/">
<title>Pure.css</title>
<link>https://blog.othree.net/log/2016/04/08/purecss/</link>
<description><![CDATA[<p>最近做的修改還有一個就是把 <a href="http://getbootstrap.com/">Bootstrap</a> 換掉，因為我覺得它實在是太大了，包進很多我沒用到的東西，即使是壓縮過的版本也要上百 KB，其實我只需要一部份的元件，像是圖片、引言、程式碼和 grid layout 等，但是這些部分的 CSS 所佔的比例其實超級少，所以我決定找一個新的 framework 把它換掉，結果我挑的是 Yahoo 已經沒有繼續更新的專案 <a href="http://purecss.io/">Pure.css</a>。</p>

<p>Pure.css 檔案大小比起 Bootstrap 實在小很多，最小化過的版本只有約 17KB，不過 responsive grid layout 的部分是獨立的，該模組的大小約是 9.57KB，和原來使用 Bootstrap 相比，總共大概是只有原來的四分之一（當然 gzip 後沒差這麼多），不過檔案小這麼多一定有所犧牲，Pure.css 提供的元件比起 Bootstrap 來少很多，而且提供的我幾乎都沒用到，最後我只用到 menu 和 grid layout 兩個部分而已，所以又從 Bootstrap 那邊把我要的元件手工複製出來使用，最後整理出來的 CSS 是 36.15KB，gzip 後是 7.3KB，brotli 壓縮過後是 6.34KB，傳輸前的資料量和原來相比大約是三分之一至四分之一，使用 gzip 壓縮傳輸的資料量則是三分之一左右（相較於原本的 18.97KB），整體來說成效不錯，其實 Framework 的部分還是佔了很大的比例，所以下一步就是把整個 CSS Framework 拿掉了，我推估實際上我需要的這些 CSS 大概 3KB 的資料量就夠了。</p>

<p>不過 Pure.css 是個已經沒在維護的專案了，Github 上已經超過一年沒有動靜，再加它其實沒 Bootstrap 那樣簡單用，有很多細節都還是要自己處理，就連它們首頁應該都是加工不少才出來的，所以要用這套 CSS Framework 的人還是要三思啊。</p>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-04-08T22:48:28+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/04/05/ssh-agent-forward/">
<title>SSH Agent Forward</title>
<link>https://blog.othree.net/log/2016/04/05/ssh-agent-forward/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/26226715966/" title="少年バット by othree, on Flickr"><img src="https://farm2.staticflickr.com/1544/26226715966_bcd656f05b_b.jpg" width="1024" height="576" alt="少年バット" srcset="https://farm2.staticflickr.com/1544/26226715966_bcd656f05b_b.jpg 1024w, https://farm2.staticflickr.com/1544/26226715966_1afbf9905d_h.jpg 1600w" /></a></p>

<p>最近對於 blog 的另外一個改動就是檔案權限的修改，我用的 Blog 系統是 MovableType，它的其中一個特色就是會產生好靜態的檔案，而這些檔案其實我都有丟上 Github 和 Bitbucket 備份，以前我基本上都用 root 來做這些事情，所以沒有權限問題，不過這次重灌後想順便把這問題處理一下，所以做了一番研究，首先在 ArchLinux 上，預設給 HTTP 等相關服務例如 nginx、php 等用的帳號是 <strong>http</strong>，所以我希望讓這些檔案的 owner 就是 http，一來可以確保所有的網路服務需要這些檔案時，都可以正確的存取，因為我嘗試過用 group 來設定權限共有，不過結果不太順利；二來 MovableType 產生的檔案 owner 也都是 http，可以保持一致性，也不用常常在那邊改檔案的 owner。</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-04-05T22:22:39+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/04/05/kyushu-rail/">
<title>九州鐵道</title>
<link>https://blog.othree.net/log/2016/04/05/kyushu-rail/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/23906413032/" title="九洲JR by othree, on Flickr"><img src="https://farm2.staticflickr.com/1631/23906413032_de2b68a752_b.jpg" width="1024" height="683" alt="九洲JR" srcset="https://farm2.staticflickr.com/1631/23906413032_de2b68a752_b.jpg 1024w, https://farm2.staticflickr.com/1631/23906413032_280443efa8_h.jpg 1600w" /></a></p>

<p>之前去了一趟九州，順便觀察了一下聽說很厲害的九州鐵道（不只是 JR），覺得果然名不虛傳，整個就是設計的比較有質感，不論是普通車還是特急列車都感覺的出來比其他地區的還要搶眼些，這次搭到比較特別的列車是特急KAMOME（特急かもめ），從博多到長崎，還有由布院之森（ゆふいんの森），從久留米到由步院，首先就來看一下特急KAMOME（以下圖多）。</p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-04-05T10:26:33+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/03/21/brotli-gzip-alt/">
<title>brotli, gzip 的替代格式</title>
<link>https://blog.othree.net/log/2016/03/21/brotli-gzip-alt/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/23998562432/" title="湯布院 by othree, on Flickr"><img src="https://farm2.staticflickr.com/1692/23998562432_ec46795cd9_b.jpg" width="1024" height="683" alt="湯布院, " srcset="https://farm2.staticflickr.com/1692/23998562432_ec46795cd9_b.jpg 1024w, https://farm2.staticflickr.com/1692/23998562432_d3f328fdaf_h.jpg 1600w" /></a></p>

<p>最近幫 blog 做了不少的調整，最近會慢慢整理放上來，其中的第一個修改就是支援 <a href="https://github.com/google/brotli">brotli</a> 了，brotli 是 Google 繼 <a href="https://github.com/google/zopfli">Zopfli</a> 之後，又一個針對網路傳輸做的貢獻，兩者都是用瑞士的麵包來命名，Zopfli 是 <a href="http://google-opensource.blogspot.tw/2013/02/compress-data-more-densely-with-zopfli.html">2013 年 2 月發佈</a>，Brotli 是在 <a href="http://google-opensource.blogspot.tw/2015/09/introducing-brotli-new-compression.html">2015 年 9 月發佈</a>的，不過直到最近才有瀏覽器支援，最先支援的是 Firefox，接著才是 Google 的 Chrome，預計版本號 50 時會支援，brotli 在發表時就同時發表一份<a href="http://www.gstatic.com/b/brotlidocs/brotli-2015-09-22.pdf">測試數據</a>了，顯示出它可以讓文件檔案更小約 20%，但是加解密的速度還是和 gzip 差不多，相信對於行動裝置的耗能也不會差異太大，不過對大檔案的壓縮效率就不一定比較好了，基本上非常適合拿來壓縮一般網站傳輸的 HTML/CSS/JS 之類的檔案。</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-03-21T13:43:51+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/02/28/device-pixel-ratio-header/">
<title>Device Pixel Ratio Header</title>
<link>https://blog.othree.net/log/2016/02/28/device-pixel-ratio-header/</link>
<description><![CDATA[<p>之前<a href="https://blog.othree.net/log/2012/10/28/device-pixel-ratio/">文章</a>有介紹過 DPR（Device Pixel Ratio），不過當時只能透過 JavaScript 在 client 端存取，如果 server 端要知道 client 端的 DPR 至少得要來回交換一次資訊，在那個時候就有想過應該之後會有新的標準來負責處理這個問題，而最近終於看到標準的草案了，叫做 <a href="http://httpwg.org/http-extensions/client-hints.html">HTTP Client Hints</a>，照字面的意思，這個 HTTP 擴充標準不是只有 DPR，而是提供 client 端的一些資訊，目前包括了：</p>

<ul>
<li>DPR</li>
<li>width</li>
<li>viewport-width</li>
<li>downlink</li>
</ul>

<p>其中 <code>DPR</code> 就是 device pixel ratio；<code>viewport-width</code> 就和以前介紹過的 viewport width 一樣；<code>width</code> 比較特別，是實際希望的 resource 寬度，而不是真的屬於 device 的資訊，例如圖片在網頁內是 160px，裝置的 DPR 是 2，<code>width</code> 就是 160×2 = 320px；最後一個 <code>downlink</code> 則是以前一直很難取得的網路速度，以前最大的限制在於不管是 client 端還是 server 端都很難取得實際的網路速度，雖然可以用 JavaScript 下載檔案算時間來取得素質，但是這樣的作法其實有個兩難的問題，一方面問題是如果檔案大小，那取得的數字會很不準確，另一方面問題是如果檔案太大，那必然就是浪費時間和網路頻寬，更不用說很多地方沒有吃到飽方案可以用，這樣的作法應該不會太受歡迎，甚至如果不測速度，搞不好都已經把網頁讀好了。現在把這個資訊的提供者更往上一層，改成由瀏覽器提供，瀏覽器就可以跟作業系統作溝通，就比較有機會不用先測速就拿到可以參考的網路速度。這些 Header 傳輸的時候都不用附上單位，只有數字，其中 downlink 的單位是 Mbps，而規範所希望瀏覽器提供的 downlink 數字是參考 <a href="https://w3c.github.io/netinfo/#downlinkmax-attribute">Network Information API</a> 這份 API 裡面整理的，主要連線方法的理論速度上限，例如 GSM 就是 0.01、LTE 是 100﹑wifi 802.11g 是 54，本來是想說這個數字是看瀏覽器自己決定，不只根據連線的方式，還會看實際的傳輸數字或是使用者偏好，例如他可能使用 LTE 但是因為不是吃到飽，所以希望把速度報低一點之類的。</p>

<p>Downlink 其實會比預期的還要有用，除了可以根據網路速度決定回傳的圖片大小外，還可以根據 downlink 大小來決定要回傳的 CSS，實際上使用可能像是，網路慢的時候就給出比較輕量的 CSS 回去給 client 端，用不一樣的版面呈現給使用者，有點像是 Google 的 <a href="https://www.ampproject.org/">Accelerated Mobile Pages Project</a>  所做的。</p>

<p>Client hint header 是個需要 opt-in 的擴充功能，就是預設是沒開的，那要怎麼開啟呢，就是在網頁 document 的 header 加上 <code>Accept-CH</code>：</p>

<pre><code>Accept-CH: "DPR, Downlink"
</code></pre>

<p>或是加上 meta tag</p>

<pre><code>&lt;meta http-equiv="Accept-CH" content="DPR, Width, Viewport-Width"&gt;
</code></pre>

<p>其中 equiv 是 equivalent 意思，就是和 HTTP header 等效的意思，透過這個 header 跟瀏覽器說 server 端可以接收 client hint 資訊，然後支援的瀏覽器就會在後續，這個網頁所需要用到的其它資源，像是 js, css, 圖片等等的 request 都加上這些資訊，這個溝通過程其實就是使用已經很久的機制： <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">HTTP content negotiation</a>，用的 header 也是 <code>Accept</code> 開頭的，目前已經支援的還只有 Chrome，而且要 46 版以後，其他幾個瀏覽器大多都還在討論要不要支援，Firefox 是有一些<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=935216">進度</a>。</p>

<p>這樣的設計其實有點先進，不完全是褒意，因為這意味著要 server 端，負責提供圖片的服務器，收到 request 後去看 DPR 或是 width 之類的資訊再來挑選要回傳哪一張圖片回去，而通常提供圖片靜態檔案的服務都不太有邏輯處理，大部分就是簡單的 HTTP server，只看靜態檔案，有就傳檔案回去，沒有就回傳 404，相信之後是會有些 module 或是設定的方法讓 HTTP server 可以把這部分直接處理掉，不過一些規模比較大的網站，如果有用上 CDN 的，可能就沒法直接用上這功能，還要等看有沒有 CDN 廠商支援。</p>

<p>Client hint 目前看來會是 responsive image 未來的一個主要解法，和 media query 相比其實有兩個很大的差異，第一個是 media query 是馬上（且隨時）發生效果，和 HTTP request 是無關的，所以一開始下載下來的網頁就會發生效果，但是 client hint 要透過第一個 HTML document 本身的 request 進行溝通，意味著 HTML document 本身的 request 是不會收到 client hint。第二個就是 media query 是隨時發生作用的，即使在網頁完整讀取下來後，還是有可能因為使用者造成的 client 環境變化，而讓瀏覽器去多下載一份檔案，最常見的情形就是調整視窗大小，在手機上可能就是轉直轉橫造成 viewport 寬度變化，甚至在 Mac 如果外接普通螢幕，拖拉瀏覽器視窗到不同螢幕也會造成影響，如果這些變化剛好符合設定的 media query，DPR 從 1 變成 2，就會讓瀏覽器又去下載了一張 DPR 不同的圖片，這類狀況在網路頻寬有限的環境下實在不是好事，而用 client hint header 的話就完全不會有這種狀況了，就只會有一開始帶著 Client Hint 去抓下來的那個檔案。</p>

<p>不過 Client Hint 也不是完全沒有副作用，目前最大的問題就是這幾個新 header 都不列在 <a href="https://fetch.spec.whatwg.org/#simple-header">simple headers</a> 裡面，所以在做 CORS request 的時候，本來不用 preflight request 的都會變成需要 preflight request 了，這個問題其實現在還在討論，因為其實有很多類似的新 header 都會造成一樣的問題，像是 CSP、Server-Sent Events 裡面的 Event-ID，主要是這麼多 Header 進去，就不 simple 了，而且照最近標準發展的狀況來看，這份 simple headers 的清單很難固定不變，有興趣的可以跟一下<a href="https://github.com/whatwg/fetch/issues/52">討論</a>。</p>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-02-28T14:34:04+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/02/06/how-to-reduce-pdf-size/">
<title>How to Reduce PDF Size and Keep Text</title>
<link>https://blog.othree.net/log/2016/02/06/how-to-reduce-pdf-size/</link>
<description><![CDATA[<h4>Requirement</h4>

<p>Small size of PDF file generated from PSD, with real text(for accessibility) and good image quality.</p>

<h4>Expect</h4>

<p>Expect the PDF file size is a little bit larger than JPG file.</p>

<h4>Issue</h4>

<p>Use <strong>save as</strong> and choose <strong>Photoshop PDF</strong> will generate large PDF. But save as JPG/PNG is much smaller. Test file spec:</p>

<ul>
<li>Page Size: 210mm*297mm (A4)</li>
<li>Resolution: 1240px*1754px</li>
<li>Fonts: 2 English font</li>
</ul>

<p>Sizes:</p>

<table>
<thead>
  <tr>
    <th>Format</th>
    <th>Option</th>
    <th>Size</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>PSD</td>
    <td></td>
    <td>79.7MB</td>
  </tr>
  <tr>
    <td>PNG</td>
    <td></td>
    <td>&#160;1.2MB</td>
  </tr>
  <tr>
    <td>JPG</td>
    <td>q: 100</td>
    <td>&#160;0.6MB</td>
  </tr>
  <tr>
    <td>PDF</td>
    <td>default</td>
    <td>&#160;7.0MB</td>
  </tr>
</tbody>
</table>

<p>File transformed on Adobe CC 2016 Jan </p>

<p>Tried several methods to reduce the file size includes:</p>

<ul>
<li>Remove unused layers</li>
<li>Merge and flatten all layers</li>
<li>Use lower jpeg compression quality</li>
<li>Not save meta data</li>
<li>Not preserve Photoshop editing capability</li>
<li>Use Photoshop autotool > PDF presentation</li>
<li>Use Illustrator</li>
<li>Use Acrobat Pro to optimize PDF</li>
</ul>

<p>But none of them can really make the PDF file as small as expected.</p>

<h4>Solution</h4>

<p>Separate the text and image. Also create a clean PSD file. Steps:</p>

<ol>
<li>Hide all text layers</li>
<li>Save as PNG file</li>
<li>Open PNG file in Photoshop</li>
<li>Unhide text layers and copy text layers to PNG file (should place at right place)</li>
<li>Save as Photoshop PDF file</li>
</ol>

<h5>Result</h5>

<table>
<thead>
  <tr>
    <th>Format</th>
    <th>Option</th>
    <th>Size</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>JPG</td>
    <td>q: 100</td>
    <td style="text-align: right">618.0KB</td>
  </tr>
  <tr>
    <td>PDF</td>
    <td>default</td>
    <td style="text-align: right">624.0KB</td>
  </tr>
</tbody>
</table>

<p>PS. I think other vector object can also use this method to keep their quality and maintain PDF in small size. But not tested.</p>
]]></description>
<dc:subject>software</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-02-06T10:10:15+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2016/01/11/json-universe/">
<title>JSON Universe</title>
<link>https://blog.othree.net/log/2016/01/11/json-universe/</link>
<description><![CDATA[<p><a href="http://json.org/">JSON</a> 在這幾年不但<a href="https://www.ietf.org/rfc/rfc4627.txt">標準化</a>，還開始漸漸的取代了 XML，成為網路上主要的資料交換格式，我認為主要的原因在於他相對於 XML 簡單好懂好用很多，另外一個優點就是他格式很簡單好懂，學起來很快，而相較於更傳統的 Form URL encode 的資料傳輸格式，我覺得最大的優點是他多了 Data Type，而且也可以一口氣送出結構化的資料，傳統的 Form URL encode 雖然有 key value pair，也可以用 <code>[]</code> 模仿出陣列，不過他的所有的 value 都是字串，在 server 端都還要自己判斷欄位，手動做一次型別轉換。只是雖然 JSON 很好上手，還是有幾個地雷容易踩到，如果是會寫 JavaScript 的人更容易中招，大概列舉一下：</p>

<ul>
<li>不支援註解</li>
<li>物件的 key 一定要用字串型式，就是一定要用引號框起來</li>
<li>字串一定要用雙引號，不能用單引號</li>
<li>陣列或物件的最後一個元素後面不能加逗點（ES5 允許）</li>
</ul>

<p>當然要避免這些問題，最保險就是用各個語言已經有人實做好的函示庫來處理，而不要自己用組字串的方式來產生 JSON string。不過這篇文章不是要講這些，其實會想寫這篇文章是從 <a href="https://blog.othree.net/log/2015/12/25/jsx-e4x/">E4X</a> 那篇文章開始來的，那篇文章有提到 E4X 已經被棄用了，而 Mozilla 建議的替代方案是一個叫 JXON 的東西，名字看起來和 JSON 很像，而事實上除了 JXON，還有一堆名稱和 JSON 很相近的相關技術，像是 JSONH、BSON、LJSON ...等等，不過其實我找不太到有人去收集這些東西，所以就決定自己來整理一下，這篇文章就是要來介紹一下這堆 JSON 衍生出來的東西，以下沒照特定排序。</p>
]]></description>
<dc:subject>script</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2016-01-11T22:38:31+08:00</dc:date>
</item>


</rdf:RDF>