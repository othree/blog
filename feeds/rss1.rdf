<?xml version="1.0" encoding="utf-8"?>

<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:admin="http://webns.net/mvcb/"
xmlns:cc="http://web.resource.org/cc/"
xmlns="http://purl.org/rss/1.0/">

<channel rdf:about="https://blog.othree.net/">
<title>O3noBLOG</title>
<link>https://blog.othree.net/</link>
<description></description>
<dc:creator></dc:creator>
<dc:date>2022-08-23T22:27:35+08:00</dc:date>
<admin:generatorAgent rdf:resource="http://www.movabletype.org/?v=4.381" />

<cc:license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/1.0/" />


<items>
<rdf:Seq>
<rdf:li rdf:resource="https://blog.othree.net/log/2022/08/23/http-103-early-hints/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2022/08/18/shopify-app/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2022/07/31/coscup-2022/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2021/09/10/does-cat-understand-what-we-say/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2021/08/12/csp-for-lambdaedge/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2021/08/02/static-site-hosting/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2021/07/19/macos-my-pref/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2021/05/20/berserk/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/11/29/intrinsic-aspect-ratio-of-incomplete-image/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/11/25/scroll-margin-padding/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/11/20/realforce-r2-mac-key-mapp/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/08/06/usb-cdisplayport/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/08/01/upgrade-my-monitor/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/07/17/safari-3rd-party-cookie/" />

<rdf:li rdf:resource="https://blog.othree.net/log/2020/05/02/2019/" />
</rdf:Seq>
</items>

</channel>


<item rdf:about="https://blog.othree.net/log/2022/08/23/http-103-early-hints/">
<title>HTTP 103 Early Hints</title>
<link>https://blog.othree.net/log/2022/08/23/http-103-early-hints/</link>
<description><![CDATA[<p>前幾天晚上前同事陶百貼了個 Tweet，說到 Chrome 要移除 HTTP/2 Server Push 了：</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">HTTP/2 PUSH is finally going away in Chrome 106: <a href="https://t.co/FFL8hmkRyf">https://t.co/FFL8hmkRyf</a><br /><br />HTTP 103 is the best way to early-hint out-of-band.<br /><br />Thanks to the community and teams that made this possible (standards teams for 103, CDNs for implementing, Net team, huge effort)</p>-- Patrick Meenan (@patmeenan) <a href="https://twitter.com/patmeenan/status/1559943970481913856?ref_src=twsrc%5Etfw">August 17, 2022</a></blockquote>
<script async="async" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>仔細看一下，發現原來大家用 Server Push 都還是為了提升網頁第一屏的速度，但是 Server Push 一直有<a href="https://www.fastly.com/blog/faster-websites-early-priority-hints#but-what-about-http/2-server-push">一些難解的問題</a>，像是不知道 client 端有沒有 cache，實作和支援比較麻煩，而 Chrome 要移除 Server Push 前，其實先實作了 <a href="https://datatracker.ietf.org/doc/html/rfc8297">RFC-8279 的
HTTP 103: Early Hints</a>，為的就要讓 Server Push 現在作的事情先有替代方案。</p>
<p>Early Hint 應該算是 Fastly 提出的，RFC 文件作者是 <a href="https://twitter.com/kazuho/">Kazuho Oku</a>，實際上應該也有其他 Fastly 的人參與構思和試驗，支援 Early Hints 的環境下，一個 HTTP request 看起來就像是下面這樣：</p>
<pre><code>Client request:

  GET / HTTP/1.1
  Host: example.com


Server response:

  HTTP/1.1 103 Early Hints
  Link: &lt;/style.css&gt;; rel=preload; as=style
  Link: &lt;/script.js&gt;; rel=preload; as=script

  HTTP/1.1 200 OK
  Date: Fri, 26 May 2017 10:02:11 GMT
  Content-Length: 1234
  Content-Type: text/html; charset=utf-8
  Link: &lt;/style.css&gt;; rel=preload; as=style
  Link: &lt;/script.js&gt;; rel=preload; as=script

  &lt;!doctype html&gt;
  [... rest of the response body is omitted from the example ...]
</code></pre>
<p>很特別的，就是在於有兩段 response，第一段就是 103 的 status code，然後內容就是 Link headers 了，接著才是常見的 200 回應，看到這邊，自然的出現第一個問題：現有的瀏覽器能相容嗎？</p>
<p>這個問題在 <a href="https://stackoverflow.com/questions/73320707/http-103-responses-what-happens-if-a-server-sends-a-103-early-hints-response-to/73320831#73320831">Stack Overflow 也有人問</a>，結果回答在 RFC 文件內其實就有，只不過是放在第三章的安全性那邊，我一開始也因為先跳過這章而沒發現，總之關於這個問題，就是如果是 HTTP/2 的話，就比較沒問題，HTTP/1.1 的話，理論上應該要可以相容（沒功能但是也不出錯），但是無法保證現在有在用的 HTTP/1.1 client 都有正確的處理 1xx response，所以比較建議是 HTTP/2 才回 103。</p>
<p>過了兩天後，我更仔細的研究一下，發現其實早在 HTTP/1.1 時，就有把 <a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.2-3">1xx 的處理需求定義</a>好了：</p>
<blockquote>
<p>A client MUST be able to parse one or more 1xx responses received prior to a final response, even if the client does not expect one. A user agent MAY ignore unexpected 1xx responses.</p>
</blockquote>
<p>就是說早在 HTTP/1.1 時的設計，就允許 1xx 接 200 的回應，而且還應該要支援多個 1xx 回應，而最後的那個 200（其實是 2xx 到 5xx 都可以），則是稱為 final response，至於這處理的方式，在 WHATWG 的 fetch 的 4.7 章則有清楚的寫下流程，在該章節的第九項裡面的第五子項目，寫成程式碼大概長成：</p>
<pre><code class="language-js">while (true) {
  const response = await networkTransmit();
  const status = response.statusCode;
    
  if (status &gt;= 100 &amp;&amp; status &lt;= 199) {
    // handle 1xx response
    continue;
  } else {
    break;
  }
}

// handle final response
</code></pre>
<p>所以理論上，Early Hints 的設計在正確支援 HTTP/1.1 但是還沒有支援 Early Hints 的瀏覽器就應該要可以正常的略過，而不會把它當成是 final response。</p>
<p>解決完第一個問題後，接著來仔細的看看剛剛範例的 server response：</p>
<pre><code>HTTP/1.1 103 Early Hints
Link: &lt;/style.css&gt;; rel=preload; as=style
Link: &lt;/script.js&gt;; rel=preload; as=script

HTTP/1.1 200 OK
Date: Fri, 26 May 2017 10:02:11 GMT
Content-Length: 1234
Content-Type: text/html; charset=utf-8
Link: &lt;/style.css&gt;; rel=preload; as=style
Link: &lt;/script.js&gt;; rel=preload; as=script

&lt;!doctype html&gt;
[... rest of the response body is omitted from the example ...]
</code></pre>
<p>不知道會不會有人疑惑，為什麼不直接用 200 response 裡面回應的 Link header 就好了？其實我一開始也是這樣想，不過這完全是因為這個問題落入身為前端工程師的我的盲點之中，因為現在前端開發主流是 SPA，通常 HTTP server 回的就是一個靜態的 HTML 檔案，所以回應速度超快。不過，如果回應的 HTML 文件，是由程式語言動態生成的，或許還需要查詢一下資料庫之類的，那這個回應時間就會變慢了，而 HTTP 103 Early Hints 就是在這種狀態下用的，在你的 server 端程式開始處理 request 之前，就先丟 103 的 status code 和 Early Hints 的內容回給瀏覽器，然後才接著處理資料和生成 HTML 文件，這種情境下，Early Hints 就顯得比較有差異了。Nitropack 的<a href="https://nitropack.io/blog/post/early-hints">文章</a>就解釋的很清楚，還有附上詳細的說明圖。</p>
<p>相較於 Server Push，其實 Early Hints 的設計簡單很多，所有的傳輸還是從 client 端看有沒有 cache ，決定要不要發 request，而這種操作已經非常成熟（相較於 server push），相信很多地方可以直接使用現有的程式碼來實作，最大的隱憂，就只是不相容 HTTP/1.0，然後會擔心有 HTTP/1.1 的 client 端沒正確實作吧，畢竟 1xx 的處理機制雖然早早就設計好，但是實際上 1xx 有被廣泛使用也是這幾年的事。</p>
<p>目前 Chrome 是從 103 <a href="https://developer.chrome.com/blog/new-in-chrome-103/">開始支援 Early Hints</a> 的，並且預計在 106 <a href="https://developer.chrome.com/blog/removing-push/">正式移除 Server Push</a>，至於其他瀏覽器則是都還沒有支援， Firefox 是有計畫要支援，<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1407355">進度</a>有點緩慢就是。</p>
<p>最後，Fastly 其實有提供一個測試用的網站：<a href="https://early-hints.fastlylabs.com/">https://early-hints.fastlylabs.com/</a>，不過這個網站不是用來測試你的瀏覽器支不支援 Early Hints 的，而是用來測試先 103 status 後 200 的 response 會不會有非預期的問題（也就是相容性的測試），如果想要直接看看來回的內容，也可以直接用 curl：</p>
<pre><code class="language-sh">curl -v https://early-hints.fastlylabs.com
</code></pre>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2022-08-23T22:27:35+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2022/08/18/shopify-app/">
<title>Shopify App</title>
<link>https://blog.othree.net/log/2022/08/18/shopify-app/</link>
<description><![CDATA[<p>之前開發 Shopify App 時，為了搞定他的安裝搞了蠻久，所以決定來紀錄一下踩到的坑，這篇文章適合已經開始在開發 Shopify App 的人閱讀，有些 Shopify App 的基本知識就不會提到，以下內文幾個名詞先定義清楚一下：</p>
<ul>
<li>App 指的是我們開發的 Shopify 第三方 app</li>
<li>Merchant 指的是在 Shopify 上開店的商家</li>
<li>安裝 app 指的是 merchant 在他們的 Shopify 商店上安裝我們開發的第三方 app</li>
</ul>
<p>首先就是，我踩的很多坑有一部分原因是因為我用 NodeJS 作為 server 端的語言，選的是 Express，但是官方的 Express 架構的 app 範例已經停止維護了，取而代之的，是 Koa 版本的 <a href="https://github.com/Shopify/koa-shopify-auth">@shopify/koa-shopify-auth</a>，只有負責驗證相關的 middleware，不過其實我也就剛好是需要 auth 相關的部分，只是差在不是 Express 版，我也還可以研究看看要怎樣自己實作了。</p>
<p>大概看一下，發現其實還有另外一個 <a href="https://github.com/Shopify/shopify-api-node">@shopify/shopify-api</a> 是底層負責處理跟 Shopify 相關的邏輯，所以理論上我也可以使用它來搭配 Express，不過這裡首先就有一個坑了，初始化的範例是長這樣：</p>
<pre><code class="language-js">Shopify.Context.initialize({
  API_KEY: process.env.SHOPIFY_API_KEY,
  API_SECRET_KEY: process.env.SHOPIFY_API_SECRET,
  SCOPES: process.env.SHOPIFY_APP_SCOPES,
  HOST_NAME: process.env.SHOPIFY_APP_URL.replace(/^https:\/\//, ''),
  API_VERSION: ApiVersion.October20,
  IS_EMBEDDED_APP: true,
  // More information at https://github.com/Shopify/shopify-node-api/blob/main/docs/issues.md#notes-on-session-handling
  SESSION_STORAGE: new Shopify.Session.MemorySessionStorage(),
});
</code></pre>
<p>可以看到，最後有一個 <code>SESSION_STORAGE</code>，這是個處理 merchant 在安裝 app 時，我們的 app 拿到的 access token 的儲存方式的 adapter，不過官方的範例是用 Memory Storage，這個 adpater 是只有存在記憶體內，其實只適用於開發用，只要你的 server 一重開，所有的 merchant 就都要重新安裝你的 app，不然你的 app 會沒有 access token 跟 Shopify 溝通，實際上你應該要參考 <a href="https://github.com/Shopify/shopify-api-node/blob/main/docs/usage/customsessions.md">Custom Session Storage</a> 這份文件，挑選適用的 adapter，我則是參考範例寫了一個 GCP FireStore 的版本，當然另外沒特別提到的就是，因為是儲存 access token，最好要考慮一下 DB 的加密。</p>
<p>第二個坑，就是要怎樣做 Shopify 的 authentication 以及 identification，先來說如何驗證 request 是可信的，在 Shopify API 的設計，就是要靠 query string parameter 裡面的 hmac，他是根據你的 App 的 secret 來計算出來的，然後，這裡的坑就是官方套件 <code>@shopify/shopify-api</code> 內有個 <code>validateHmac</code> 可以用，但是它的計算其實是不正確的，它是用白名單只有取部分的 query string parameter 來計算，結果和 Shopify 給的就會有出入，所以我是參考 GitHub issue 討論串內 Muhammad Kamal 給的<a href="https://github.com/Shopify/shopify-node-api/issues/275#issuecomment-1059968699">範例</a>來使用。</p>
<p>第三個坑，則是安裝 App 用的 route 了，Shopify 的設計有點特別，所有的初始 request （不論是第一次安裝、還是從 Shopify 後台進入 App 的設定畫面），都長的很接近，所以你就要根據各種狀況來決定該做什麼事情，以下是所有可能的狀況：</p>
<ul>
<li>第一次來安裝</li>
<li>安裝後進到設定畫面</li>
<li>曾經安裝過，但是需要重新授權，可能的原因：
<ul>
<li>App 需要的權限有變動</li>
<li>App 端的 access token 失效了</li>
</ul>
</li>
<li>Shopify 認為已經安裝了，但是 app 端沒資料</li>
</ul>
<p>扣除需要的權限有變動之外，其實就是排列組合，Shopify 端認為有沒有安裝過，和 App 端認為有沒有安裝過，二乘二共四種可能性，不過實際上只有三種處理方式：初次安裝、重新授權、安裝沒問題的快樂路線（happy path）整理成程式流程大概是：</p>
<ol>
<li>驗證 hmac，沒過可以直接回 400</li>
<li>判斷 shop 是否有在資料庫中</li>
<li>2 有的話驗證資料庫中的 access token</li>
<li>3 驗證通過的話，狀態就是 happy path，Shopify 認為 app 有裝，app 端檢查也沒問題，我把這狀態命名為 <code>valid</code></li>
<li>3 驗證沒通過的話，判斷有沒有 <code>session</code> 這個 query string 參數</li>
<li>5 有的話，狀態就是 app 端的 access token 不能用了，需要走重新授權的流程，我把這狀態命名為 <code>invalid</code></li>
<li>5 沒有的話，就是第一次安裝的流程，我把這狀態命名為 <code>not_found</code></li>
<li>最後就是 2 沒有的話也是走初次安裝的授權流程，同樣也可以叫 <code>not_found</code></li>
</ol>
<p>然後 app 需要的權限變動的話，理論上是每次進來，驗證 access token 的時候，可以去打 API 問目前 <a href="https://shopify.dev/api/usage/access-scopes#checking-granted-access-scopes">token 的 access scope</a>，不過這部份我沒實做，因為目前我還沒有相關需求。</p>
<p>網路上可能可以找到 <code>X-Shopify-API-Request-Failure-Reauthorize</code> 這個 header，不過這個其實不是 Shopify API 的回應，而是 Shopify 的 <a href="https://github.com/Shopify/shopify-app-template-node/blob/main/server/middleware/verify-request.js">app-template</a> 裡面設計的機制，它們的 app template 裡面，server 端在轉發 Ajax API request 時，如果收到 Shopify 端的錯誤後，就加上這個 header 回給 app 前端，app 前端收到這個 header 後就可以透過 Shopify app-bridge 進入重新授權的流程。</p>
<p>講到這邊，或許有人會好奇，為什麼需要把安裝 app 和重新授權兩個流程的處理方式分開？其實這可以算是第四個坑，也是和使用者體驗有關係，狀況就是，Shopify 認為是初次安裝時，是直接進入 OAuth 的流程，所以是瀏覽器的最上層視窗直接轉址到 auth 頁面，但是如果是需要重新授權的情形，則是 Shopify 端認為已經安裝好，但是 app 這邊認為需要重新跑一次 OAuth，而這時候，連到 app server 的瀏覽器視窗是在 Shopify 商店後台的 iframe 內，在 iframe 內也無法正確的完成 OAuth 授權，所以需要用 Shopify 現在一套叫 app-bridge 的工具幫忙，讓 OAuth 流程從最上層視窗開始，所以需要回一個 HTML 頁面，<a href="https://shopify.dev/apps/tools/app-bridge/getting-started/app-setup#set-up-shopify-app-bridge-in-your-app">引入 app-bridge 的 script</a>，然後執行以下的的 JS：</p>
<pre><code class="language-js">const AppBridge = window['app-bridge'];
const createApp = AppBridge.default;
const Redirect = AppBridge.actions.Redirect;
const app = createApp({
	apiKey: '{{API_KEY}}',
	host: '{{HOST}}',
});
const redirect = Redirect.create(app);

redirect.dispatch(
	Redirect.Action.REMOTE,
	'/url/to/your/auth?shop={{SHOP}}'
);

</code></pre>
<p>當然記得要把該替換的東西替換上去，然後就可以看到正確的從最上層視窗開始進入 OAuth 授權的流程了。</p>
<p>最後一個坑，其實就是 merchant 反安裝 app 後，Shopify 和 app 端的狀態就會不一致的問題，Shopify 端認為沒安裝，但是 app 端認為有安裝，雖然我上面設計的程式流程已經可以處理這種狀況（驗證 access token 會失敗，然後沒有 <code>session</code> 參數，所以會進入初次安裝），但是這種情形還是應該要能避免就避免，而解法就是要支援 webhook，要作的事情就是：</p>
<ol>
<li>安裝完成的 callback 去訂閱 <code>APP_UNINSTALLED</code> 這個 webhook event</li>
<li>然後在收到這個事件後，把資料庫中的對應資料刪除</li>
</ol>
<p>這邊我是用 <code>@shopify/shopify-api</code> 提供的工具像是
<code>Shopify.Webhooks.Registry.register</code> 和 <code>Shopify.Utils.deleteOfflineSession</code>，真的想要自己作也不是辦不到，不過我記得 Shopify 的 webhook 處理起來有點麻煩。</p>
<p>這些細節就是官方文件沒有好好寫清楚，雖然官方文件內容已經很多，有努力整理了，但是實際上要自己接就還是遇到了不少問題，所以特別寫一篇文章紀錄，雖然不知道會不會有其他中文圈的人需要自己來做 Shopify app 就是了，可以直接用他們的 app template 還是比較簡單啦。</p>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2022-08-18T20:48:14+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2022/07/31/coscup-2022/">
<title>COSCUP 2022</title>
<link>https://blog.othree.net/log/2022/07/31/coscup-2022/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/52253486310/" title=" by othree, on Flickr"><img src="https://live.staticflickr.com/65535/52253486310_6b0fb625bc_b.jpg" width="1024" height="768" alt="" srcset="https://live.staticflickr.com/65535/52253486310_52f4492e44_k.jpg 2x" /></a></p>
<p>(照片是今年的新玩意，紀錄組的形象照)</p>
<p>今年 COSCUP 恢復實體活動，而我和我的稿件間的緣份也終於來了（有來聽的就知道我等緣份到等了兩年有），所以今年是小孩出生後難得有稿可以投，也幸運的投上了，於是就參加了第一天的活動，今年活動的人潮我目測和往年差不多，後來晚上官方也很快速的公布了明調的數字，也有一千三四百筆數據。</p>
<p>我的分享時間是下午的兩點，我大概早上十點半才到會場，先去摩斯買杯紅茶，然後在門口報到區遇到昨天晚上在前夜 party 淋雨全濕的菜骨，接著我先去攤位區亂晃，在 MozTW 的攤位跟 Irvin 閒聊一下，還有遇到 Ett 和 RJ，之後又在形象照（今年紀錄組的新玩意）區遇到丞相還有幾位紀錄組的新朋友（Ada 和另外一位沒記起名字），拍了些 COSCUP 形象照，還遇到 Bob 和哈維、日落，這邊要先岔題澄清一下，就是我常被誤認我有當過 COSCUP 紀錄組長，不過其實沒有，某一年 Bob 有詢問過我意願，那一年我想要拼研究所畢業所以思考過後還是放棄，結果同一年我後來還是接了其他場活動的紀錄組長，因為我後來還是放棄該年度畢業了...</p>
<p>之後去買了一批 COSCUP 紀念品，然後攤位區拿了一點小點心要回家給小孩，接著亂晃一下發現時間已經接近十二點了，而且肚子有點餓就趕快去覓食，不意外的摩斯爆炸，所以轉戰到一餐點了個可以快速吃完的東西，快速的解決後回到會場，然後和一位台大社團的學弟閒聊一陣子，中間還有遇到大助、Trista、Singing 等人，差不多到一點的時候我決定先去教室內休息等待，途中剛好經過 OCF 攤位有跟 Rock、Max 打招呼，然後也看了一下開源星手村桌遊，OCF 攤位還有位朋友（應該是 OCF 實習生）說之前有到我的動森島上參觀過，之後我就到教室坐著休息一下，接著就是 Max 的分享場次了，他分享的題目是<a href="https://coscup.org/2022/zh-TW/session/99GBZC">開源軟體與社群 - 參與國際社群經驗談</a>，是我的前一個場次。</p>
<p>其實即使到現在，我還是有點難恢復純會眾的角色，到了會場就是會想到處走來走去，有點難靜下心來聽別人分享，連排想聽的主題都有點難，實在是當太多次志工的後遺症，今年聽 <a href="https://sakanamax.github.io/">Max</a> 的分享是我近年難得有真的能夠靜下心來認真作聽眾的經驗，必須說這真的是緣份，要不是剛好排在我的前一個場次，我也不會能夠靜下來聽，而且不聽還好，一聽下去發現內容有很多地方和我的講題部分想說的地方有呼應到，甚至是我想表達但是我沒有很明確寫出來的。</p>
<p>總之接著就換我分享了，今年有認真練習了幾次，有發現時間有點緊，所以實際分享時有一些細節漏了，這邊剛好列一下：</p>
<ul>
<li>如何開始貢獻那邊，原本有想提到 <a href="https://opensource.guide/zh-hant/">opensource.guide</a>，第二天小飛機的分享：<a href="https://coscup.org/2022/zh-TW/session/GKDWQF">如何跟隨開源技術保持你的職涯發展</a>似乎也有提到，期待之後的錄影</li>
<li><a href="https://github.com/mlinksva">Mike Linksvayer</a> 和 <a href="https://github.com/benbalter">Ben Balter</a> 的介紹，兩位都是 GitHub 員工，不過看職位似乎也不是專門處理 open source license 相關的，倒是會後 Bob 在 FB 有提到他也認識(?) Mike</li>
<li>如何跟 Mike Linksvayer 和 Ben Balter 溝通關於使用 Vim License 的那超過一千個的 public repositories</li>
<li>開 issue 跟 PR 時應該怎樣說明</li>
<li>更進一步介紹怎樣比對 Licensee 的比對原理</li>
<li>選擇你最舒服的方式參與，這句是從 Max 的投影片借來的，我自己的分享是說了兩三次佛系貢獻、等待緣份，其實和 Max 說的「選擇你最舒服的方式參與」是很接近的，我想表達的比較是不給自己和對方壓力</li>
<li>本來還想畫張 timeline 的，還有投稿之後準備內容時於到的外部誘惑等等（那個什麼法環的）</li>
<li>然後就有點離題的商業和開源難分難解的關係</li>
</ul>
<p>其實我在分享講話的時候，大腦沒什麼在思考的感覺，很像是直覺反射那樣，所以不太能臨時性的控制和調整，這些缺漏就只能等等看之後寫成文字紀錄的時候能不能補上了，附上分享的<a href="https://speakerdeck.com/othree/how-github-supports-vim-license-detection-the-five-years-journey">投影片</a>：</p>
<iframe class="speakerdeck-iframe" style="border: 0px none; background: rgba(0, 0, 0, 0.1) none repeat scroll 0% 0% padding-box; margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 560px; height: 314px;" src="https://speakerdeck.com/player/0256360bb6ec4a79b562fcdcb63d49f3" title="How GitHub Supports Vim License Detection, The Five Years Journey" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true" data-dashlane-frameid="1533303324720" data-ratio="1.78343949044586" frameborder="0"></iframe>
<p>除了缺漏之外，其實這次分享還有點可惜是投影解析度不太夠，因為我其中一張投影片的動畫的關係（SPDX 那邊的討論串），我選擇用自己的電腦，不過為了配合大會的錄影，現場的投影解析度就有點低，對現場的聽眾是不太好意思，希望錄影的部分能夠正常可以觀看，其實事後回想，或許我還可以選擇輸出的解析度測試看看，只是不知道那個擷取裝置有沒有支援，當時有點慌忙都忽略了。</p>
<p>分享結束之後我去買了杯氮氣咖啡就快速收工回家了，後來在柏強的 FB 提到了「看到問題的能力」，我就想到我確實之前就有意識到這一點，不過我意識到的是，相較於平常沒主動分享（寫文章或是演講）的人，我確實很容易知道，哪些我的經驗（工作上的、生活上的、興趣上的）可以匯集成一個主題，可能可以寫成文章，也可能可以投稿分享，不過這個<strong>能力</strong>本身似乎不是這麼容易能分享給新手的。</p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2022-07-31T22:24:42+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2021/09/10/does-cat-understand-what-we-say/">
<title>貓聽得懂人話嗎</title>
<link>https://blog.othree.net/log/2021/09/10/does-cat-understand-what-we-say/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/8997762712/in/photolist-236z5zf-22ms8cB-23HUtwV-X3kfUu-TF7f8Y-RoEKe7-RyyKvA-QoqGRP-RyB6t7-QkDFnQ-RyB5XN-QkDGgd-RoGwzq-RyB7NG-Bcfmhj-BB5dJA-BB5e4U-A1AFfr-qAfKsg-eH6TnS-2mnSMWp-eGZPpp-eH6TN1-eGZNXH" title="菲貓 by othree, on Flickr"><img src="https://live.staticflickr.com/3690/8997762712_4915c923b5_b.jpg" width="1024" height="683" alt="菲貓" srcset="https://live.staticflickr.com/3690/8997762712_e24a8ff6e5_k.jpg 2x" /></a></p>
<p>不知道別人家的貓是怎樣，不過我是蠻相信我家的貓是聽得懂的，我們家的貓咪年紀大了，開始有腎臟問題，行動力也差很多，有一陣子看他身體不舒服，然後還要移動去尿尿埋沙好像很辛苦，於是有一次我就跟他說不要埋了我幫他處理，結果，從此之後他就再也不埋尿尿便便了，即使後來身體比較好也一樣...</p>
<p>我們家貓咪的名字叫菲菲，其實他是一隻蠻特別的貓咪，一來他是很少見的母的橘貓，根據我隨便搜尋了一下，好像要有兩組 DNA 的基因都要是橘色基因，然後機率都是三分之一的樣子；二來他的叫聲很特別，別的貓咪是喵喵叫，他都是凹凹叫，而且很多話；另外就是耳朵的尖端還有些毛也很少在橘貓上見到。這幾個特點之外，其他的地方就和一般常見的橘貓很像了，愛吃、親人、喜歡摸摸，根據我的觀察，家裡的成員當中，他最喜歡我摸他了，常常摸頭頭下巴摸一摸他就乾脆整顆頭都不出力支撐，直接倒在我手上了，啊，他還有一個特色是很會騙人，就我所知有好幾個藍星人跟他接觸之後覺得貓咪很可愛也開始養貓了。</p>
<p>回到聽得懂人話嗎這個問題上，另外一個例子是他前幾兩週身體狀況惡化很多，後腳無力，幾乎走不太動了，尿尿便便常常會來不及跑去貓沙盆，雖然有鋪尿布但是他不一定躺在上面，我就跟他說有事情要叫我們，要便便尿尿都跟我們說，結果就真的開始偶爾會突然開始叫幾聲，然後我們問他什麼事情，他就開始尿尿了（不過還是蠻堅持想要到貓沙上面）。</p>
<p>其實菲菲這次身體狀況惡化，醫生是已經無法處理了，我們就是在家裡讓他盡量過的舒適，晚上事情忙完就會去客廳陪他摸摸他，順便玩對馬戰鬼導演版，所幸他還算可以安靜躺著，因為不知道他到底這樣會不會需要其他協助，還跑去問醫生，不過根據醫生說法，痛苦的話貓咪還是會有反應，像是焦慮、一直換姿勢或是嘔吐等等，總之就是會更慘烈就是，還好菲菲這樣還蠻平靜。菲菲最後是在上週六晚上離開的，他挑了一個剛好沒人在旁邊的時間離開，就是我晚上去倒垃圾的時候，我離開家裡之前還跟他說我要去倒垃圾了，一下子就會回來陪他了，等到我回來時他狀況已經驟變了，呼吸變成很慢，大概好幾秒鐘才一次，然後很吃力了，眼睛也都完全沒反應了，之後只有再呼吸幾次就停了，告別就這樣突然的來到，本來最近看房子還在想不知道到新房子的話要讓他佔據那邊呢，悲傷之餘跟老婆先查過的廠商聯絡，心裡其實也有點逃避現實的想著會不會菲菲其實還活著呢，但是也不敢再多看他幾眼，維持在一個自以為的薛丁格的貓的狀態。</p>
<p>隔天週日天氣很好，週六其實下了很大的雨，所以週日天空特別的蔚藍，空氣很乾淨能見度很高，比這兩天颱風前的天空還要漂亮，在開車往火化園區的路上，看著這一大片蔚藍的天空，想到岳母前幾天有說貓咪在挑日子，就覺得他真的是很會挑日子和時間，挑到天氣這麼這麼好的一天，不過一路上還是會逃避現實的想著他會不會其實還活著，要是還活著就把他送進去火化太可怕了吧，不過這種不切實際的幻想終於還是在禮儀師幫菲菲清潔身體時被打破了，看著完全沒反應不會動的貓咪身體，我心理想著：「啊，真的死了」，等火化出來時，看著骨頭想著：「啊，就這樣變成這樣了」。</p>
<p>跟小孩說貓咪去當小天使了，他雖然不常摸菲菲，但是還是會說不想要看不到貓咪，會想他，看到放在桌上的貓咪罐頭還會怕他去當小天使肚子餓怎麼辦（只好趕快裝到箱子），雖然他沒有反應很大不過似乎這陣子也是有比較敏感。至於我，一開始面對空曠的客廳時感到很不習慣，甚至想逃避那個空間，過了快一週是已經沒那麼害怕客廳了，不過大概是很難繼續玩對馬戰鬼了吧，本來甚至很怕會無法看其他貓咪影片照片的，結果似乎也還好，不過以前要出門時，我都會跟佔據在客廳的菲菲報備一下，這個習慣的慣性即使到現在都還在，或許遲早我還是會習慣菲菲不在了，出門再也不會有要跟他報備的衝動吧，也或許更讓人難受的是知道自己遲早會漸漸忘懷他吧。</p>
<p>PS. 本來想放小孩跟貓咪的合照，不過實在沒很多張，最後挑的是我幫他拍的第一張照片。</p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2021-09-10T21:37:58+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2021/08/12/csp-for-lambdaedge/">
<title>CSP for Lambda@Edge</title>
<link>https://blog.othree.net/log/2021/08/12/csp-for-lambdaedge/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/51371732481/" title="CSP by othree, on Flickr"><img src="https://live.staticflickr.com/65535/51371732481_5335b8d3f0_b.jpg" width="710" height="305" alt="CSP" srcset="" /></a></p>
<p>之前工作上主要是用 AWS，AWS 放靜態網站有過 CloudFront CDN 時，如果需要調整 header 的話，官方的解決方案是用 Lambda@Edge，寫 AWS Lambda function 的時候，其實我個人有一個偏好，就是能不用第三方 module 就不用，主要原因有兩個，第一個原因是，如果程式碼太大包，會無法在 AWS console 上直接看（或修改）程式碼；第二個原因是發佈流程會比較麻煩，因為還要去安裝 module，然後再全部打包起來上傳。</p>
<p>要調整 header 的一個主要原因就是為了 security headers，大部分的 security header 都還算單純，但是 CSP（Content Security Policy）就複雜很多了，如果沒有用結構化的資料，其實很難維護，但是針對 Lambda function 我又不想要用第三方 module，最後我想到的解決方案，就是設計一個很簡短的工具函式來把結構化的資料轉成 CSP header 的值，這就是我最近趁 COSCUP 2021 會議期間整理好的新的 open source 專案：<a href="https://github.com/othree/csp">CSP</a>。</p>
<p>這個專案內容就只是一個簡單的 function：</p>
<pre><code class="language-javascript">const CSP = (directives) =&gt; {
  return directives
    .map((directive) =&gt; {
    	return `${directive.name} ${directive.value.join(' ')};`;
    })
    .join(' ');
};
</code></pre>
<p>不過為了好好設計這個 function 其實我也是花不少功夫，首先就是輸入參數的結構要長怎樣，其實一般比較常見的是用物件 property 直接就作為 directive name 的形式，像是 Google 的 <a href="https://github.com/google/csp-evaluator">CSP Evaluator</a>：</p>
<pre><code class="language-json">{
  &quot;default-src&quot;: [&quot;'none'&quot;],
  &quot;script-src&quot;: [&quot;'self'&quot;],
  &quot;connect-src&quot;: [&quot;blah&quot;, &quot;blah&quot;]
}
</code></pre>
<p>這種結構比較精簡，但是問題就是無法保證順序，考慮再三之後，決定還是用陣列的形式：</p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;default-src&quot;,
    &quot;value&quot;: [&quot;'none'&quot;]
  },
  {
    &quot;name&quot;: &quot;script-src&quot;&quot;,
    &quot;value&quot;: [&quot;'self'&quot;]
  }
]
</code></pre>
<p>這樣就可以讓開發人員確保輸出的順序，其實大部分時候我也不會那麼在意順序，不過要是 <code>default-src</code> 如果不是第一個感覺就很不舒服。確定主要的資料結構後，再來就是屬性名稱要用什麼好的問題了，為了找到正確的名稱，我去翻了 <a href="https://w3c.github.io/webappsec-csp/#framework-policy">CSP spec</a> 找到關於 parsing 相關的說明，確定了 spec 定義的結構是這樣的（使用 TypeScript 語法）：</p>
<pre><code class="language-typescript">type Source = string;

type Directive = {
  name: string;
  value: Source[];
};

type Policy = {
  source: &quot;header&quot; | &quot;meta&quot;;
  disposition: &quot;enforce&quot; | &quot;report&quot;;
  directiveSet: OrderedSet&lt;Directive&gt;;
};

type Policies = Policy[];
</code></pre>
<p>在輸入資料的陣列中，每個元素都是 <code>Directive</code>，<code>Directive</code> 的兩個屬性分別是 <code>name</code> 和 <code>value</code>，<code>value</code>  則是 <code>Source</code> 的陣列集合，當然 <code>Source</code> 還有更嚴謹的定義，不過這邊就簡化成字串就好。確定完輸入資料的結構後，就是要想盡辦法簡化 function 的內容了，但是也不希望太難讀懂，調整了幾次變成現在的樣子，我還提供了精簡的版本：</p>
<pre><code class="language-javascript">const CSP = p =&gt; p.map(d =&gt; `${d.name} ${d.value.join(' ')};`).join(' ');
</code></pre>
<p>其實我對於那個 <code>map</code> 接 <code>join</code> 一直耿耿於懷，很想要用 <code>reduce</code> 解決，但是要避免頭尾多空白，會需要多判斷式，就算不予理會，程式碼長度其實還是比現在這個版本長，結果還是 <code>map</code> 接 <code>join</code> 看起來比較漂亮，所以最後的版本就維持這樣了。</p>
<p>然後我還寫了測試和提供了兩個 <a href="https://github.com/othree/csp/tree/master/examples">example</a>，分別是 Lambda@Edge 和 Cloudflare Workers 的，不確定還有沒有類似的服務，如果有發現會再加上。最後就是，因為這個 function 設計就是要給人複製貼上的，所以並沒有發布到 npm 上，然後使用 MIT-0 license 所以也不用 attribution，覺得有興趣使用的就請直接複製貼上吧～</p>
<p>PS. 如果有其他需求，可以看看 <a href="https://www.npmjs.com/package/csp-header">csp-header</a>，例如 Express 使用，我覺得介面設計得很不錯。</p>
]]></description>
<dc:subject>script</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2021-08-12T11:59:16+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2021/08/02/static-site-hosting/">
<title>Static Site Hosting 服務需求</title>
<link>https://blog.othree.net/log/2021/08/02/static-site-hosting/</link>
<description><![CDATA[<p>前陣子研究了一下用 GCP 來放靜態網站，那時候有整理了一下需求，這篇文章把需求的緣由也整理出來，先說在前面，這些需求並不是要求單一家服務就可以達成所有目標，內文也盡量不提到特定服務，所以不同服務要怎樣達到這些需求就有賴各位自行研究了。</p>
<h4>支援 CDN</h4>
<p>這個需求沒什麼好說了吧。</p>
<h4>支援 HTTP/2</h4>
<p>主要的服務應該都支援了，不過還是列一下。</p>
<h4>支援加上 Security Headers</h4>
<p>現在大家對於安全性的要求很高，所以可以加上 security headers 對我來說已經是一個必備的功能了，像是 CSP、HSTS 等，這項需求看廣一點，其實就是要自定義回傳 header 的功能，如果可以根據路徑調整就更好了，基本上應該只有 HTML 文件本身需要這些 header。</p>
<h4>支援 HTTP 轉成 HTTPS</h4>
<p>在各家瀏覽器的推波助瀾之下，不支援 HTTPS 的網站感覺就是次一等了，所以把 HTTP protocol 的 traffic 全部轉到 HTTPS 這件事情我也列為必備，有兩種支援的方式，一種是服務內建支援 protocol 轉址，這種最好，因為它會保留請求的路徑（path），而不是把訪客導到首頁，另外一種就是用下面要提到的全站轉址的方式來達成。</p>
<p>雖然我自己是都會把 HTTP 轉到 HTTPS，不過看網站目標，也還是有可能需要繼續支援 HTTP 的。</p>
<h4>支援全站轉址</h4>
<p>主要的需求是把 <code>www.example.com</code> 轉址到 <code>example.com</code> ，或是反過來，像 <code>www.apple.com</code> 那樣，當然最好還能保留請求的路徑，這個看似很基本的設定，其實現在還蠻常會發現有網站沒做到這件事，尤其是台灣的，我真的是黑人問號？＿？</p>
<p>除了 host name 的轉換之外，還有一種情形是需要把整個網站的 request 都轉到某個 URL，例如 <code>docs.example.com</code> 要關站，然後要把流量都轉到 <code>https://example.com/docs</code> 。</p>
<p>以下算是非必備的需求</p>
<h4>支援把 404 改寫成 200</h4>
<p>非 SSR 的 SPA 然後配上 route 的話，會有個問題就是除了首頁的 route 都會 404，雖然一般可以用 error_document/not_found_page 之類的設定來讓內容可以正確呈現，但是 404 的 status code 還是會有不少問題，一來是影響搜尋引擎的結果，二來是不知道是不是所有瀏覽器都還會正確的處理 404 時的網頁內容，所以最好還是能回正確的 status code，可以辦到這件事的方法就我所知道的也是有兩種，一種是 rewrite 機制，另外一種就是可以寫程式處理 request/respone 的，像是 Lambda@Edge 那樣。不過在處理這個功能時要是直接全部的路徑回應都變 200 其實也不太好，要完美有點麻煩啊。</p>
<h4>支援 CORS</h4>
<p>如果會有需要靜態的 JSON 檔案，然後跨網域直接抓下來當資料使用，那就會需要支援 CORS header，和上面自定義回傳 header 那一項不太一樣的是，CORS header 其實是有互動而不是寫死的，應該是要根據 request 的 header 內容來改變回傳的 CORS header，如果需要 preflight request 那還要支援 OPTIONS method 和相對應的回應，不過如果單純只是靜態 JSON 檔案，靠自訂回傳 header 的功能直接寫死應該也是夠用了。</p>
<h4>支援 Basic Auth</h4>
<p>如果有尚未公開的網站，還是希望至少有個基本的保護，Basic Auth 只是其中一種方法。</p>
<h4>支援根據 Header 切換 origin</h4>
<p>這個需求的來源就是用手機的訪客可以看到手機版網頁，用桌上型電腦的訪客看到桌面版網頁，然後網址想要維持一致而且兩種版本的網站想要分開開發，不一定會有這個需求。然後不得不說，AWS 的 <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-cloudfront-headers.html#cloudfront-headers-device-type"><code>CloudFront-Is-*-Viewer</code> header</a> 真是蠻方便的，不過他們沒洩漏過判斷方式，Cloudflare 則是只有<a href="https://support.cloudflare.com/hc/en-us/articles/229373388-Understand-Cache-by-Device-Type-Enterprise-plans-only-">企業方案有支援</a>，但是有提供他們如何判斷 device type。</p>
<h4>支援根據路徑切換 origin</h4>
<p>如果有特定路徑下的網頁是另外開發的，有支援這個功能的話就會比較好處理，一個比較常見的情境是開發文件的 API spec 是用其他工具或服務產生的，例如用 OpenAPI 文件產生的那種就很常見，或是有些語言也都有常用的文件產生工具，例如 Python 的 Sphinx。</p>
<h4>支援 brotli</h4>
<p>Google 開發的壓縮格式，對文字資料的壓縮表現比以前主流的 gzip 還好，主要的服務應該都支援了，不過還是列一下。</p>
]]></description>
<dc:subject>server</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2021-08-02T22:23:14+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2021/07/19/macos-my-pref/">
<title>MacOS 我的設定</title>
<link>https://blog.othree.net/log/2021/07/19/macos-my-pref/</link>
<description><![CDATA[<p>最近因應新工作買了台新的 M1 Mac mini，所以重新把常用設定弄了一下，這篇文章來紀錄一下。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/51318768736/" title="Mac OS Preference by othree by othree, on Flickr"><img src="https://live.staticflickr.com/65535/51318768736_786d7e9446_b.jpg" width="668" height="696" alt="Mac OS Preference by othree" srcset="" /></a></p>
<p>首先是 <strong>一般</strong> 裡面的顯示捲軸（scrollbar），預設的設定是 <strong>自動依據滑鼠或觸控軌跡板</strong> ，這個選項的意思是，如果你用的是蘋果的滑鼠或觸控板，那他就會用自動隱藏的那種捲軸，如果有其他品牌的外接游標控制設備，那捲軸就是傳統的，有得捲動時就是會一直出現在那，佔據一塊空間，其實我對於這個預設行為有疑惑很久了，為什麼其他品牌的滑鼠就一定要用傳統的捲軸模式？直到某一天在系統篇好設定亂逛的時候才發現原來就是這個選項。</p>
]]></description>
<dc:subject>mac</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2021-07-19T00:37:19+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2021/05/20/berserk/">
<title>三浦建太郎逝世</title>
<link>https://blog.othree.net/log/2021/05/20/berserk/</link>
<description><![CDATA[<p>本部落格的 ACG 類別真的都用來發這種文了，5 月 20 日的時候，白泉社官方發布訃文，三浦建太郎老師在 5 月 6 日因為主動脈剝離逝世了，享年 54 歲。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">【三浦建太郎先生　ご逝去の報】<br />『ベルセルク』の作者である三浦建太郎先生が、2021年5月6日、急性大動脈解離のため、ご逝去されました。三浦先生の画業に最大の敬意と感謝を表しますとともに、心よりご冥福をお祈りいたします。<br />2021年5月20日　株式会社白泉社　ヤングアニマル編集部 <a href="https://t.co/vy923fIqiP">pic.twitter.com/vy923fIqiP</a></p>-- ヤングアニマル公式 (@YoungAnimalHaku) <a href="https://twitter.com/YoungAnimalHaku/status/1395213014182162436?ref_src=twsrc%5Etfw">May 20, 2021</a></blockquote> <script async="async" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<p>白泉社官網還有<a href="https://www.hakusensha.co.jp/information/60696/">多國語言版本</a>的訃文。</p>
<p>最令人惋惜的就是他的代表作品<a href="https://zh.wikipedia.org/wiki/%E7%83%99%E5%8D%B0%E5%8B%87%E5%A3%AB">烙印勇士</a>（ベルセルク）還未完成了吧，從我還在國高中時就開始看了，不過後來連載速度慢了很多，當時我想說他是不是被夕映治癒了，靈魂內黑黑的東西被洗滌一空，後來才知道他健康出問題了，其實也是不意外，烙印勇士雖然是月刊連載，但是很多畫面其實都是畫的非常精細，很難想像早期要維持那樣的作畫精細度和連載速度要投入多少精力，這幾年速度就慢很多了，差不多都是一兩年才出一本單行本。目前白泉社還沒有說烙印勇士之後要怎樣，不過有特別提到之後確定後會在跟大家說，我自己是認為三浦應該是對於整個故事的發展早就都規劃好了，不過有留下多少資料又是另外一回事，還有就是如果要找人接手，那個作畫也是一個大問題吧。</p>
<p>最後放上兩張圖，是烙印勇士當中我印象最深刻的地方。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/51242950039/" title="ベルセルク by othree, on Flickr"><img src="https://live.staticflickr.com/65535/51242950039_d261b0b123_b.jpg" width="600" height="800" alt="ベルセルク" srcset="https://live.staticflickr.com/65535/51242950039_d261b0b123_b.jpg 768w, https://live.staticflickr.com/65535/51242950039_99358ade99_h.jpg 1200w" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/51241472177/" title="ベルセルク by othree, on Flickr"><img src="https://live.staticflickr.com/65535/51241472177_402bb4e123_b.jpg" width="600" height="800" alt="ベルセルク" srcset="https://live.staticflickr.com/65535/51241472177_402bb4e123_b.jpg 768w, https://live.staticflickr.com/65535/51241472177_41da5f9fe8_h.jpg 1200w" /></a></p>
<p>PS. 東立有出數位版，而且說現在是<a href="https://www.facebook.com/TongLiComic/photos/a.247930171901325/2945108425516806/">沒有任何修剪的版本</a>了，至於實體書去年有再版過，現在應該是缺貨中。</p>
]]></description>
<dc:subject>acg</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2021-05-20T00:10:08+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/11/29/intrinsic-aspect-ratio-of-incomplete-image/">
<title>HTML 文件圖片預設寬高比</title>
<link>https://blog.othree.net/log/2020/11/29/intrinsic-aspect-ratio-of-incomplete-image/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/50660948372/" title="Intrinsic aspect ratio of incomplete image by othree, on Flickr"><img src="https://live.staticflickr.com/65535/50660948372_745a2dd865_b.jpg" width="1024" height="718" alt="Intrinsic aspect ratio of incomplete image" srcset="https://live.staticflickr.com/65535/50660948372_745a2dd865_b.jpg 1024w, https://live.staticflickr.com/65535/50660948372_7b5b33b5cd_h.jpg 1600w" /></a></p>
<p>我在 2018 年有篇文章 <a href="https://blog.othree.net/log/2018/09/21/intrinsic-size/">Intrinsic Size 媒體寬高比</a>，介紹一個標準的草案 <code>intrinsicsize</code> ，為什麼會需要這東西在那篇文章也有講，主要就是要搭配像是：</p>
<pre><code class="language-css">img {
  max-width: 100%;
  height: auto;
}
</code></pre>
<p>這種寫法非常通用，但是在圖片讀取完成前，<code>&lt;img /&gt;</code> 標籤的佔位會無法先知道，這會造成頁面在圖片讀取完成後瀏覽器會需要比較大的重新繪製的工作。</p>
<p>這幾天想起來去查了一下近況，發現竟然早早就停止發展了，caniuse <a href="https://caniuse.com/mdn-html_elements_img_intrinsicsize">那邊</a> 也顯示瀏覽器都把一些實驗中的支援都拿掉了，<a href="https://github.com/WICG/intrinsicsize-attribute/issues/16">細看下去</a>，發現 Firefox 的人當時說要開始試驗另一個比較優雅的方法，也有和 CSS WG 的人開始討論，他們當時的想法就是直接用 <code>width</code> 和 <code>height</code> 屬性來計算寬高比（aspect ratio），不過之後就都沒有標準文件相關的發展細節或連結了。</p>
<p>搜尋一番後，發現 Firefox 在 71 開始就已經發佈這個修改了，當時的 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/71#CSS">release note</a> 其實有寫，而且 MDN 上還有一篇文章：<a href="https://developer.mozilla.org/en-US/docs/Web/Media/images/aspect_ratio_mapping">Mapping the width and height attributes of media container elements to their aspect-ratio</a>，也有介紹這個修改要解決的問題以及技術上是怎樣處理的，簡單一點形容就是：</p>
<pre><code class="language-css">img { 
  aspect-ratio: attr(width) / attr(height); 
}
</code></pre>
<p>不過實際上不是真的使用這條 User Agent style 來實作就是了，因為這個透過  <code>width</code> 和  <code>height</code> 計算出來的寬高比只有在圖片還沒讀取的時候會有效，圖片讀取完成後就會改成用圖片實際的尺寸來計算怎麼顯示了，所以要說它是預設的寬高比也不太正確。</p>
<p>在 CSS Image 這個 Module 的第四章：<a href="https://drafts.csswg.org/css-images/#sizing">Sizing Images and Objects in CSS</a> 中，有詳細的定義要怎樣決定圖片在繪製在網頁上時要怎樣處理，還定義了一些專有名詞：</p>
<ul>
<li><strong>Intrinsic dimensions</strong> 簡單一點形容就是圖片的原始尺寸，尺寸包含了寬（intrinsic width）、高和寬高比，不一定會全部都有，像是向量圖就只有寬高比，另外 intrinsic 中文翻譯是固有、或是根本的，所以 intrinsic dimentions 也不是真的就是圖片原始尺寸，它的文字敘述是：a preferred or natural size of the object itself。</li>
<li><strong>Specified size</strong> 使用 CSS 設定的物件大小。</li>
<li><strong>Concrete object size</strong> 根據上面兩個資訊所決定的實際上物件要繪製的大小，也就是我們眼睛所會看到的圖片呈現的大小。</li>
</ul>
<p>所以主要就是在寫怎樣計算 concrete object size 了，大概計算過程就是和各位腦袋中想的不會差距太大。不過在這個地方，有一個細節是在 CSS 文件中故意沒有講出來的，就是怎樣取得 intrinsic dimensions，CSS 文件中沒有明確的說 intrinsic width 是來自圖片標籤的 <code>width</code> 屬性，或是圖片的實際寬度（早在 CSS 2.1 就有<a href="https://www.w3.org/TR/CSS21/conform.html#intrinsic">寫出</a> CSS 文件不定義怎樣取得該數值了）。其實 HTML 圖片的 intrinsic dimensions 要怎麼取得是放在 HTML 文件的 <a href="https://html.spec.whatwg.org/multipage/rendering.html#dimRendering">15.4.3</a>，15 章都在講 rendering，15.4 則是 replaced elements，也就是圖片、影片之類的內容會整個替換掉的元素，15.4.3 最後一段的第一點是說圖片如果有抓下來的話就直接用圖片的 intrinsic aspect ratio，而第二點是這樣寫的：「If img's <code>width</code> and <code>height</code> attribute values, when parsed using the rules for parsing dimension values), are both not an error, not a percentage, and non-zero, then use   the ratio resulting from dividing the <code>width</code> attribute value   by the <code>height</code> attribute value.」這邊就明確的寫到用兩個屬性來計算 intrinsic aspect ratio 了，不過針對這個圖片讀取完成前的 intrinsic aspect ratio，並沒有定義一個專有名詞，所以可以看到 cnaiuse 用一個<a href="https://caniuse.com/mdn-html_elements_img_aspect_ratio_computed_from_attributes">複雜的文字</a>來敘述這項修改，要是我的話應該會把這個值命名為 intrinsic aspect ratio of incomplete image 之類的吧。</p>
<p>最後整理一下：</p>
<ul>
<li>圖片讀取完成前，如果有設定正確的數值的 width 和 hieght 的話，瀏覽器會先它們來計算 intrinsic aspect ratio</li>
<li>圖片讀取完成後，瀏覽器會用圖片原始的寬高比來作為 intrinsic aspect ratio</li>
<li>本來是希望能用在所有的 replaced elements，不過會造成既有網站壞掉所以目前限制在 <code>&lt;img&gt;</code> 標籤</li>
<li>以上的修改是大約是今年前半年才進入瀏覽器的</li>
</ul>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-11-29T23:05:12+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/11/25/scroll-margin-padding/">
<title>Scroll Margin/Padding</title>
<link>https://blog.othree.net/log/2020/11/25/scroll-margin-padding/</link>
<description><![CDATA[<p>這篇文章要介紹一組算是蠻新的 CSS 屬性，分別是 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-margin"><code>scroll-margin</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-padding"><code>scroll-padding</code></a>，這兩個屬性是在 <a href="https://stackoverflow.com/questions/4086107/fixed-page-header-overlaps-in-page-anchors">Scroll Snap Module Level 1</a> 裡面定義的，目前主要的瀏覽器都有<a href="https://caniuse.com/mdn-css_properties_scroll-margin">支援</a>，IE 完全不支援，Safari 則是還在使用舊的非標準的屬性名稱，為什麼要介紹這兩個屬性呢？因為它除了原來 scroll-snap 微調的需求之外，還順便解決了一個存在已久的問題，也就是如果網頁的設計有固定浮動在頁面頂端的 header 時（Sticky/Fixed Header），使用 link 的 fragment 直接定位到頁面特定位置的時候，最上面一部份想顯示給訪客的內容會被 header 覆蓋到。</p>
<p>這個問題大概是從 Sticky Header 出現時就存在了，Stack Overflow 上就可以找到<a href="https://stackoverflow.com/questions/4086107/fixed-page-header-overlaps-in-page-anchors">十年前的發問</a>，以前的主要的解決方法就是讓連結的目標有看不到的高度，像是用 <code>padding-top</code>，比較乾淨一點是用 pseudo-element 的 <code>:before</code> 來把內容往下推，不過這幾個方法雖然有用，但是對我來說卻一直不是個最佳解，所以一直以來我都期待能有更漂亮的解決方案，有事沒事就會搜尋一下，然後，終於我發現了這組 CSS 屬性可以用來讓瀏覽器自己捲動到目標時有指定的偏移。</p>
<p><code>scroll-margin</code> 是用在你想要捲動到的目標元件上，也就是有 id 的那個，像我的 blog 就是 <code>&lt;article&gt;</code> 標籤，給它加個 <code>scroll-margin-top: 56px;</code> 就可以了：</p>
<pre><code class="language-css">article {
  scroll-margin-top: 56px;
}
</code></pre>
<p><code>scroll-padding</code> 則是要用在 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Scroll_container">scroll container</a> 上的，而不是目標的父母層，舉例來說，在我這邊，沒有特別設定任何 <code>overflow</code> 的情形下，scroll container 會落在 <code>&lt;html&gt;</code> 元件上，而不是 <code>&lt;article&gt;</code> 外面的 <code>&lt;main&gt;</code>，所以設定就要改成：</p>
<pre><code class="language-css">html {
  scroll-padding-top: 56px;
}
</code></pre>
<p>這組 CSS 屬性我是今年才發現的，不過其實 CSS Trick 在去年就有文章介紹了：<a href="https://css-tricks.com/fixed-headers-on-page-links-and-overlapping-content-oh-my/">Fixed Headers, On-Page Links, and Overlapping Content, Oh My! </a>，真是太後知後覺了（其實也是因為我現在沒用 RSS reader 的關係）。</p>
]]></description>
<dc:subject>css-html</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-11-25T22:18:02+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/11/20/realforce-r2-mac-key-mapp/">
<title>Realforce R2 Mac Key Mapping</title>
<link>https://blog.othree.net/log/2020/11/20/realforce-r2-mac-key-mapp/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/50624884456/" title="system-preference-switch by othree, on Flickr"><img src="https://live.staticflickr.com/65535/50624884456_79c8476838_b.jpg" intrinsicsize="1024x891" width="1024" height="891" alt="system-preference-switch" srcset="https://live.staticflickr.com/65535/50624884456_79c8476838_b.jpg 1024w, https://live.staticflickr.com/65535/50624884456_be71932787_h.jpg 1336w" /></a></p>
<p>換了 Realforce R2 TKL(Tenkeyless) 其實好一陣子了，本來是沒有特別要發一篇文章的，不過前陣子因故裝起了 <a href="https://mizage.com/divvy/">Divvy</a> 和 <a href="https://karabiner-elements.pqrs.org/">Karabiner-Elements</a>，然後接著的一些設定和發現可以作為之後買新鍵盤的一些參考，所以還是發個一篇文章來紀錄一下。</p>
]]></description>
<dc:subject>buy</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-11-20T23:40:43+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/08/06/usb-cdisplayport/">
<title>USB-C、DisplayPort</title>
<link>https://blog.othree.net/log/2020/08/06/usb-cdisplayport/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/50176207458/" title="LG UltraFine 5K by othree, on Flickr"><img src="https://live.staticflickr.com/65535/50176207458_47d3e5420f_b.jpg" intrinsicsize="1024x768" width="1024" height="768" alt="LG UltraFine 5K" srcset="https://live.staticflickr.com/65535/50176207458_47d3e5420f_b.jpg 1024w, https://live.staticflickr.com/65535/50176207458_6984419dba_h.jpg 1600w" /></a></p>
<p>前陣子為了買螢幕認真的研究了一下 USB-C 介面的問題，然後就在 FB 上快速的紀錄了一下，這篇就把那時的紀錄轉過來，每段文字前後有點不連貫還請忽略，然後尾巴加一些後來研究才知道的東西，當然因為我不是這方面專業的，內容有錯還請通知我～</p>
<p>最有趣的大概是 USB-C to HDMI 幾乎都是走 DisplayPort Alt. mode 然後線上晶片轉成 HDMI 訊號吧，反而沒有什麼支援輸出  HDMI Alt. mode 的設備，就算有，用上這種主動線材也不能用，然後買線的時候，有些廠商又不寫他是支援 DisplayPort Alt. mode  還是 HDMI Alt. mode（像是那個 moshi，盒子上可能有寫但是網站上都沒寫），不過現在應該幾乎都是前者吧，後者專用的線材可能還要特別去找。</p>
<p>然後 Mac 之前 Thunderbolt 3 其實只有支援到傳輸 DisplayPort 1.2 的訊號，但是 DisplayPort 1.2  的資料傳輸量只有支援到 4K 60Hz，只是 Thunderbolt 3 可以傳輸兩組 DisplayPort 1.2 訊號，所以可以把 5K 60Hz 10bpc(bit per color) 的視訊資料塞進去。不過最近出的 Pro Display XDR 是 6K 螢幕，一樣只用一條 Thunderbolt 3 線傳輸，研究一番才發現應該是 Mac 換了新的 Thunderbolt 晶片，現在支援到 DisplayPort 1.4，所以可以輸出到 6K 訊號了，不過一般查 Thunderbolt 3 都還是只有寫支援到 DisplayPort 1.2，不知道是不是其實這部分是動態沒寫死的。</p>
<p>再來就是我之前貼的兩台螢幕，MSI 那台的 USB-C 頭在使用手冊內有寫說不支援數據傳輸，所以那個頭應該是用 USB-C 的 DisplayPort Alt. mode，而不是 Thunderbolt Alt. mode 去傳輸 DisplayPort 訊號，LG 的是後者，所以它可以一條線同時做訊號傳輸，還提供筆電充電和三個  USB-C 頭出來（真的是 USB 介面的），不過沒有 downstream 來串接 Thunderbolt 設備，4K 版才有多餘的頻寬。</p>
<p>蘋果那條 Pro Cable 厲害的點就是在它有 2M 長度，但是：</p>
<ol>
<li>支援 USB-C 資料傳輸，傳輸速度可以到 USB 3.1 Gen 2 的 10Gbps；</li>
<li>Thunderbolt 3 Alt. mode，傳輸速度可以到最高速的 40 Gbps；</li>
<li>DisplayPort Alt. mode 訊號，並且支援到 1.3 的 HBR3，資料量有到 25.92 Gbps；</li>
<li>支援充電到 100W，也是 Thunderbolt 3 規格的最高功率。</li>
</ol>
<p>可以說是目前最常見的模式都有支援到目前的頂級規格了，一般這種長度的線通常就是：1. 普通 USB-C 被動（沒晶片處理）線材，然後就無法乘載 Thunderbolt 3 的 40G 訊號；2. 主動的 Thunderbolt 3 or DisplayPort 線材，但是就會變成只能傳輸自己支援的訊號，不能當 USB-C 線用，蘋果那條線到底是怎麼同時達成其實還不清楚，充電要怎樣能到 100W 然後同時傳輸這樣大量的資料也是很厲害。其實也有廠商出過同時可以當 Thunderbolt 3 和 USB 的<a href="https://www.akitio.com.tw/accessories/40gbps-thunderbolt3-cable-2m">線材</a>，只是 USB 就不能到 10Gbps，充電也有差，總之就是沒有樣樣完美的。</p>
<p>MacBook Pro 16 現在有支援同時輸出給兩台 Pro Display XDR，不過要一台插左邊，一台插右邊，其實 5K 就需要了，官網文件有寫，所以大概可以知道四個 port 頻寬是左右兩邊分開的，其實 Apple 官方文件寫的還蠻仔細的，不同機種都有各自的文件說明：</p>
<ul>
<li><a href="https://support.apple.com/en-us/HT210754">MacBook Pro 16</a></li>
<li><a href="https://support.apple.com/en-us/HT208366">iMac Pro</a></li>
<li><a href="https://support.apple.com/en-us/HT210392">Mac Pro with Radeon Pro Vega II Duo MPX Module</a></li>
</ul>
<p>然後 DisplayPort 1.4 有支援到 8K 60Hz 的訊號，Dell 也有一台 8K 螢幕 UP3218K 支援到 8K 60Hz 10bpc，不過現在一來 macOS 不支援輸出 8K，二來 Dell 那台如果要支援 8K 60Hz 是用兩條 DisplayPort 1.3（標準接頭）來傳輸訊號的，因為 DisplayPort 1.3 只有支援到 8K 30Hz，單一條無法到達 60Hz。不過一來 30Hz 蘋果不喜歡，二來兩條線也不符合蘋果美學，所以這個組合在可見的未來大概也是無法搭配在一起吧，我推測蘋果的裝置要支援到 8K 螢幕應該是至少要先換到 Thunderbolt 4 的介面，用比較高效的編碼然後用到單向 80Gbps 的傳輸，不過單向傳輸的話其實就無法同時串接 Thunderbolt 裝置了，也會變成無法達成一條線同時傳視訊、資料和充電，到時候到底會怎樣還是很很讓人好奇啊。</p>
<p>說到這其實我就很好奇，兩條 DisplayPort 線輸出高解析度畫面，這靠的是什麼標準呢？以前在 DVI 時代，這叫做 Dual-Link，不過 DisplayPort 似乎沒有相對應的專有名詞，蘋果網站和 LG 說是 dual-link SST(Single Stream Transport) ，Thunderbolt 網站有看到寫 Dual DisplayPort 的，不過似乎都不是正式的名稱，我基於好奇搜尋許久，還找到看起來好像很有關連的 DisplayPort Dual Mode（DP++）這東西，但是其實這也不是我要找的，我要找的最後是在一份 VESA 在 Display Summit 用的投影片中找到，這份投影片叫：<a href="https://www.vesa.org/wp-content/uploads/2016/06/Display-Summit-USA-2016-AMD-VESA-SAH_Final_r1.pdf">DisplayPort Future Proofing Display Connectivity for VR and 8K HDR</a>，其實這個能力是真的沒有特別的專有名詞（行銷用詞），它是利用 <a href="https://en.wikipedia.org/wiki/DisplayID">DisplayID</a> 的一個功能「Tiled Display Topology Data Block」來達成的，意思就是顯示器的 DisplayID 會跟訊源說你可以把我當成是一組並排螢幕中的一個，Dell UP3218K 是需要實體的 DisplayPort 線兩條，顯示器只要其中一個孔位說是左邊，一個說是右邊就可以，然後解析度都是 3840 × 4320 at 60Hz ，像 Thunderbolt 3 可以傳輸兩組 DisplayPort 訊號，也是一樣的方式，接 UltraFine 5K 的話是兩組 2560 × 2880 at 60Hz 10bpc 的訊號。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/50195209003/" title="Pro Cable by othree, on Flickr"><img src="https://live.staticflickr.com/65535/50195209003_39aa1b5807_b.jpg" intrinsicsize="1024x768" width="1024" height="768" alt="Pro Cable" srcset="https://live.staticflickr.com/65535/50195209003_39aa1b5807_b.jpg 1024w, https://live.staticflickr.com/65535/50195209003_60a2cb1dd3_h.jpg 1600w" /></a></p>
<p>最後，如果你看到一台螢幕號稱說是 USB-C 螢幕，那有三種可能性，一是它只支援 Thunderbolt Alt. mode，像是舊版的 LG UltraFine 5K；二是它只支援 DisplayPort Alt. mode，像是 MSI Prestige PS341WU；最後就是兩種都支援，像是新版的 LG UltraFine 5K。哇！除了線材挑選有學問之外，螢幕說支援 USB-C 接頭傳輸視訊，其實也有不同可能性了，USB-C 真的很難！</p>
]]></description>
<dc:subject>buy</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-08-06T23:30:04+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/08/01/upgrade-my-monitor/">
<title>更新螢幕</title>
<link>https://blog.othree.net/log/2020/08/01/upgrade-my-monitor/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/50176899326/" title="LG UltraFine 5K by othree, on Flickr"><img src="https://live.staticflickr.com/65535/50176899326_873c44ed56_b.jpg" intrinsicsize="1024x768" width="1024" height="768" alt="LG UltraFine 5K" srcset="https://live.staticflickr.com/65535/50176899326_873c44ed56_b.jpg 1024w, https://live.staticflickr.com/65535/50176899326_4d8f5560db_h.jpg 1600w" /></a></p>
<p>最近因為改用公司發的筆電，所以買了一台新螢幕，本來用的初代 Retina 5K iMac 就先搬回舊家了，這篇來記錄一下這次的螢幕的挑選過程。</p>
]]></description>
<dc:subject>buy</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-08-01T23:22:17+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/07/17/safari-3rd-party-cookie/">
<title>Safari 3rd-Party Cookie</title>
<link>https://blog.othree.net/log/2020/07/17/safari-3rd-party-cookie/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/50122828112/" title="Apple ITP by othree, on Flickr"><img src="https://live.staticflickr.com/65535/50122828112_79ce3e54d3_b.jpg" intrinsicsize="1024x837" width="936" height="765" alt="Apple ITP" srcset="https://live.staticflickr.com/65535/50122828112_79ce3e54d3_b.jpg 1024w, https://live.staticflickr.com/65535/50122828112_73eaebf7b0_h.jpg 1600w" /></a></p>
<p>Apple 之前有<a href="https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/">宣告</a>要完全阻擋 3rd-party cookie，iThome 也有相關的<a href="https://www.ithome.com.tw/news/136565">報導</a>，iOS 和 iPadOS 應該是已經上線了，然後最近 Mac 版 Safari 也快要上線了，所以這篇來記錄一下要怎樣因應還有一些參考資料。</p>
<p>其實真的會寫到第三方 cookie 的服務是沒想像多的，如果不是開發給其它網站用的第三方服務的話（不是掛 script 而已），那其實沒那麼常見，舉例來說：很多人可能會覺得 Google Analytic 會受影響，但是其實並沒有，一般網站掛 Google Analytic 算是掛上 3rd-party script，但是它寫的 cookie 是 1st party cookie，也就是寫在你的網站的 domain 下，Google 的文件也有很詳細的說明他的每個 cookie 的<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/cookie-usage">用途</a>，然後仔細看就會找到還有寫如何<a href="https://developers.google.com/analytics/devguides/collection/analyticsjs/cross-domain">跨網域追蹤</a>，而這其實是需要帶一些參數過去的，如果 GA 是用 3rd-party cookie 寫在 Google 自己的 domain 的話，要跨網域追蹤就不需要這樣帶參數了，我是覺得 Apple 的 ITP 比較是針對廣告和 Facebook，早幾年前 Facebook 可以用 like button 來簡單的做到跨站追蹤，現在那些 iframe 都會被認為是 3rd-party，cookie 會和 1st-party 放不同區（partition），甚至本來如果有先去看過 facebook.com 之後，會有 24 小時可以存取該網域 3rd-party cookie 的能力也在 <a href="https://webkit.org/blog/8311/intelligent-tracking-prevention-2-0/">ITP 2.0</a> 移除，facebook 後來加上了 <code>fbclid</code> 這個參數來追蹤連出去的連結，然後 <a href="https://webkit.org/blog/8828/intelligent-tracking-prevention-2-2/">ITP 2.2</a> 就又針對這種連結裝飾（link decoration）也設了 cookie 的存取限制（剛好同時也影響到 Google Analytic）。</p>
<p>如果真的是需要作為 3rd-party 端提供服務的話怎麼辦呢？其實一開始 Apple 那篇<a href="https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/">文章</a>，有列了幾個方案，其中正規的兩個方案：</p>
<ol>
<li>用 OAuth 2.0 作為 user auth 的方案，然後第一方網站拿到 token 後自己存好（作為 1st-party cookie 或是其它儲存方法）。</li>
<li>用 <a href="https://webkit.org/blog/8124/introducing-storage-access-api/">Storage Access API</a>，這是 Apple 所提出的 Web API，在被視為第三方的 context 中（例如 iframe），可以透過 Storage Access API 來取得 1st-party cookie 的存取權限，不過一般人直接用這個 API 要權限，可能會覺得奇怪怎麼 Safari 都沒有問使用者要不要給，權限就拿到了，其實這是因為 Apple 那邊的想法是這個 API 要盡可能的不干擾使用者，所以只有被歸類（classified）為有追蹤能力的域名才會跳出視窗跟使用者詢問，至於這個歸類的方法是在 <a href="https://webkit.org/blog/7675/intelligent-tracking-prevention/">ITP 1.0</a> 中提出的，Apple 考慮到隱私問題，所以這個機制是用機器學習的，每台電腦/裝置都維護自己的清單，沒有中心化的黑名單（Firefox 應該是用這種方法），而如果想要親自驗證自己的 domain 要是被歸類為追蹤網站的話，會發生什麼事的話，也有篇<a href="https://webkit.org/blog/8387/itp-debug-mode-in-safari-technology-preview-62/">文章</a>介紹，我自己有測試過也確實看到了那個詢問視窗。</li>
</ol>
<p>然後如果要用 Storage Access API，其實還有些限制，Safari 從 1.0 開始，就有個針對 3rd-party cookie 的限制，就是使用者要曾經直接訪問過該網域，並且寫入過 1st-party cookie，之後該網域才能對 3rd-party cookie 做存取，而這項限制也延伸到 Storage Access API 這邊，一樣要先作為 1st-party 寫入過 cookie，之後才能夠透過 Storage Access API 取得 1st-party cookie 的存取權限，Apple 負責 ITP 的 <a href="https://twitter.com/johnwilander">John Wilander</a> 最近正在寫相關的<a href="https://bugs.webkit.org/show_bug.cgi?id=193277#c7">文件</a>，裡面就有提到，然後這個限制 Firefox 也有，不過 Firefox 似乎是 30 天內有訪問過該網域就可以。</p>
<p>寫到這邊，其實有件事情忘記先提，就是網路上你去搜尋 <strong>Safari 3rd Party Cookie</strong> 會找到一些方法說可以成功讀寫 3rd-party cookie 的，那些全部都已經失效了，而且不只是 cookie，所有可以寫入的東西像是 DOM Storage 也是有受到一樣的限制保護的（然後 Storage Access API 現在<a href="https://twitter.com/jonathandavis/status/1204102948571119616">只能拿到 cookie 的權限</a>），目前也沒有出現其它的繞過方式，而且就算有人找到，Apple 都會修掉的，所以如果有這需求還是趕快用 Storage Access API 實做吧（別忘了 feature detection）。</p>
<p>然後或許有人會覺得 ITP 沒檔到 Google Analytic 好像沒什麼意義，其實 <a href="https://twitter.com/johnwilander">John Wilander</a> 早在 2017 年就有在 WebAppSec 稍微<a href="https://lists.w3.org/Archives/Public/public-webappsec/2017Mar/0034.html">提過 Single Trust</a> 這件事，提的就是網頁內掛的 3rd-party script 其實是安全性隱憂，應該只有同 domain 的東西可以信任，在 cookie 這邊來說就是 3rd-party script 不應該有存取網站 1st-party cookie 的權限（不過後來發生的是<a href="https://twitter.com/GossiTheDog/status/1038333980423204865">某航空公司的信用卡資訊輸入頁面放的第三方 script 會做 key log</a>），如果真的進行，這個改變可以想像的到影響非常的巨大，舉例來說，以前的 Performance Practice 其中一項是把 static file 放到 CDN 並且用不同 domain host，但是這樣其實就會被當成是 3rd-party script 了，雖然他在我們的認知下是可信任的，然後目前也有非常大量的現存網站是這樣做。目前 Apple 也有在做一些相關的研究，其中一個已經廣為人知(?)的就是 Safari 現在有在<a href="https://bugs.webkit.org/show_bug.cgi?id=204262">紀錄 3rd-party script 的數量</a>，另外就是我之前在 <a href="https://blog.othree.net/log/2019/05/27/incrementally-better-cookies/">SameSite Cookie</a> 這篇文章有提到的，Mike West 起草的 <a href="https://github.com/WICG/first-party-sets">First-Party Sets</a>，透過 <code>/.well-known/</code> 下的檔案定義可以被認為是 1st-party 的 domain 清單，假設未來真的要做到 single trust 的程度，要處理 CDN 之類的問題，像是 First-Party Sets 的機制就不可少。</p>
<p>最後附上一些延伸的參考資料：</p>
<ul>
<li><a href="https://github.com/whatwg/html/issues/3338#issuecomment-357790890">在提案 Storage Access API 時，Apple 工程師整理的 Safari 行為</a></li>
<li><a href="https://medium.com/@meistudio/the-rise-of-privacy-8c9ea5f53b09">Paul Li 之前在介紹 SameSite Cookie 時也有討論到相關的問題，並且還有一個 test suite</a></li>
<li><a href="https://www.tenmax.io/archives/14012">TenMax 介紹 ITP 的這篇文章的 ITP 發展歷程整理的很棒</a></li>
<li><a href="https://note.com/martech">日本的 AD EBiS マーテック研究会 的文章資訊都很新且深入</a></li>
</ul>
]]></description>
<dc:subject>web</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-07-17T21:51:00+08:00</dc:date>
</item>

<item rdf:about="https://blog.othree.net/log/2020/05/02/2019/">
<title>2019</title>
<link>https://blog.othree.net/log/2020/05/02/2019/</link>
<description><![CDATA[<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/49845723161/" title="2019 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/49845723161_bccd876b09_b.jpg" intrinsicsize="768x1024" width="576" height="768" alt="2019" srcset="https://live.staticflickr.com/65535/49845723161_bccd876b09_b.jpg 768w, https://live.staticflickr.com/65535/49845723161_349079f004_h.jpg 1200w" /></a></p>
<p>2019 年的回顧也是拖很久，這次也是拖到五月了，不過基本上和去年一樣，沒有什麼拍照，所以只能做一個整年度的紀錄，這一年最大的不同就是整個年度都要照顧小孩，其實我的生活形態已經變成像是過一週算一週的方式了，每週維持一樣的生活步調，咬牙苦撐完 52 週就結束了這一年，還蠻沒有什麼過了一年的實感，不過小孩在兩歲前的成長真的是不等人，去年還在那邊爬來爬去，現在已經可以跑來跑去講一堆話了，根據我周邊同事和我的感想，小孩最可愛就是一歲半到兩歲中間這段時期了（其實有點跨到今年了），還沒有生小孩或是小孩還沒到這個年記得朋友還請把握這段時期XD</p>
<p>另外一件值得記錄的就是 COSCUP 還有負責辦 Open Web Technologies 議程（今年因為眾多考量就沒繼續了，留待明年再說），一開始投稿階段稿量很高，結果仔細一看發現一人多投的還不少，有點尷尬，最後選出來的海外講者也比我預期的還多，我自覺是沒有統整的很好，甚至有些 TODO 自己都沒做好，當然也是因為要照顧小還有些事情不能親自下去，而且其實意外的不好找人幫忙，像是 Moztw 社群內就找不太到人來幫忙當天的雜事，另外就是去年半下來我認為最需要避免再犯的就是在徵稿階段就需要提示主辦方對於講者能提供多少補助，像是 COSCUP 無法對講者旅費做補助，就讓兩位外國講者無法參與，我印象中其中一位是內部審稿已經過關了但是才確定不行，因為我在跟他聯絡後，該名講者也有自己去找他們公司內部的補助，不過沒有過關，如果能提早告知這個部分的資訊，應該是可以避免這個過程，也不用讓雙方都有錯誤的期待了。</p>
]]></description>
<dc:subject>diary</dc:subject>
<dc:creator>othree</dc:creator>
<dc:date>2020-05-02T21:53:25+08:00</dc:date>
</item>


</rdf:RDF>