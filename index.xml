<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>i</b:listType>
			<b:listData listID="index"/>
		</b:entriesMeta>

		<b:entry entryID="000919" baseName="htc-u11plus">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-03-24</b:date>
				<b:time>17:46:13</b:time>
			</b:datetime>
			<b:category>buy</b:category>
			<b:title>HTC U11+</b:title>
			<b:content>
				<b:summary> 去年想說要把用了兩三年的 HTC M9 換掉，在 M9 之前其實我 M8、M7 都有用，算是三代機皇的使用者，本來這次想要買 Google Pixel 2 的，不過台灣一直沒上市，直到前幾天 Google 才說要在台灣上市，不過總之，最後考量價錢、機能等等，決定買號稱本來是 Pixel 2 XL 的 HTC U11+，然後也決定要買主打的透明黑，不過可能因為生產問題，透明黑比較晚上市，其實當時差不多是去年的 1111，各家都有特價什麼的，但是卻買不到透明黑感覺實在有點尷尬，連 HTC 自家網站，當時也有些活動，買 U11+ 就可以用很好的折扣家買周邊，有限期間，於是我就每天上去看，看了好幾天覺得，應該沒這麼會做決策吧，結果一如預期的，特價活動結束隔天才有得下單預定透明黑... 我當然是不差買那些周邊啦，不過對於這種搞法實在是無法參透，總之我還是第一天就下定了，後來也比一堆開箱文還早兩三天拿到，不過拖到今天才來記錄一下。 整體而言我覺得這台還蠻不錯的，透明黑玻璃很漂亮，價錢 ok，定價和五吋的高階機種（U11）一樣，對比於 Pixel 的價位真的是親切很多，而且規格和螢幕都比較大，電池電量表現也很不錯，出門一整天也不用擔心沒電，U11 開始主打的 Edge Sense，拿來單手拍照真的很不錯，相機表現也不錯，不過那個側框啟動叫出目錄的功能就不太行了，主要是反應太慢，還不如用指紋直接開畫面，另外一點就是指紋速度很快，還有防塵防水，然後初期宣傳有說全面屏，不過實際上只是正面的玻璃是全部覆蓋，沒有接縫，或許 Google 當初要捨棄實體鍵打的就是這個主意。 不過 U11+ 還是有點問題，其中我比較有感的就是要用 Google...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/38956472765/" title="HTC U11+ by othree, on Flickr"><img src="https://farm5.staticflickr.com/4704/38956472765_7d5d8a75ce_b.jpg" width="1024" height="683" alt="HTC U11+" srcset="https://farm5.staticflickr.com/4704/38956472765_7d5d8a75ce_b.jpg 1024w, https://farm5.staticflickr.com/4704/38956472765_4c6a20240a_h.jpg 1600w" /></a></p>
<p>去年想說要把用了兩三年的 HTC M9 換掉，在 M9 之前其實我 M8、M7 都有用，算是三代機皇的使用者，本來這次想要買 Google Pixel 2 的，不過台灣一直沒上市，直到前幾天 Google 才說要在台灣上市，不過總之，最後考量價錢、機能等等，決定買號稱本來是 Pixel 2 XL 的 HTC U11+，然後也決定要買主打的透明黑，不過可能因為生產問題，透明黑比較晚上市，其實當時差不多是去年的 1111，各家都有特價什麼的，但是卻買不到透明黑感覺實在有點尷尬，連 HTC 自家網站，當時也有些活動，買 U11+ 就可以用很好的折扣家買周邊，有限期間，於是我就每天上去看，看了好幾天覺得，應該沒這麼會做決策吧，結果一如預期的，特價活動結束隔天才有得下單預定透明黑... 我當然是不差買那些周邊啦，不過對於這種搞法實在是無法參透，總之我還是第一天就下定了，後來也比一堆開箱文還早兩三天拿到，不過拖到今天才來記錄一下。</p>
<p>整體而言我覺得這台還蠻不錯的，透明黑玻璃很漂亮，價錢 ok，定價和五吋的高階機種（U11）一樣，對比於 Pixel 的價位真的是親切很多，而且規格和螢幕都比較大，電池電量表現也很不錯，出門一整天也不用擔心沒電，U11 開始主打的 Edge Sense，拿來單手拍照真的很不錯，相機表現也不錯，不過那個側框啟動叫出目錄的功能就不太行了，主要是反應太慢，還不如用指紋直接開畫面，另外一點就是指紋速度很快，還有防塵防水，然後初期宣傳有說全面屏，不過實際上只是正面的玻璃是全部覆蓋，沒有接縫，或許 Google 當初要捨棄實體鍵打的就是這個主意。</p>
<p>不過 U11+ 還是有點問題，其中我比較有感的就是要用 Google Map 導航會進不了導航狀態，這問題在官方論壇上也有討論，暫時的解法是重開機可以修復，所以還可以接受，除此之外如果還要挑，大概就是螢幕還沒到 4K 吧，不過是廣色域的其實也蠻不錯了，聽說今年的 U12 就會是 4K 螢幕了，不過我應該下一台真的會買 Pixel 了吧。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000918" baseName="accessibility-object-model">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-03-08</b:date>
				<b:time>08:25:17</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Accessibility Object Model</b:title>
			<b:content>
				<b:summary>很久以前介紹 AMP 的時候，有提到標準內的 HTML attribute，都是有其意義和用途，而當然 WAI-ARIA 的那堆 aria-* 屬性也是，不過以前那堆東西的介面在 web 開發端是碰不到的，不過前陣子在看 Chrome Platform Status 的時候，發現到了一個新的標準草稿叫做 Accessibility Object Model，中文可以叫做親和力物件模型吧，還很早期不過 Firefox 有一些基本實做，預設關閉，掛在他們的 Accessiblity API 下面。 這個標準目前規劃四個階段，目前有內容的只有前兩個，分別要做的事情是： Accessible Property，建立存取親和力相關屬性的標準界面，包括了 role 和 aria-*，目前的草案不是直接把這些屬性放在 ElementNode 下，而是在 ElementNode 新增一個 accessibleNode； Accessible Action，建立和親和力相關的事件，擴充 accessibleNode 並且讓它會接收到這些親和力相關事件； Virtual Accessibility...</b:summary>
				<b:mainContent><p>很久以前介紹 <a href="https://blog.othree.net/log/2016/10/14/acclerated-mobile-pages/">AMP</a> 的時候，有提到標準內的 HTML attribute，都是有其意義和用途，而當然 WAI-ARIA 的那堆 <code>aria-*</code> 屬性也是，不過以前那堆東西的介面在 web 開發端是碰不到的，不過前陣子在看 <a href="https://www.chromestatus.com/features/6643371200217088">Chrome Platform Status</a> 的時候，發現到了一個新的標準草稿叫做 <a href="https://github.com/WICG/aom/">Accessibility Object Model</a>，中文可以叫做親和力物件模型吧，還很早期不過 Firefox 有一些基本實做，預設關閉，掛在他們的 <a href="https://wiki.mozilla.org/Accessibility/WebAccessibilityAPI">Accessiblity API</a> 下面。</p>
<p>這個標準目前規劃四個階段，目前有內容的只有前兩個，分別要做的事情是：</p>
<ol>
<li>Accessible Property，建立存取親和力相關屬性的標準界面，包括了 <code>role</code> 和 <code>aria-*</code>，目前的草案不是直接把這些屬性放在 ElementNode 下，而是在 ElementNode 新增一個 <code>accessibleNode</code>；</li>
<li>Accessible Action，建立和親和力相關的事件，擴充  <code>accessibleNode</code> 並且讓它會接收到這些親和力相關事件；</li>
<li>Virtual Accessibility Node，讓開發者可以產生虛擬的 <code>accessibleNode</code>，然後這些虛擬的 node 也有前兩個階段的能力，所以可以預期像是用 canvas 畫的介面也可以生出介面讓數位輔具可以溝通；</li>
<li>Computed Accessibility Tree，提供 Accessibility Tree 的介面，目前，Accessibility Tree 也還是網頁開發者碰不到的。</li>
</ol>
<p>目前這份草稿還在 WICG，不過已經開始有些實做了，除了 Firefox 之外 Chrome 也有，我看作者是 Mozilla、Google、Apple 的人都有，之後應該會慢慢發展成統一的數位輔具介面吧。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000917" baseName="webdriver-level-2">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-02-17</b:date>
				<b:time>00:00:08</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>WebDriver Level 2</b:title>
			<b:content>
				<b:summary> 這超新的，新到其實什麼都還沒有，不過總之記錄一下，有兩條路線匯流： 第一條是 E2E 測試，E2E 測試比較早期是 Selenium 一家獨大，以前不知道是用什麼方法控制瀏覽器，就我瞭解應該不是太正規的方式，後來到 Selenium 2 開始發展 WebDriver，而且各家 browser vendor 都還蠻支持的，也朝向標準化的方向前進，標準文件現在也已經是 CR 了，由 Browser Testing and Tools 工作小組在維護，不過看了看 mailing list，該工作小組目前活躍度好像不高。標準化的好處就是大家都可以照著做，除了 Selenium WebDriver 之外的實做，現在還有 WebDriverIO 這個 nodejs 環境的實做，理論上可以只用 WebDriverIO 加上瀏覽器各自的 driver 而不用透過 Selenium 來做自動化測試 另外一條路線是 remote debugging，這個一開始是為了...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/26429223408/" title="Chrome DevTool Protocol by othree, on Flickr"><img src="https://farm5.staticflickr.com/4632/26429223408_e0beb83830_b.jpg" width="1024" height="483" alt="Chrome DevTool Protocol, " srcset="https://farm5.staticflickr.com/4632/26429223408_e0beb83830_b.jpg 1024w, https://farm5.staticflickr.com/4632/26429223408_a4b04c9af7_h.jpg 1600w" /></a></p>
<p>這超新的，新到其實什麼都還沒有，不過總之記錄一下，有兩條路線匯流：</p>
<p>第一條是 E2E 測試，E2E 測試比較早期是 Selenium 一家獨大，以前不知道是用什麼方法控制瀏覽器，就我瞭解應該不是太正規的方式，後來到 Selenium 2 開始發展 WebDriver，而且各家 browser vendor 都還蠻支持的，也朝向標準化的方向前進，標準文件現在也已經是 <a href="https://www.w3.org/TR/webdriver/">CR</a> 了，由 <a href="https://www.w3.org/testing/browser/">Browser Testing and Tools 工作小組</a>在維護，不過看了看 mailing list，該工作小組目前活躍度好像不高。標準化的好處就是大家都可以照著做，除了 Selenium WebDriver 之外的實做，現在還有 <a href="http://webdriver.io/">WebDriverIO</a> 這個 nodejs 環境的實做，理論上可以只用 WebDriverIO 加上瀏覽器各自的 driver 而不用透過 Selenium 來做自動化測試</p>
<p>另外一條路線是 remote debugging，這個一開始是為了 debug 手機上的瀏覽器，後，讓手機上的 browser 傳送訊息到桌機上，用桌機瀏覽器的開發工具來顯示資訊，方便除錯，發展到後來，變成開發工具和瀏覽器之間的溝通協定都走同一套，也就是說現在桌機瀏覽器也是用 remote debugging 同樣的溝通方式在跟自己的開發工具溝通，兩者耦合就這樣拉開了，我最早知道可以這樣拆開的是 Opera 以前的 <a href="http://www.opera.com/dragonfly/">Dragonfly</a>，然後可以想見每家瀏覽器的協定內容不一樣，然後就有一位 <a href="https://kenneth.io/">Kenneth Auchenberg</a> 的人出來說這應該要有個標準！然後弄了個 <a href="https://remotedebug.org/">remotedebug.org</a>，初期計畫是希望大家都有個 adapter 可以轉譯自家的協定到公用的協定，像是 Mozilla 的 <a href="https://github.com/mozilla/valence">Valence</a>，然後接著就開始有一些利用這些協定的各種發展，像是幫 Node 程式除錯、或是 iOS App、Electron 應用程式的除錯，甚至是除錯工具的開發也是用除錯工具自己 remote debug 自己，同時 Kenneth Auchenberg 也在推動 W3C 的標準化，一開始（約三年前）就是找上 Browser Testing and Tools 工作小組，不過一開始不太順利，因為那邊的都是自動化測試專門的人，和除錯工具關係其實不大。</p>
<p>Remote debug protocol 的資訊種類和訊息量其實都很大，目前看起來也只有 Google Chrome 的 <a href="https://chromedevtools.github.io/devtools-protocol/">DevTool Protocol</a> 整理的比較完整，而 Firefox 的 Valence 其實已經沒維護了，他們的 README 上說要盡量相容 Chrome 的 protocol，這點讓我有點失望也不太意外，一來是擴充套件的 <a href="https://developer.chrome.com/extensions/devguide">API</a> 已經被 Google <a href="https://blog.mozilla.org/addons/2015/08/21/the-future-of-developing-firefox-add-ons/">帶著走</a>了，二來是 debug 用的資訊太多太雜，不好維護，而且這樣似乎也是比較快可以統一的方式。而標準化的工作其實在去年有點進展，也就是 Browser Testing and Tools 工作小組 終於接納，要把他放進 WebDriver Level 2 裡面了，這其實是去年十月底的消息，在 remotedebug 的 <a href="https://twitter.com/auchenberg/status/925079235173138432">twitter</a> 上有發消息，也有工作小組章程修改的 <a href="https://github.com/AutomatedTester/charter-drafts/commit/0d924010aa1c87c7e39ad7a0737e8b7854eb9428">commit</a> 連結證實，接下來就看他們要怎麼標準化了，畢竟複雜度比 WebDriver Level 1 複雜許多，還有些部分是不穩定可能隨時會變動的。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000916" baseName="codeceptjs-puppeteer">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-02-07</b:date>
				<b:time>12:29:49</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>CodeceptJS + puppeteer</b:title>
			<b:content>
				<b:summary>看起來一切似乎都很美好，直到真的下去用。 這幾天就在這組合裡面打滾，昨天還花了幾乎半天在查一個問題，總之先條列一下目前覺得幾個重點： CodeceptJS 文件裡面有 code sample 用 generator function 的非同步取值，現在支援用 async await 了，不過 code sample 還沒改。 每種 helper 可以用的 method 不完全相同，大部分一樣，不過也沒列出基本組合，所以好像也不是很好一組 test 測所有 helper。 Puppeteer helper 裡面其實有很多地方是直接跟 CDP（Chrome DevTools Protocol） 溝通的，這部分也可以印 debug log： env DEBUG=&quot;puppeteer:protocol&quot; codeceptjs run --steps --verbose 開...</b:summary>
				<b:mainContent><p>看起來一切似乎都很美好，直到真的下去用。</p>
<p>這幾天就在這組合裡面打滾，昨天還花了幾乎半天在查一個問題，總之先條列一下目前覺得幾個重點：</p>
<ul>
<li><a href="https://codecept.io/">CodeceptJS</a> 文件裡面有 code sample 用 generator function 的非同步取值，現在支援用 async await 了，不過 code sample 還沒改。</li>
<li>每種 helper 可以用的 method 不完全相同，大部分一樣，不過也沒列出基本組合，所以好像也不是很好一組 test 測所有 helper。</li>
<li>Puppeteer helper 裡面其實有很多地方是直接跟 CDP（Chrome DevTools Protocol） 溝通的，這部分也可以印 debug log：  <code>env DEBUG=&quot;puppeteer:protocol&quot; codeceptjs run --steps --verbose</code></li>
<li>開 CDP 的 log 的話資訊量會超多，訊息內容還算好理解，細節網路上也有<a href="https://chromedevtools.github.io/devtools-protocol/">文件</a>，左邊 sidebar 有很多不同領域的，上面的 DEBUG 參數也可以自己修改只顯示想要的，詳見 <a href="https://github.com/GoogleChrome/puppeteer#debugging-tips">puppeteer 文件</a>。</li>
<li>puppeteer 的 <code>page.goto</code> 有個選項是 waitUntil，預設是 load 事件，不過我發現這個事件有時候會觸發不到，雖然我看開發工具的 network 圖是有線出來，不過總之我後來會這樣的案例就先都改成 <code>networkidle2</code> 了。</li>
</ul>
<p>然後昨天花很多時間查的問題已經上去發了 <a href="https://github.com/Codeception/CodeceptJS/issues/914">issue</a>，總之就是發點擊事件點連結後，要檢查新頁面的內容會出現錯誤：</p>
<pre><code>     Protocol error (Runtime.callFunctionOn): Cannot find context with specified id undefined
</code></pre>
<p>目前探究下來狀況應該是：puppeteer 的點擊回傳的 promise，在點擊完成就 resolve 了，這時候瀏覽器去開新網頁，才要開始發出請求，新的網頁還沒準備好，所以要做檢查的時候就會沒有 context。然後我有用 Nightwatch helper 測試過，是沒這問題的，總之就是個實做問題，puppeteer 目前這樣邏輯上也不算是錯誤的設計，不知道最後會怎麼修改，當然簡單一點就是 click 觸發 browser navigate 到別的網頁時就要等新網頁回來。目前的 work around 是自己多 wait 一下。</p>
<p>最後就是，我終於可以順暢的把 puppeteer 這個單字打出來了QQ</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000915" baseName="tc39-logo">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-02-02</b:date>
				<b:time>12:29:18</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>TC39 logo</b:title>
			<b:content>
				<b:summary>每兩個月一次的 TC39 會議剛結束的一月會議，除了確定了 ECMAScript 2018 的 feature set 之外，還加碼發佈了 TC39 自己的 logo： 這設計基本上就是參照 JS logo，顏色改成 ECMA 橘，之前那個 JS logo 其實不是官方的，而是社群發起的： 現在還蠻廣泛使用，已經是公認的 logo，兩個 logo 都是放在 GitHub 上 https://github.com/tc39/logo/ https://github.com/voodootikigod/logo.js/...</b:summary>
				<b:mainContent><p>每兩個月一次的 TC39 會議剛結束的一月會議，除了確定了 ECMAScript 2018 的 feature set 之外，還加碼發佈了 TC39 自己的 logo：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28255675539/" title="TC39 by othree, on Flickr"><img src="https://farm5.staticflickr.com/4623/28255675539_95a96b168d_b.jpg" width="1024" height="1024" alt="TC39, " srcset="https://farm5.staticflickr.com/4623/28255675539_95a96b168d_b.jpg 1024w" /></a></p>
<p>這設計基本上就是參照 JS logo，顏色改成 <a href="https://www.ecma-international.org/">ECMA</a> 橘，之前那個 JS logo 其實不是官方的，而是社群發起的：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/40034835081/" title="JS by othree, on Flickr"><img src="https://farm5.staticflickr.com/4715/40034835081_1ebf851535_b.jpg" width="1024" height="1024" alt="JS, " srcset="https://farm5.staticflickr.com/4715/40034835081_1ebf851535_b.jpg 1024w" /></a></p>
<p>現在還蠻廣泛使用，已經是公認的 logo，兩個 logo 都是放在 GitHub 上</p>
<ul>
<li><a href="https://github.com/tc39/logo/">https://github.com/tc39/logo/</a></li>
<li><a href="https://github.com/voodootikigod/logo.js/">https://github.com/voodootikigod/logo.js/</a></li>
</ul>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000914" baseName="recommend-semicolon">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-01-12</b:date>
				<b:time>10:54:06</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>分號大戰 again</b:title>
			<b:content>
				<b:summary>今天一早起來就看到有人說 TC39 要準備建議 JavaScript 程式碼應該要加分號： TC39 is recommending that JS programmers use semicolons at the end of statements in code, rather than relying on ASI.https://t.co/9FY4i29iqs-- Daniel Ehrenberg (@littledan) 2018年1月11日 然後下面就一大串了，本來想說 standardjs 要哭哭了，難道 semistandard 要扶正了嗎？不過我仔細端詳了一下，發現這個 PR 還是 open 狀態，而且 Brendan Eich...</b:summary>
				<b:mainContent><p>今天一早起來就看到有人說 TC39 要準備建議 JavaScript 程式碼應該要加分號：</p>
<blockquote class="twitter-tweet" data-lang="zh-tw"><p lang="en" dir="ltr">TC39 is recommending that JS programmers use semicolons at the end of statements in code, rather than relying on ASI.<a href="https://t.co/9FY4i29iqs">https://t.co/9FY4i29iqs</a></p>-- Daniel Ehrenberg (@littledan) <a href="https://twitter.com/littledan/status/951523844262637568?ref_src=twsrc%5Etfw">2018年1月11日</a></blockquote>
<p>然後下面就一大串了，本來想說 <a href="https://standardjs.com/">standardjs</a> 要哭哭了，難道 <a href="https://www.npmjs.com/package/semistandard">semistandard</a> 要扶正了嗎？不過我仔細端詳了一下，發現這個 <a href="https://github.com/tc39/ecma262/pull/1062">PR</a> 還是 open 狀態，而且 Brendan Eich 甚至表態反對：</p>
<blockquote class="twitter-tweet" data-lang="zh-tw"><p lang="en" dir="ltr">I dissent.</p>-- BrendanEich (@BrendanEich) <a href="https://twitter.com/BrendanEich/status/951554266535141377?ref_src=twsrc%5Etfw">2018年1月11日</a></blockquote>
<script async="async" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>原因之一是已經有很多 standardjs 的 code 其實運作的很好，不過另外一個原因我覺得更有力，就是 TC39 的文件，做為 spec 似乎不該提出<strong>建議</strong>，當然提出這個 PR 的 Daniel Ehrenberg 其實也不是單純因為支持加分號才提的，他其實是 <a href="https://github.com/tc39/proposal-class-fields">Class field declarations</a> 的主要貢獻者，這是什麼呢？就是：</p>
<pre><code class="language-javascript">class Counter extends HTMLElement {
  x = 0;

  clicked() {
    this.x++;
    window.requestAnimationFrame(this.render.bind(this));
  }
}
</code></pre>
<p>這種在 class method 外面定義 class 屬性和預設值的語法（另外還有 private property），而這種很像是 expression 的語句，一定要 semicolon，不然會有他稱為 AST hazard 的情形，也就是很難評斷開發者實際上意圖的情形發生，也就無法用 ASI 自動補分號，對此 Brendan Eich 有個建議是在 class field 裡面關掉 ASI 機制，也就是這些 property 定義一定要加分號做結。</p>
<p>目前看起來，Brendan Eich 提的那點，TC39 不該做語法的建議實在很強而有力，應該也反駁不了，所以結果應該就是沒有收 PR，或是改成更中性的文字，不是建議的文字，不過想來想去還是沒有比較適合的，畢竟在 spec 文件裡面還提建議、警告開發者用的語法就很怪。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
