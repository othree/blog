<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>i</b:listType>
			<b:listData listID="index"/>
		</b:entriesMeta>

		<b:entry entryID="000935" baseName="eslint-plugin-pep8-blank-lines">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-09-08</b:date>
				<b:time>10:24:24</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>eslint-plugin-pep8-blank-lines</b:title>
			<b:content>
				<b:summary> 我的第二個 ESLint plugin 終於進 beta 了，這是我自己期望很久的檢查規範，上一次介紹 ESLint plugin 的時候就有說到接下來想處理空行，其實 ESLint 內建的 rule 已經有蠻多是用來檢查空行的了，不過沒有一個能符合我想要的規範，我想要的規範其實很簡單，就是希望能在大一點的物件中間能多一點空行，比較有段落的感覺，這樣閱讀起來感覺也比較好（如上圖），剛好我這兩年寫了一點 Python，有用 Flake8 做語法檢查，其中的 PEP8 coding style 中關於空行的規範，就符合我想要的樣子，而且很簡單，這個規範是在大部分地方都允許最多一行空行，但是最上層（top level）的 function, class 前後要兩行空行。 於是這個 ESLint plugin 的主要目標，就是把 PEP8 這部分的規範搬過來，一開始想的實做方式有兩個，其一是參考 padding-line-between-statements 的作法，比較兩個相鄰 token/node 間的 line number，另一個則是用 sourceCode 來一行一行看，不過同時也要知道該行的 context...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/43805736994/" title="eslint-plugin-pep8-blank-lines by othree, on Flickr"><img src="https://farm2.staticflickr.com/1855/43805736994_ed80198c0b_b.jpg" width="1024" height="768" alt="eslint-plugin-pep8-blank-lines, " srcset="https://farm2.staticflickr.com/1855/43805736994_ed80198c0b_b.jpg 1024w, https://farm2.staticflickr.com/1855/43805736994_84b2fc4977_h.jpg 1600w" /></a></p>
<p>我的第二個 ESLint plugin 終於進 beta 了，這是我自己期望很久的檢查規範，上一次介紹 ESLint plugin 的時候就有說到接下來想處理空行，其實 ESLint 內建的 rule 已經有蠻多是用來檢查空行的了，不過沒有一個能符合我想要的規範，我想要的規範其實很簡單，就是希望能在大一點的物件中間能多一點空行，比較有段落的感覺，這樣閱讀起來感覺也比較好（如上圖），剛好我這兩年寫了一點 Python，有用 Flake8 做語法檢查，其中的 <a href="https://www.python.org/dev/peps/pep-0008/#blank-lines">PEP8 coding style 中關於空行</a>的規範，就符合我想要的樣子，而且很簡單，這個規範是在大部分地方都允許最多一行空行，但是最上層（top level）的 function, class 前後要兩行空行。</p>
<p>於是這個 ESLint plugin 的主要目標，就是把 PEP8 這部分的規範搬過來，一開始想的實做方式有兩個，其一是參考 <a href="https://github.com/eslint/eslint/blob/master/lib/rules/padding-line-between-statements.js">padding-line-between-statements</a> 的作法，比較兩個相鄰 token/node 間的 line number，另一個則是用 <a href="https://eslint.org/docs/developer-guide/working-with-rules#contextgetsourcecode">sourceCode</a> 來一行一行看，不過同時也要知道該行的 context 是什麼才能判斷，所以也是跑不掉要進去看 AST，加上我想要玩玩看 JavaScript 的 AST，所以最終我是選擇第一種作法，不過不是用 ESLint 內建的 walker，而是在 <code>Program:exit</code> 的時候才用自己寫的 walker 進去看 AST；而經過一輪重構後，現在的架構其實是靈活度很高的，我實際上做出了一個比 padding-line-between-statements 還要更多功能的<a href="https://github.com/othree/eslint-plugin-pep8-blank-lines/blob/master/lib/guides/pep8.js">規範定義格式</a>，然後根據這個格式寫出我想要的空行規範，只是目前還沒開介面出來給使用者輸入自訂的空行規範就是了；其實我自己覺得這個 plugin 實做的理想型式應該還是要用實做方案二，並搭配使用 ESLint 的 AST walker，實際上  padding-line-between-statements 也就是這樣做，會這樣想最主要的原因是現在的實做只看 AST，但是 AST 其實不能 100% 表達原來的程式碼，這也是這次開發經驗中我最大的體悟，所以其實一些奇怪地方的空行就會很難抓到，例如 <code>await 1</code> 這兩個 token 中間如果有空行就會跳過，不過會在這種地方放空行的情形應該都是蠻少見的，所以目前也沒打算繼續改下去，短期內都會以處理 bug 為主，過陣子應該會試著加上 fix 的功能，總之歡迎測試並回報問題，雖然有寫測試，不過還沒什麼實際跑在真實的程式碼上，目前唯一的就是它自己的 code base 本身是有用吧，另外就是使用時如果是搭配其它 style 可能會需要把其它 style 的空行規則關掉，例如搭配 <a href="https://standardjs.com/">standardjs</a> 時的 <code>.eslintrc</code> 範例：</p>
<pre><code class="language-json">{
  &quot;extends&quot;: &quot;standard&quot;,
 
  &quot;plugins&quot;: [
    &quot;pep8-blank-lines&quot;,
    &quot;no-parameter-e&quot;
  ],
 
  &quot;rules&quot;: {
    &quot;semi&quot;: [2, &quot;always&quot;],
    &quot;no-extra-semi&quot;: 2,
    &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always-multiline&quot;],
    &quot;no-multiple-empty-lines&quot;: 0,
    &quot;pep8-blank-lines/pep8-blank-lines&quot;: 2,
    &quot;no-parameter-e/no-parameter-e&quot;: 2
  }
}
</code></pre>
<p>這組其實也是我目前在用的設定啦～</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000934" baseName="tern-022-released">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-09-02</b:date>
				<b:time>17:41:32</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Tern 0.22 released</b:title>
			<b:content>
				<b:summary>First Tern release in a year and a half today https://t.co/1Ws7zYEJSd . All thanks to @othree picking up maintenance!-- Marijn Haverbeke (@MarijnJH) 2018年8月28日 大約七月初的時候，我開始接手幫忙維護 Tern，Tern 是一個獨立的 JavaScript inference engine，用於協助撰寫 JavaScript 程式碼，就和之前介紹過的 Microsoft 的 LSP 後面的 Language Server 一樣，都是獨立於編輯器/IDE之外，不過 TernJS 是...</b:summary>
				<b:mainContent><blockquote class="twitter-tweet" data-lang="zh-tw"><p lang="en" dir="ltr">First Tern release in a year and a half today <a href="https://t.co/1Ws7zYEJSd">https://t.co/1Ws7zYEJSd</a> . All thanks to <a href="https://twitter.com/othree?ref_src=twsrc%5Etfw">@othree</a> picking up maintenance!</p>--	 Marijn Haverbeke (@MarijnJH) <a href="https://twitter.com/MarijnJH/status/1034328203026984961?ref_src=twsrc%5Etfw">2018年8月28日</a></blockquote>
<script async="async" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>大約七月初的時候，我開始接手幫忙維護 <a href="http://ternjs.net/">Tern</a>，Tern 是一個獨立的 JavaScript inference engine，用於協助撰寫 JavaScript 程式碼，就和之前介紹過的 Microsoft 的 LSP 後面的 Language Server 一樣，都是獨立於編輯器/IDE之外，不過 TernJS 是 2013 年就有開始發展的，所以是走自己的溝通介面；其實我幾年前也有幫忙貢獻過 TernJS，以前弄過我還有印象的有 Promise 支援、fetch 的定義、CofeeScript plugin。</p>
<p>後來作者 <a href="https://github.com/marijnh">Marijn</a>暫停維護 Tern 跑去弄其他東西像是 <a href="https://github.com/acornjs/acorn">Acorn</a>、<a href="https://codemirror.net/">CodeMirror</a> 還有 ProseMirror 等（這位很厲害，改天再來介紹），並公開找人接手，在一些文字內有找到他的說法是說現在這個架構有些問題處理不了，很難再發展下去了，總之所以就停了一年多沒更新了，我也是斷斷續續注意到這個狀況，不過在研究 LSP 的時候發現其實還蠻多東西是依賴 TernJS 的，讓他這樣荒廢下去好像有點可惜，認真考慮了一兩週後決定接手維護工作，考慮的點主要在於不知道能不能順利接手處理問題，因為 TernJS 的 code base 實在不容易理解，尤其是我沒有相關的 compiler、工具的訓練和開發經驗，以前那些貢獻其實都是花很大心力下去才弄出來的，幾乎是處於那種「程式碼會動了，但是我不知道為什麼」的狀態，不過這兩年相關的知識補了不少，還玩了好一陣子的 JavaScript AST，有覺得比較看的懂 TernJS 的程式碼了，就心一橫報名說要幫忙維護了，Marijn 看到我過去有發過一些 PR 後，很迅速的就開協作者權限給我了。</p>
<p>正式開始接手後，我就開始把要做的事情整理出來，我的目標是在保持現有架構之下，盡可能的繼續支援新語法，直到真的這個架構撐不住為止，所以一開始就是把一些落後的語法支援和定義補上，這次發佈的 <a href="http://ternjs.net/#releases">0.22 版</a>就是包括 0.21 之後的一些小 bugfix，還有我加入之後開始弄的 async/await、async iteration(包括 <code>for await of</code>) 以及 <code>**</code> 支援，下一版我會開始一些內部的修改、還有看看 bug，不過 Emacs 相關的我現在是真的無法處理。</p>
<p>最後一段來說說目前感想吧，Tern 真是我目前為止看過最難理解的 code 了，不知道是不是會寫 compiler 的人腦袋都會轉換到常人無法理解的形狀，我目前為止看的第二辛苦的 code base 是 Kibana 的，不過 Kibana 單純只是東西很多，找入口找很久，Tern 難的點在於它用了很多 side effect 來做事，而且 code 內沒什麼文件說明，所以像下面這行我就花了很多時間才看懂實際上做什麼事：</p>
<pre><code class="language-js">infer(node.right, scope, new HasMethodCall(&quot;:Symbol.iterator&quot;, [], null,
                                           new HasMethodCall(&quot;next&quot;, [], null,
                                                             new GetProp(&quot;value&quot;, target))))
</code></pre>
<p>這行程式碼是先拿 <code>node.right</code> 的 <code>:Symbol.iterator</code> method 的執行結果，再看它的 <code>next</code> method 的執行結果，然後取最後這個結果的 <code>value</code> property 的資訊（可能的 type 之類的）塞給 target 物件，然後這行下面你又看不到 target 做何用，因為 target 物件是在上面已經有和其它會回傳的物件有建立關聯的；除此之外，這裡有個 <code>new GetProp</code>，其它地方還有個 <code>AVal.getProp</code> 又是不同功能，一開始看的真的是黑人問號...</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000933" baseName="web-fe-news-service-ofrontend">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-08-22</b:date>
				<b:time>23:42:43</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Web 前端文章廣播服務 ofrontend</b:title>
			<b:content>
				<b:summary> 前陣子弄了一個 web 前端文章的廣播服務，現在沒有正式的服務名稱，不過 code base 和一些帳號都叫 ofrontend，所以就先這樣稱呼它吧，現在這服務有兩個末端： Twitter Telegram Channel 會轉發的文章主要就是我看到和前端相關的為主，也會有少量其他的技術文章，大約 80% 英文、20 % 中文，不過不一定是我讀過覺得要推薦的，也是有過一些剛看標題覺得好像不錯，結果找到時間看完覺得沒什麼的文章，不介意的話可以 follow 一下。 目前資訊來源包括了： Twitter 上的 follows 和 Facebook 上自己的 Timeline GitHub 上的 follows、watching（沒有 public 的頁面）我有 watch 一些標準文件的 repository，像是 TC39、CSS-WG 等，現在蠻多資訊可以在 GitHub issue 內看到了，以前都要訂閱 mailing-list...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/30332209388/" title="frontend-news by othree, on Flickr"><img src="https://farm2.staticflickr.com/1897/30332209388_f956381a2d_b.jpg" width="512" height="512" alt="frontend-news" srcset="https://farm2.staticflickr.com/1897/30332209388_f956381a2d_b.jpg 1024w" /></a></p>
<p>前陣子弄了一個 web 前端文章的廣播服務，現在沒有正式的服務名稱，不過 code base 和一些帳號都叫 <a href="https://github.com/othree/ofrontend">ofrontend</a>，所以就先這樣稱呼它吧，現在這服務有兩個末端：</p>
<ul>
<li><a href="https://twitter.com/ofrontend">Twitter</a></li>
<li><a href="https://t.me/ofrontend">Telegram Channel</a></li>
</ul>
<p>會轉發的文章主要就是我看到和前端相關的為主，也會有少量其他的技術文章，大約 80% 英文、20 % 中文，不過不一定是我讀過覺得要推薦的，也是有過一些剛看標題覺得好像不錯，結果找到時間看完覺得沒什麼的文章，不介意的話可以 follow 一下。</p>
<p>目前資訊來源包括了：</p>
<ul>
<li>Twitter 上的 <a href="https://twitter.com/following">follows</a> 和 Facebook 上自己的 Timeline</li>
<li>GitHub 上的 <a href="https://github.com/othree?tab=following">follows</a>、watching（沒有 public 的頁面）我有 watch 一些標準文件的 repository，像是 TC39、CSS-WG 等，現在蠻多資訊可以在 GitHub issue 內看到了，以前都要訂閱 mailing-list</li>
<li>跟的 <a href="https://blog.othree.net/blogroll/">Feed</a>，有記得才會去看，線上這份 Feed 清單沒有隨時更新</li>
<li>Facebook 上的社團：
<ul>
<li><a href="https://www.facebook.com/groups/enjoyfonts/">字嗨</a></li>
<li><a href="https://www.facebook.com/groups/javascript.tw/">JavaScript.tw</a></li>
<li><a href="https://www.facebook.com/groups/vim.tw/">Vim 正體中文社群</a></li>
<li><a href="https://www.facebook.com/groups/augularjs.tw/">Angular Taiwan</a></li>
<li><a href="https://www.facebook.com/groups/1249720198386038/">Fire-and-Forget 前端轉貼總部</a></li>
<li><a href="https://www.facebook.com/groups/142197385837507/">Ruby Taiwan</a></li>
<li><a href="https://www.facebook.com/groups/521085554595481/">Front-End Developers Taiwan</a></li>
<li><a href="https://www.facebook.com/groups/168537393167684/">Perl 台灣</a></li>
<li><a href="https://www.facebook.com/groups/830853873715381/">Markdown 台灣</a></li>
<li><a href="https://www.facebook.com/groups/262800543746083/">node.js台灣</a></li>
<li><a href="https://www.facebook.com/groups/1439747729634154/">ReactJS.tw</a></li>
<li>...等</li>
</ul>
</li>
<li>訂閱的電子報：
<ul>
<li><a href="https://weekly.codetengu.com/">碼天狗</a></li>
<li><a href="https://weekly.techbridge.cc/">TechBridge 技術週刊</a></li>
<li><a href="https://javascriptweekly.com/">JavaScript Weekly</a></li>
<li><a href="https://nodeweekly.com/">Node Weekly</a></li>
<li><a href="https://frontendfoc.us/">Frontend Focus</a></li>
<li><a href="https://mobiledevweekly.com/">Mobile Dev Weekly</a></li>
<li><a href="https://webopsweekly.com/">WebOps Weekly</a></li>
<li><a href="https://www.pycoders.com/">Pycoder's Weekly</a></li>
<li><a href="https://rubyweekly.com/">Ruby Weekly</a></li>
<li><a href="https://golangweekly.com/">Golang Weekly</a></li>
<li><a href="https://wasmweekly.news/">WebAssembly Weekly</a></li>
<li>...等</li>
</ul>
</li>
<li>其它各種一時想不起來或是非預期的來源</li>
</ul>
<p>會做這個服務有幾個原因，一個是我其實本來就有在轉發前端相關的文章連結，不過大多丟在一些非公開的地方，並且這些文章連結都沒好好整理，一直都有想找個書籤服務弄起來，然後這陣子看到<a href="https://wanqu.co/">灣區日報</a>和<a href="https://t.me/JustShareChannel">吹水 Just Share</a> 覺得也可以來做類似的傳播管道，研究和思考了好一陣子，最後決定花錢訂閱了個 <a href="https://pinboard.in/">Pinboard</a> 服務來收集和管理連結，Pinboard 雖然介面沒找什麼設計師，看起來很陽春，不過其實他還蠻靈活的，API 很簡單可以用，不用 oauth，只要帶 token 發請求就可以，和 Telegram Bot 蠻像的，所以其實也不少工具可以用，Android、iOS、Firefox 都有，隨時看到相關的文章都可以很快的把連結丟進 Pinboard。</p>
<p>連結進 Pinboard 之後，就有個轉發的工具來把這連結丟去 Twitter 和 Telegram，轉發的程式也放在 GitHub 上，叫 <a href="https://github.com/othree/pinboardto">pinboardto</a>，Python 寫的，本來有想趁機玩玩看 Rust，不過研究一下覺得還是先用 Python 把基本款弄出來，裡面東西很簡單沒什麼技術難題，並且不依靠外部儲存（資料庫、檔案），同步的機制是靠系統時間和 cronjob，所以不知什麼原因錯過就錯過了，不過因為這服務也沒有這麼要求可靠性，所以還好。</p>
<p>Facebook 的部分，本來有想接到 Fire-and-Forget 前端轉貼總部 去的，可是 FB 那邊弄不到永久有效的 token 就弄下去。</p>
<p>最後成本部分，這個服務其實對我來說蠻低成本的，主要固定支出就只有 Pinboard 的年費，不過本來就要好好收集算是本來就要花，轉發服務掛在現有的主機上，最後就是 iPad 上有花錢買一個 Pinboard 的 app，不過其實也還沒有滿意就是，不知道為什麼抓 Twitter 的網頁 title 都會抓錯。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000932" baseName="language-server-protocol">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-07-28</b:date>
				<b:time>23:59:05</b:time>
			</b:datetime>
			<b:category>vim</b:category>
			<b:title>Language Server Protocol</b:title>
			<b:content>
				<b:summary> 最近才注意到 Language Server Protocol （官方中文介紹）這東西，微軟為了 Visual Studio Code 所定的一個協定，專門用來輔助程式開發用的，像是 VSCode 的 IntelliSense 提供的自動補完就可以基於這個協定支援更多語言，這協定其實在 2016 就發表了，感覺我 lag 很久，不過其實我也好奇 VSCode 怎麼處理這問題一陣子了，最近在 TernJS 的 issue 裡面看到 LSP 這個詞，好奇之下才去看到底是什麼東西。 LSP 的設計理念是開發 Editor 的不可能每種程式語言都花時間心力去把它們的編輯輔助功能做起來（還不一定做的好），所以不如就把這塊拆出來，讓分析程式碼、提供輔助功能的部分（Language Server）拆出去給各自領域的人開發，然後透過一個公定的介面來做溝通，這個介面就是 Language Server Protocol 了。 LSP 是架構在 JSON-RPC 這個 protocol...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/43311328182/" title="Language Server Protocol by othree, on Flickr"><img src="https://farm1.staticflickr.com/838/43311328182_e7663f40dc_b.jpg" width="1024" height="640" alt="Language Server Protocol, " srcset="https://farm1.staticflickr.com/838/43311328182_e7663f40dc_b.jpg 1024w, https://farm1.staticflickr.com/838/43311328182_b3478fb066_h.jpg 1600w" /></a></p>
<p>最近才注意到 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> （<a href="https://docs.microsoft.com/zh-tw/visualstudio/extensibility/language-server-protocol">官方中文介紹</a>）這東西，微軟為了 Visual Studio Code 所定的一個協定，專門用來輔助程式開發用的，像是 VSCode 的 IntelliSense 提供的自動補完就可以基於這個協定支援更多語言，這協定其實在 2016 就發表了，感覺我 lag 很久，不過其實我也好奇 VSCode 怎麼處理這問題一陣子了，最近在 TernJS 的 issue 裡面看到 LSP 這個詞，好奇之下才去看到底是什麼東西。</p>
<p>LSP 的設計理念是開發 Editor 的不可能每種程式語言都花時間心力去把它們的編輯輔助功能做起來（還不一定做的好），所以不如就把這塊拆出來，讓分析程式碼、提供輔助功能的部分（Language Server）拆出去給各自領域的人開發，然後透過一個公定的介面來做溝通，這個介面就是 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> 了。</p>
<p>LSP 是架構在 JSON-RPC 這個 protocol 上，只要你的 Editor 可以透過 JSON-RPC 發送請求並接收結果，就可以利用 LSP 來提供功能，現在支援 LSP 的編輯器也不少，不是只有 VSCode 有支援，其它還有 Eclipse、Vim、NeoVim、Sublime Text 3 都已經有方案可以支援了，在社群維護的網站  <a href="http://langserver.org/">langserver.org</a> 上有一份<a href="http://langserver.org/#implementations-server#implementations-client">清單</a>介紹各個 client 的支援狀況。</p>
<p>送到 Language Server 的指令，目前 Protocol 可以提供以下功能：</p>
<ul>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_completion">Completion</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_hover">Hover Information</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_signatureHelp">Signature Help</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_definition">Goto Definition</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_typeDefinition">Goto Type Definition</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_implementation">Goto Implementation</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_references">Find References</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction">Action</a>, fix code</li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens">Code Lens</a>, information for specific position</li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting">Formatting</a></li>
<li><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics">Diagnostic</a>, 像是 code lint</li>
</ul>
<p>其它還有一些是檔案、工作區相關的操作指令，另外由於現在 Language Server 實做和 LSP 是分開的，也沒有限制一定要所有功能都有支援，所以有些 Language Server 可能是沒有支援特定功能的，目前可以找到兩份 Language Server 的列表，一份是 LSP <a href="https://microsoft.github.io/language-server-protocol/implementors/servers/">官網的</a>，另一份則是 <a href="http://langserver.org#implementations-server">langserver.org</a> 上的，社群維護的版本才有標示不同的 Language Server 對應支援的功能，不過說是社群維護，其實 langserver.org 是另外一間公司 <a href="https://about.sourcegraph.com/">Sourcegraph</a> 在維護的，該公司做的東西和 LSP 相關性看起來還蠻大的，也提供了很多 Language Server。</p>
<p>然後我就很感興趣，VSCode 現在內建的 JavaScript 用的 Language Server 是哪一套呢？畢竟仔細一看，兩個列表裡面，都沒有列出內建由微軟維護的 JavaScript 的 Language Server，只有 Sourcegraph 的版本，不止 JavaScript 沒有，TypeScript 也沒，只有 <a href="http://typefox.io">TypeFox</a> 的版本（TypeFox 也是做程式碼相關工具的公司，我有找到一些研討會演講介紹 LSP 的講者就是這間公司的人）。總之兩個語言都沒列這真是太不尋常了，實在引起了我的好奇心，後來到處尋找總算在 <a href="https://code.visualstudio.com/docs/languages/javascript">JavaScript in VS Code</a> 這頁找到蛛絲馬跡，這頁內文第二句話就有個連結連去 <a href="https://github.com/Microsoft/TypeScript/wiki/JavaScript-Language-Service-in-Visual-Studio">JavaScript Language Service</a> 在 GitHub 的介紹，位置是 TypeScript 專案下的 Wiki 頁面，也有找到 TypeScript 專案內的相關<a href="https://github.com/Microsoft/TypeScript/tree/master/src/services">程式碼</a>，實際上 VSCode 對於 JavaScript 和 TypeScript 的編輯輔助功能都是依靠這個 TypeScript Language Service 提供的，或是也可以叫它 <a href="https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29">tsserver</a>，TypeScript 的大架構可以參考 <a href="https://github.com/Microsoft/TypeScript/wiki/Architectural-Overview">Architectural Overview</a> 這篇文章；由於 tsserver 比較早推出，所以用的不是 LSP 用的 JSON-RPC，而是 STDIO 然後傳輸 JSON 加上 header，指令也有些落差，不過其實整體而言沒差距很大，因為 VSCode 那些輔助功能幾乎都是從 Visual Studio 來的，TypeScript 的支援也早就都透過 tsserver 來實現了，事實上，Sourcegraph 的 <a href="https://github.com/sourcegraph/javascript-typescript-langserver">TypeScript Language Service</a> 就是個 tsserver 的 proxy，底層還是 tsserver，不過實際上要用的話應該是 <a href="https://github.com/theia-ide/typescript-language-server">TypeFox 的</a>比較好；然後當然也有人提出來說 TypeScript 是不是應該直接提供 LSP 版本的開發工具支援，在 GitHub 上的 <a href="https://github.com/Microsoft/TypeScript/issues/11274">Issue 11274</a>，不過目前看來是沒打算樣子，這點我也是蠻意外的，畢竟 LSP 和 TypeScript 同公司的，沒打算支援自家公司定的標準，也是十足的霸氣，也看的出來各開源專案自治度其實蠻高的。</p>
<p>補充：另外有個 debugger 用的 <a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Adapter Protocol</a></p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000931" baseName="naming-1">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-07-21</b:date>
				<b:time>23:12:15</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>命名記錄 1</b:title>
			<b:content>
				<b:summary> 記錄一下這兩年自己覺得還不錯的命名，本來是想累積更多再貼的。 Herculus 海克力士，用在測試服務名稱上，是希臘神話中的大力士，曾經完成十二偉業，這兩年還有部電影，取名源由其實是 Fate/stay night 中，他做為 Berserk 的 Servant 所持有的寶具，稱為 十二の試練，試練就聯想到 test ～ Erebor 用在資料庫相關的服務，哈比人歷險記的孤山的精靈語，因為孤山裡面有很多矮人的寶物，資料庫內的資料某種層面來說也算是個寶物。 Olympus 應該不用介紹來源了，用在 client 端自己寫的 API helper，取這個名字的原因是覺的客戶端跟 server 端要資料就如同在跟眾神請求一樣。...</b:summary>
				<b:mainContent><p><a title="By Thorin Oakenshield II [CC BY-SA 4.0 
(https://creativecommons.org/licenses/by-sa/4.0
)], from Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:%D0%9A%D0%B0%D1%80%D1%82%D0%B0_%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D0%BA%D0%BE%D0%B9_%D0%93%D0%BE%D1%80%D1%8B_.jpg"><img width="512" alt="Карта Одинокой Горы " src="https://upload.wikimedia.org/wikipedia/commons/b/b3/%D0%9A%D0%B0%D1%80%D1%82%D0%B0_%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D0%BA%D0%BE%D0%B9_%D0%93%D0%BE%D1%80%D1%8B_.jpg" /></a></p>
<p>記錄一下這兩年自己覺得還不錯的命名，本來是想累積更多再貼的。</p>
<h4>Herculus</h4>
<p><a href="https://zh.wikipedia.org/zh-tw/%E8%B5%AB%E6%8B%89%E5%85%8B%E5%8B%92%E6%96%AF">海克力士</a>，用在測試服務名稱上，是希臘神話中的大力士，曾經完成十二偉業，這兩年還有部電影，取名源由其實是 Fate/stay night 中，他做為 Berserk 的 Servant 所持有的寶具，稱為 <strong>十二の試練</strong>，試練就聯想到 test ～</p>
<h4>Erebor</h4>
<p>用在資料庫相關的服務，哈比人歷險記的<a href="https://en.wikipedia.org/wiki/Lonely_Mountain">孤山</a>的精靈語，因為孤山裡面有很多矮人的寶物，資料庫內的資料某種層面來說也算是個寶物。</p>
<h4>Olympus</h4>
<p>應該不用介紹來源了，用在 client 端自己寫的 API helper，取這個名字的原因是覺的客戶端跟 server 端要資料就如同在跟眾神請求一樣。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000930" baseName="quotation">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2018-07-17</b:date>
				<b:time>00:39:20</b:time>
			</b:datetime>
			<b:category>others</b:category>
			<b:title>引號</b:title>
			<b:content>
				<b:summary> 記錄一下搞 i18n 的一些發現，首先是引號，一般寫程式用的單雙引號 '&quot; 是沒分開關的，不過這和寫作的不一樣，當初 ASCII Code 編定時也是因為資源有限所以才不分開引號還是關引號，不過現在其實這些標點符號都已經有區分的版本了，在 Mac 上也都有快速鍵輸入，像是： &quot; : opt + [ &quot; : opt + shift + [ ' : opt + ] ' : opt + shift + ] 一般文字我還蠻喜歡把普通的單引號雙引號都轉成這種，有個意外的好處就是放在 JSON 裡的字串內時，不需要用 \ 跳脫，肉眼看起來和諧許多。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/28562524947/" title="Qutation Marks by othree, on Flickr"><img src="https://farm2.staticflickr.com/1786/28562524947_6b41f2c99a_b.jpg" width="233" height="454" alt="Qutation Marks, " srcset="https://farm2.staticflickr.com/1786/28562524947_6b41f2c99a_b.jpg 466w" /></a></p>
<p>記錄一下搞 i18n 的一些發現，首先是引號，一般寫程式用的單雙引號 <code>'&quot;</code> 是沒分開關的，不過這和寫作的不一樣，當初 ASCII Code 編定時也是因為資源有限所以才不分開引號還是關引號，不過現在其實這些標點符號都已經有區分的版本了，在 Mac 上也都有快速鍵輸入，像是：</p>
<ul>
<li><code>&quot;</code> :  <code>opt + [</code></li>
<li><code>&quot;</code> :  <code>opt + shift + [</code></li>
<li><code>'</code> :  <code>opt + ]</code></li>
<li><code>'</code> :  <code>opt + shift + ]</code></li>
</ul>
<p>一般文字我還蠻喜歡把普通的單引號雙引號都轉成這種，有個意外的好處就是放在 JSON 裡的字串內時，不需要用 <code>\</code> 跳脫，肉眼看起來和諧許多。</p>
<p>然後當初實做 Markdown 的 John Gruber 有個工具叫 <a href="https://daringfireball.net/projects/smartypants/">SmartyPants</a> 可以來處理單雙引號的轉換，這工具當年常和 Markdown 一起合作，我則是有把它 port 到 <a href="https://www.npmjs.com/package/smartypants">JavaScript</a>，然後其實有些語言的引號不是這種點點得，像是大家都知道的中日文的 <code>「」</code> ，我要提的則是俄文用的是箭頭引號 <code>«»</code> 叫 Guillemet，長的和<a href="https://zh.wikipedia.org/wiki/%E4%B9%A6%E5%90%8D%E5%8F%B7">書名號</a>很像，不過大小就有差，當然 Guillemet 也有單線條的版本 <code>‹›</code>，輸入方法如下：</p>
<ul>
<li><code>«</code> :  <code>opt + \</code></li>
<li><code>»</code> :  <code>opt + shift + \</code></li>
<li><code>‹</code> :  <code>opt + shift + 3</code></li>
<li><code>›</code> :  <code>opt + shift + 4</code></li>
</ul>
<p>德文又比較特別，左邊的引號是放在底部的 <code>„</code>，輸入方法為：</p>
<ul>
<li><code>„</code> : <code>opt + shift + w</code></li>
</ul>
<p>當然這些不同語言的不同型式好像現在也沒有講究一定要用，我隨便找一些該語言的新聞網站也還是很多用普通的雙引號，而且實際上這些引號的組合很多，<a href="https://en.wikipedia.org/wiki/Quotation_mark">wikipedia</a> 上有人整理好。</p>
<p>另外想特別提一下西班牙文，它的問句和驚嘆句，除了在句尾加問號和驚嘆號之外，還可以在句首加上反過來的問號和驚嘆號，一樣，現在似乎也沒一定要這樣寫了，輸入方法為：</p>
<ul>
<li><code>¿</code> : <code>opt + shift + /</code></li>
<li><code>¡</code> : <code>opt + 1</code></li>
</ul>
<p>最後補篇少數派的文章 <a href="https://sspai.com/post/45516">别再用「六个点」当省略号了，这些标点都有更规范的输入方式</a>。</p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
