<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>i</b:listType>
			<b:listData listID="index"/>
		</b:entriesMeta>

		<b:entry entryID="001007" baseName="json-type-definition">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2024-04-17</b:date>
				<b:time>22:47:21</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>JSON Type Definition</b:title>
			<b:content>
				<b:summary>之前工作上需要，想要一個簡單的可以檢查 JSON 資料結構的工具，研究了一陣子，發現到了 JSON Type Definition（簡稱 JSON Typedef 或是 JTD） 這個 RFC 標準，相較於發展已經很久的 JSON Schema，JSON Typedef 的語法簡潔不少： { &quot;properties&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;createdAt&quot;: { &quot;type&quot;: &quot;timestamp&quot; }, &quot;karma&quot;: { &quot;type&quot;: &quot;int32&quot; }, &quot;isAdmin&quot;: { &quot;type&quot;: &quot;boolean&quot; }...</b:summary>
				<b:mainContent><p>之前工作上需要，想要一個簡單的可以檢查 JSON 資料結構的工具，研究了一陣子，發現到了 <a href="https://jsontypedef.com/">JSON Type Definition</a>（簡稱 JSON Typedef 或是 JTD） 這個 <a href="https://datatracker.ietf.org/doc/html/rfc8927">RFC 標準</a>，相較於發展已經很久的 <a href="https://json-schema.org/">JSON Schema</a>，JSON Typedef 的語法簡潔不少：</p>
<pre><code class="language-json">{
	&quot;properties&quot;: {
		&quot;id&quot;: { &quot;type&quot;: &quot;string&quot; },
		&quot;createdAt&quot;: { &quot;type&quot;: &quot;timestamp&quot; },
		&quot;karma&quot;: { &quot;type&quot;: &quot;int32&quot; },
		&quot;isAdmin&quot;: { &quot;type&quot;: &quot;boolean&quot; }
	 }
}
</code></pre>
</b:mainContent>
				<b:extendContent><p>光是看不到 <code>$</code> 那種 meta 屬性的前綴就覺得簡潔不少，然後官網上也提供了幾個常見程式語言的實作，接著我在看 RFC 文件的時候，發現到文件的分類是 <strong>Independent Submission</strong>，這就讓我好奇了起來，於是就花了不少時間了解前因後果。</p>
<p>JSON Typedef 的作者是 <a href="https://github.com/ucarion">Ulysse Carion</a>，當時在 segment.com 工作，不過在講到他之前，要先來提另外一位在 AWS 工作的 Tim Bray，他常常要處理 AWS 服務間的事件，這些事件都是 JSON 資料，然後有很多種事件，整體而言是 discriminated union(tagged union)，中文有翻譯為可辨識聯合或是標簽聯合，那這是什麼東西呢？簡單舉例，在 DOM 裡面的事件，滑鼠 click 事件會有點擊的座標，鍵盤 keydown 事件則會有按下的按鍵，這兩個事件都有一個 <code>type</code> 屬性，簡單的 TypeScript 定義長這樣：</p>
<pre><code class="language-typescript">type ClickEvent {
  type: 'click';
  offsetX: number;
  offsetY: number;
}

type KeydownEvent {
  type: 'keydown';
  keyCode: number;
}
</code></pre>
<p>然後 <code>Event</code> 則是兩種的聯集：</p>
<pre><code class="language-typescript">type Event = ClickEvent | KeydownEvent;
</code></pre>
<p>這時，如果有支援的工具就可以透過判斷 <code>type</code> 屬性的值來知道該物件應該是長什麼樣子，但是就是沒有，當然也不用說更進一步用 schema 驗證收到的事件資料，他也在 2018 年九月寫了一篇 <a href="https://www.tbray.org/ongoing/When/201x/2018/09/22/JSON-scheming">JSON Scheming</a> 講到這件事情，也說明了為什麼無法用 JSON Schema，除了不支援 discriminated union 這個主因之外，還有錯誤訊息不好和沒有 code generation 可用。</p>
<p>之後，Carion 在 2019 年四月，在 IETF 的 <a href="https://mailarchive.ietf.org/arch/browse/json/">json mailing list</a> 發了一封信，想要找人一起協作開發一個 JSON 的 schema 語言，他遇到的問題是他常常用 JSON-RPC，然後這些 RPC 協定的 request/response 本身也和 AWS 團隊要處理的那些 events 一樣是 discriminated union，然後一樣檯面上沒有好用的工具和語言可以用來作資料檢查，Carion 那封信件後面的回應有些人提了一些 prior arts，像是我從來沒聽過的 <a href="https://web.archive.org/web/20210616220814/http://json-content-rules.org/">JSON Content Rules</a>（網站已死），還有 JSON 的二進位版超集：<a href="https://cbor.io/">CBOR</a> 和用來描述 CBOR 資料的 <a href="https://datatracker.ietf.org/doc/html/rfc8610">CDDL</a>，CDDL 也可以用在 JSON 資料結構上，也已經是 RFC 標準了，不過 CDDL 是一個完全不同的語言，要使用它要從 parser 開始導入，會困難並且慢很多，隨便找一個 CDDL 範例：</p>
<pre><code class="language-cddl">PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * tstr =&gt; any
}
</code></pre>
<p>然後五月的時候 Carion 提交了第一版的 Internet-Draft 到 IETF 了，當時使用的名稱叫 <a href="https://mailarchive.ietf.org/arch/msg/json/pkI8w-djHBKsfPFv43g_2G3A3Mg/">JSON Schema Language</a>，不過因為會和 JSON Schema <a href="https://stackoverflow.com/questions/60959556/using-discriminator-keyword-in-json-schema">混淆</a>，所以後來就改名成 <a href="https://mailarchive.ietf.org/arch/msg/json/tnG7o3jTAcLnT9XCYTJi62rXXUo/">JSON Data Definition Format</a>（簡稱：JDDF），然後等到正式發布時則又改名為現在的名稱：JSON Type Definition，至於為何會是 Independent Submission 呢？其實是因為 IETF 的 JSON-WG 早早就已經關閉了，只是 mailing-list 還一直開著，可以讓人討論，但是已經不能透過 JSON-WG 發佈新文件了，這時不是走獨立提交，那就是要另外找一個或開一個 WG，就會有一些行政流程要跑，其實現在很多的 JSON 相關的 RFC 文件，都是有各自的 WG 來處理，像是 <a href="https://www.rfc-editor.org/rfc/rfc9535.html">JSONPath</a> 就有開一個 <a href="https://datatracker.ietf.org/wg/jsonpath/about/">jsonpath WG</a></p>
<p>最後正式版的 JSON Typedef 達成了 Carion 一開始的目標，支援 discriminated union（到這個時間點 JSON Schema 還沒法這樣簡單的支援）以及很容易就可以做出 code generation 的特性，Carion 還自己實作了數個語言的支援，例如 JavaScript 生態系就是可以生成 TypeScript type definition，例如以下的 schema：</p>
<pre><code class="language-json">{
    &quot;discriminator&quot;: &quot;eventType&quot;,
    &quot;mapping&quot;: {
        &quot;USER_CREATED&quot;: {
            &quot;properties&quot;: {
                &quot;id&quot;: { &quot;type&quot;: &quot;string&quot; }
            }
        },
        &quot;USER_PAYMENT_PLAN_CHANGED&quot;: {
            &quot;properties&quot;: {
                &quot;id&quot;: { &quot;type&quot;: &quot;string&quot; },
                &quot;plan&quot;: { &quot;enum&quot;: [&quot;FREE&quot;, &quot;PAID&quot;]}
            }
        },
        &quot;USER_DELETED&quot;: {
            &quot;properties&quot;: {
                &quot;id&quot;: { &quot;type&quot;: &quot;string&quot; },
                &quot;softDelete&quot;: { &quot;type&quot;: &quot;boolean&quot; }
            }
        }
    }
}
</code></pre>
<p>可以自動轉成：</p>
<pre><code class="language-typescript">// Code generated by jtd-codegen for TypeScript v0.2.1

export type Event = EventUserCreated | EventUserDeleted | EventUserPaymentPlanChanged;

export interface EventUserCreated {
  eventType: &quot;USER_CREATED&quot;;
  id: string;
}

export interface EventUserDeleted {
  eventType: &quot;USER_DELETED&quot;;
  id: string;
  softDelete: boolean;
}

export enum EventUserPaymentPlanChangedPlan {
  Free = &quot;FREE&quot;,
  Paid = &quot;PAID&quot;,
}

export interface EventUserPaymentPlanChanged {
  eventType: &quot;USER_PAYMENT_PLAN_CHANGED&quot;;
  id: string;
  plan: EventUserPaymentPlanChangedPlan;
}
</code></pre>
<p>然後 TypeScript 也支援這樣定義的語法，我最近特別喜歡用 <code>switch</code> 來處理這種東西，TypeScript 都會<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions">幫你判斷好變數的型別</a>：</p>
<pre><code class="language-typescript">switch (event.eventType) {
  case 'USER_CREATED':
    // event type is EventUserCreated
    break;
  case 'USER_DELETED':
    // event type is EventUserDeleted
    break;
  default:
    // blah blah
}
</code></pre>
<p>當然 JTD 也可以用來驗證資料，除了 Carion 自己實作的之外，另外還有一套 <a href="https://ajv.js.org/">ajv</a> 支援 JSON Typedef，不過如果是表單驗證，我自己是沒那麼推薦，我目前表單通常會是用 <a href="https://react-hook-form.com/">react-hook-form</a> 和 <a href="https://zod.dev/">Zod</a>，一個原因是 JTD 不太有擴充性，而且也沒有太多什麼奇妙的型別，都是很基本的型別，所以沒有 email、ip、url 那種 pattern 形式的驗證，至於我推薦表單檢查用 Zod 除了它比較容易擴充自訂的檢查之外，還有其他原因，其一是它也支援 discriminated union：</p>
<pre><code class="language-javascript">const myUnion = z.discriminatedUnion(&quot;status&quot;, [
  z.object({ status: z.literal(&quot;success&quot;), data: z.string() }),
  z.object({ status: z.literal(&quot;failed&quot;), error: z.instanceof(Error) }),
]);
</code></pre>
<p>另一個原因就是 <a href="https://github.com/sindresorhus/ow">ow</a> 的作者 @sindresorhus 也推薦用 Zod 了XD。</p>
<p>回到 JSON Typedef，其實使用起來還是有一點隱憂的，主要的隱憂就是怕之後就沒人用了，一來使用族群不大，二來是 Carion 那些套件都很久沒更新了，他本人後來也跑去創業了，大概也沒時間來故這些東西了吧，所以要不要用 JTD 也只能自己承擔後果了吧，不過都做為正式 RFC 文件發佈了，我覺得應該是不會慘到哪去啦。</p>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="001006" baseName="the-magic-of-dialog">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2024-04-03</b:date>
				<b:time>11:49:41</b:time>
			</b:datetime>
			<b:category>css-html</b:category>
			<b:title>Dialog 的魔法</b:title>
			<b:content>
				<b:summary> HTML 在 2014 的 HTML5 之後，其實就很少有什麼新的標籤，比較多是在各種細節的釐清和標準化各種未定義行為，不過在這些屈指可數的新標籤中，有一個比較廣為人知的，就是 &lt;dialog&gt;。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53626597432/" title="HTML dialog by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53626597432_f11da51222_b.jpg" width="1024" height="235" alt="HTML dialog" srcset="https://live.staticflickr.com/65535/53626597432_8d2190c44e_k.jpg 2x" /></a></p>
<p>HTML 在 2014 的 HTML5 之後，其實就很少有什麼新的標籤，比較多是在各種細節的釐清和標準化各種未定義行為，不過在這些屈指可數的新標籤中，有一個比較廣為人知的，就是 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog"><code>&lt;dialog&gt;</code></a>。</p>
</b:mainContent>
				<b:extendContent><p><code>&lt;dialog&gt;</code> 的出現和前端工程實務上的發展很有關係，我個人認為它其實就是古早時候的 <code>confirm</code> 和 <code>alert</code> 的現代版本，十多年前大部分的網路服務有類似需求還是直接用這兩個原生的互動介面為主，不過因為是原生的，對開發者來說可控性很低，加上以前的版本很容易會把瀏覽器卡死，使用體驗也不太好，現在的版本則考慮到使用者隱私也多了很多限制，加上樣式無法客製，所以在前端工程開始熱烈發展之時，很多網站也都開始自己做自己的對話框了；其中，最具代表性的或許是當年紅極一時的 Bootstrap 的 <a href="https://getbootstrap.com/docs/5.0/components/modal/">modal</a> 了吧。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53627498716/" title="Bootstrap Modal by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53627498716_a215f9150e_b.jpg" width="1024" height="686" alt="Bootstrap Modal" srcset="https://live.staticflickr.com/65535/53627498716_dc28344076_k.jpg 2x" /></a></p>
<p>這些各家自製的對話框都很不錯，設計漂亮、功能完善，不過它畢竟沒有魔法（那些無法透過網路標準辦到的東西），有幾個問題還是無法克服，首先第一個就是，它無法永遠保持在最上層；第二個就是，使用者還是有可能意外 focus 跑到 modal 對話框之外的元素上；最後一個是，<code>&lt;dialog&gt;</code> 是如何沒有外層元素，卻可以垂直水平置中且本身大小是非固定的？其實我一開始就是對最後這個問題感到疑惑，才開始認真的研究 <code>&lt;dialog&gt;</code>，結果一研究下去，發現超多的細節的。</p>
<p>在回答問題之前，先來介紹一下 <code>&lt;dialog&gt;</code> 吧，首先 <code>&lt;dialog&gt;</code> 預設樣式是 <code>display: none;</code> 隱藏起來的，不考慮直接改 CSS 的話，要讓它出現有幾種方法，首先是透過 <code>open</code> 這個專屬的新 attribute：</p>
<pre><code class="language-html">&lt;dialog open&gt;
   This is a dialog
&lt;/dialog&gt;
</code></pre>
<p>這樣就會讓 <code>&lt;dialog&gt;</code> 出現在畫面上，表現就如同一般的 <code>&lt;div&gt;</code> 標籤，第二種方法則是透過 JavaScrpt：</p>
<pre><code class="language-javascript">dialogNode.show()
</code></pre>
<p>這樣的效果和 <code>open</code> 一樣，然後除了這兩個方法之外，還有一個最特別的：</p>
<pre><code class="language-javascript">dialogeNode.showModal()
</code></pre>
<p><code>showModal</code> 會讓這個 <code>&lt;dialog&gt;</code> 出現在網頁的最上層，並且保持置中，而且同時，網頁上除了該 <code>&lt;dialog&gt;</code> 以外的地方都會無法互動。</p>
<p>在這邊，一下子三件以前辦不到的事情都出現了：</p>
<ul>
<li>保證在網頁的最上層</li>
<li>只有一層標籤就水平垂直置中</li>
<li>其他地方都無法互動</li>
</ul>
<p>那麼，這些事情是如何辦到的呢？首先就來說說第一點吧，如何能夠保證 <code>&lt;dialog&gt;</code> 一定在最上層呢？那就是一個新規範的東西了，叫做 <a href="https://developer.chrome.com/blog/what-is-the-top-layer?hl=zh-tw">top Layer</a>，標準則是放在 <a href="https://drafts.csswg.org/css-position-4/#top-layer">CSS Positioned Layout Module Level 4</a>，這東西指的現在瀏覽器在繪製文件之餘，還要建立一個獨立於文件之外的 <a href="https://web.dev/learn/css/z-index?hl=zh-tw">stacking context</a>，然後該 context 一定是在其他所有 stacking context 之上，尺寸則是和 viewport 一樣大，這個 stacking context 就是 top layer 了，開發者是無法直接控制該 context，需要透過一些特定 API 操作，才能把東西丟到 top layer 來繪製，目前有用到 top layer 的除了 <code>&lt;dialog&gt;</code> 之外，文件上是還有寫到 fullscreen API 和還在初期的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Popover_API">popover</a>，開發工具都已經有支援，下圖的開發工具的截圖中，文件的尾端就多了一個 top layer。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53626368602/" title="Top layer by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53626368602_726c893848_b.jpg" width="1024" height="689" alt="Top layer" srcset="https://live.staticflickr.com/65535/53626368602_185cc1da44_k.jpg 2x" /></a></p>
<p>根據前一點，可以知道其實 <code>&lt;dialog&gt;</code> 一樣是普通 DOM 節點，只是在用 <code>showModal()</code> 時會放在不同的 stacking context，一樣可以用 CSS 設定樣式，那麼，<code>&lt;dialog&gt;</code> 是如何只有一層標籤就置中的呢？這當中可沒有魔法，其實很簡單，也是一個很古早的水平垂直置中的方法之一：</p>
<pre><code class="language-css">dialog {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
}
</code></pre>
<p>其實就是絕對定位 + 上下左右都設為 0 + margin 設定為 auto 的方法，等等，如果垂直水平置中這麼簡單，那大家怎麼會痛苦了幾十年還一直在尋求一個物件置中的方法？其實原因就在於，這個方法有個先決條件，就是該標籤的寬高必須是要明確定義的值，而不能是 auto，詳細的計算方式規範目前在 CSS Position Level 3 裡面的第五章「<a href="https://www.w3.org/TR/css-position-3/#abspos-old">Old Absolute Positioning Layout Model</a>」，更早則是 CSS 2 就已經有了，這一個章節是在介紹如果是絕對定位的標籤，要怎樣計算它的位置、寬高和 margin，有個表格詳細的列出各種情境的排列組合（是否為 <code>auto</code>）：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53627463283/" title="Summary of rules for dir=ltr in horizontal writing modes by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53627463283_af610fb8ac_b.jpg" width="776" height="1024" alt="Summary of rules for dir=ltr in horizontal writing modes" srcset="https://live.staticflickr.com/65535/53627463283_69bc0a53b3_k.jpg 2x" /></a></p>
<p>以 modal dialog 的例子來看怎樣計算水平的定位吧：首先來看屬性的組合，left 和 right 都是有值，值為 0、margin-left 和 margin-right 都是 auto，如果寬度是有值的話，那就是表格第二行中的第三項，算法就是：</p>
<blockquote>
<p>margins split positive free space</p>
</blockquote>
<p>剩餘的空間平分給兩個 margin auto，結果就會是水平置中；如果 width 是 auto 的話就是最下面一行：</p>
<blockquote>
<p>auto margins → zero<br />
solve for auto</p>
</blockquote>
<p>意思就是 margin 的 auto 都為 0，剩下的空間都給設為 auto 的 width。這表格也解釋了為何有些 <code>marign: auto</code> 會有元件置中的效果，其實這個問題也在我腦中好久了，沒想到計算方法在 CSS 2 就已經有明確的定義好了。</p>
<p>回來看 <code>&lt;dialog&gt;</code>，它在 modal 模式下，是會水平垂直置中的，但是它的寬高表現也很像是用 <code>auto</code> 一般，是根據內容變化的，那到底是怎樣達成這樣的效果的呢？其實關鍵就是它的寬高是一個新的值：<code>fit-content</code>，完整的樣式應該是：</p>
<pre><code class="language-css">dialog {
  position: fixed;
  inset: 0; /* shorthand of top, right, bottom, left */
  margin: auto;
  width: fit-content;
  height: fit-content;
}
</code></pre>
<p>結果就是，因為 width 不是 auto，所以套用的規則就是表格中的第二行中的第三項，根據標籤內容決定標籤的寬度之後，剩下的空間就平分給 margin，達成置中的效果。</p>
<p>了解原理之後，就可以知道哪些 CSS style 宣告是和定位有關的，除了可以避免不小心覆蓋掉（我最最一開始就是因為自訂 CSS 讓它定位不正常才開始研究的），還可以隨心所欲的調整標籤的位置，舉例來說，我的版面有一個 sidebar 佔去左邊的 300px，然後我希望 <code>&lt;dialog&gt;</code> 是在剩下的主要區域內置中，那我就把 left 設為 300px 就好了。</p>
<p>終於來到第三個問題，是怎樣讓其他地方都無法互動的呢？這就也是一個 <code>&lt;dialog&gt;</code> 的特異功能，它有一個隱藏的 is modal flag，呼叫 <code>showModal</code> 時，除了會把該 flag 設為 <code>true</code> 之外，還可以讓文件中其它部分變為和有 <code>inert</code> 時一樣，什麼是 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inert"><code>inert</code></a> 呢？中文翻譯為惰性，可以讓互動元件失去活性，使用時機就是如果互動元件因為一些原因需要暫時性的停用，例如收合起來的目錄，這時候我們不希望使用者的 focus 移動到目錄內，甚至不小心點擊到，那就可以用 <code>inert</code> 這個屬性讓它失去活性，使用者的游標就永遠不會跑進去，也不會有互動事件。</p>
<p>然後研究到這邊，我突然想起另外一個在腦中疑惑許久的問題，<strong>modal</strong> 這個單字到底是哪裡來的？為什麼 Bootstrap 也是選這個字？然後為什麼 HTML 不就 dialog 這個字用到底呢？進一步搜尋之後才發現，原來這邊的 modal 不是指 UI 元件，而是一種流程，這個 modal 其實是 modal window(dialog) 的 modal，而這個 modal 是專指應用程式中一種特定的模式(modal 的字源即為 mode)，在該模式之下，除了 modal window 之外的元件都被停用，使用者必須要先完成 modal window 內的互動才可以繼續。這就很像是古早時候的 <code>confirm</code> 和 <code>alert</code> 一樣，不把它關掉就無法繼續用網頁，然後我也才理解為什麼會標準文件內還會提到 autofocus 流程、還有為什麼會有 <code>returnValue</code> 這個屬性可以用。</p>
<p>其實 <a href="https://issues.chromium.org/issues/40251038">Chrome</a> 早在 2014 年就支援 <code>&lt;dialog&gt;</code> 了，然後還提供了個 <a href="https://github.com/GoogleChrome/dialog-polyfill">polyfill</a>（當然無法解決 top layer 的問題），不過 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=840640">Firefox</a> 和 <a href="https://bugs.webkit.org/show_bug.cgi?id=84635">Safari</a> 則是要到 2022 才支援，我去找出 Firefox 的 issue 來看，一路看下來，Firefox 是約 2016 開始，斷斷續續的實作，在實做的這段期間，其實標準也一直有修改，Safari 和 Firefox 都是 2022 才正式支援，到 2022 正式支援時的版本已經蠻穩定了，所以可以說是直到 2022，<code>&lt;dialog&gt;</code> 才是真正意義上的可用，我則是直到今年才有考慮拿來用，然後也才生出了這篇文章，其實 <code>&lt;dialog&gt;</code> 還有很多細節，像是 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::backdrop"><code>::backdrop</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:modal"><code>:modal</code></a>、<code>formmethod=&quot;dialog&quot;</code>、<code>returnValue</code>、怎麼用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/cancel_event"><code>cancel</code> 事件</a>和 <kbd>ESC</kbd> 等，雖然內文礙於篇幅沒有介紹，不過我有用 codesandbox 做了個簡單的<a href="https://codesandbox.io/p/sandbox/dialog-kf6fgr">範例</a>，有興趣的可以去玩看看。</p>
<p>最後，如果和我一樣是寫 React 要用 modal 模式的 <code>&lt;dialog&gt;</code> 的話，就一定要用到 <code>useEffect</code>，不能只操作 <code>open</code> 屬性，實作其實很簡單，我隨意搜尋一下也有看到一個 <a href="https://github.com/sjc5/use-html-dialog/blob/main/index.ts">use-html-dialog</a> ，也可以直接參考它的原始碼，關鍵的部分：</p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  if (openModal) {
    ref.current?.showModal();
  } else {
    ref.current?.close();
  }
}, [openModal]);
</code></pre>
<p>其他參考資料：</p>
<ul>
<li><a href="https://webkit.org/blog/12209/introducing-the-dialog-element/">Introducing the Dialog Element</a></li>
<li><a href="https://intersection.tw/6e9b2104eac0">Modal 模式是大多數設計師不甚瞭解的 UX 概念</a></li>
<li><a href="https://medium.com/@choce1378/modal-dialog-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%96%E5%80%91%E6%98%AF%E4%BB%80%E9%BA%BC%E5%97%8E-a1d1a975d3e0">Modal？Dialog？你真的知道他們是什麼嗎？</a></li>
</ul>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="001005" baseName="yamani">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2024-03-28</b:date>
				<b:time>10:01:14</b:time>
			</b:datetime>
			<b:category>diary</b:category>
			<b:title>やまに（yamani）旅館</b:title>
			<b:content>
				<b:summary> 去年的名古屋之行因為所以然後就跑去了南知多，研究行程時發現當地冬天有虎河豚，也很多餐廳有套餐可以享用，加上在台灣要吃河豚相對比較不容易，所以在安排行程時就花了不少時間研究要找哪一間，做這種套餐的其實很多是旅館，蠻大部分是當地的小型旅館，沒有上國際的訂房網站，甚至有的只有電話可以聯絡訂房訂位的，後來我的搜尋方法就是用 Google Map 慢慢找，在上面找了很久，最後選的旅館叫 やまに（yamani）旅館，本來是打算住一晚，後來因為參加源氏香活動的關係，就改成只有去吃河豚套餐。 選擇 Yamani 旅館的一個主要原因是，雖然舊，但是看起來蠻乾淨，我也一直很想體驗看看比較在地的住宿體驗（雖然沒住），另外就是它們其實也是有上樂天旅遊可以接外國遊客，不過樂天旅遊訂的話會比較貴，所以就還是在官網訂（不過沒住宿的我忘了樂天能不能能訂），唯一比較擔心的大概就是我沒日本電話號碼吧，不過結果還蠻順利的，不多說廢話，就趕快來看看 やまに旅館 的虎河豚套餐吧。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53403097470/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403097470_8f640fb9b6_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53403097470_931b7f0426_k.jpg 2x" /></a></p>
<p><a href="https://blog.othree.net/log/2024/01/06/2023-nagoya/">去年的名古屋之行</a>因為所以然後就跑去了南知多，研究行程時發現當地冬天有虎河豚，也很多餐廳有套餐可以享用，加上在台灣要吃河豚相對比較不容易，所以在安排行程時就花了不少時間研究要找哪一間，做這種套餐的其實很多是旅館，蠻大部分是當地的小型旅館，沒有上國際的訂房網站，甚至有的只有電話可以聯絡訂房訂位的，後來我的搜尋方法就是用 Google Map 慢慢找，在上面找了很久，最後選的旅館叫 <a href="https://yamaniryokan.com/">やまに（yamani）旅館</a>，本來是打算住一晚，後來因為參加源氏香活動的關係，就改成只有去吃河豚套餐。</p>
<p>選擇 Yamani 旅館的一個主要原因是，雖然舊，但是看起來蠻乾淨，我也一直很想體驗看看比較在地的住宿體驗（雖然沒住），另外就是它們其實也是有上樂天旅遊可以接外國遊客，不過樂天旅遊訂的話會比較貴，所以就還是在官網訂（不過沒住宿的我忘了樂天能不能能訂），唯一比較擔心的大概就是我沒日本電話號碼吧，不過結果還蠻順利的，不多說廢話，就趕快來看看 やまに旅館 的虎河豚套餐吧。</p>
</b:mainContent>
				<b:extendContent><p>我們訂的是梅套餐，菜色當然是比松或竹少一些，但是份量還是很多，首先是小菜：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53401737977/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53401737977_21dd10297c_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53401737977_11775c73be_k.jpg 2x" /></a></p>
<p>重點的河豚生魚片，非常大盤，這樣的份量台灣不知道會多貴：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402677121/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402677121_0ee9d0f2d9_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402677121_da33f93d34_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53403095425/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403095425_f80d4546c2_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53403095425_007315e940_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402985869/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402985869_99a3e7e93e_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402985869_cb020dd19f_k.jpg 2x" /></a></p>
<p>河豚生魚片很好吃，脆脆的口感非常特別，是整個套餐我最喜歡的，而且份量多讓我吃得很滿足。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402988134/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402988134_573282f201_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402988134_ecf32e7aeb_k.jpg 2x" /></a></p>
<p>然後是另外一個主要餐點之一的火鍋：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402985919/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402985919_8d8fdc8446_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402985919_564cf8cb5d_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402852473/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402852473_fe2d926e31_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402852473_2a1ee2c9cc_k.jpg 2x" /></a></p>
<p>河豚生魚片也可以用火鍋煮，不過就沒那麼好吃了，火鍋本身就味道很清淡，河豚肉就稍微比較硬，然後有一堆蔬菜，是整趟行程吃到最多菜的一餐了，給的菜和河豚肉還有豆腐等等差不多可以煮兩鍋。</p>
<p>然後是炸河豚：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53401740302/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53401740302_5e6bc856e9_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53401740302_fef53a7dd7_k.jpg 2x" /></a></p>
<p>我們還有點兒童餐，也是很豐盛，這次名古屋行點了好幾次兒童餐，都蠻讓人滿意的，這邊的還有生魚片：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402850033/" title="やまに旅館 兒童餐 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402850033_cfc6d17f84_b.jpg" width="1024" height="683" alt="やまに旅館 兒童餐" srcset="https://live.staticflickr.com/65535/53402850033_efd17b042f_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53401738032/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53401738032_3226e3e7d2_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53401738032_183c5ac46c_k.jpg 2x" /></a></p>
<p>最後的雜炊，因為火鍋吃完時已經很飽了，但是又很想吃吃看所以請他做一人份，結果份量根本還是兩人吃也很夠：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402662081/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402662081_37cd660103_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402662081_3966c3afd2_k.jpg 2x" /></a>
<a class="thumbnail" href="https://www.flickr.com/photos/othree/53402662051/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402662051_3e45455680_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402662051_532ed836fb_k.jpg 2x" /></a></p>
<p>甜點：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402987994/" title="やまに旅館 お手頃ふぐ梅 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402987994_e08a7ef6f8_b.jpg" width="1024" height="683" alt="やまに旅館 お手頃ふぐ梅" srcset="https://live.staticflickr.com/65535/53402987994_79c09427e1_k.jpg 2x" /></a></p>
<p>套餐內容其實還有兩個附近的富古神社（音同河豚）的繪馬，可以寫下願望後他幫我們去綁，我們一個寫願望一個帶回家當紀念。</p>
<p>然後稍微放些旅館本身的照片：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53403097250/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403097250_805d477e51_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53403097250_f1d09170fb_k.jpg 2x" /></a>
<a class="thumbnail" href="https://www.flickr.com/photos/othree/53403097225/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403097225_d8c93ed0c4_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53403097225_8f5d8a7bc8_k.jpg 2x" /></a></p>
<p>洗手間超有年代感，但是很乾淨完全沒異味：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402661896/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402661896_636dd2321c_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53402661896_0029df0058_k.jpg 2x" /></a></p>
<p>兒童拖鞋是小熊維尼的皮拖鞋：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402661406/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402661406_3c029e9230_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53402661406_4c366c51bc_k.jpg 2x" /></a></p>
<p>玄關的擺飾：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53402661716/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402661716_9a1d162ab8_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53402661716_1b0a06f1cd_k.jpg 2x" /></a>
<a class="thumbnail" href="https://www.flickr.com/photos/othree/53402987649/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402987649_cc95099649_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53402987649_3b80627c4b_k.jpg 2x" /></a>
<a class="thumbnail" href="https://www.flickr.com/photos/othree/53402661626/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53402661626_d02d6b2a61_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53402661626_c623ff82cd_k.jpg 2x" /></a></p>
<p>簽名板們：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53403097105/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403097105_146bd33a5c_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53403097105_88efa09b19_k.jpg 2x" /></a></p>
<p>外觀：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53403096770/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403096770_19fe3649ca_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53403096770_fceda8081b_k.jpg 2x" /></a></p>
<p>大門：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53403096745/" title="やまに旅館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53403096745_23fbb63856_b.jpg" width="1024" height="683" alt="やまに旅館" srcset="https://live.staticflickr.com/65535/53403096745_aec28c474a_k.jpg 2x" /></a></p>
<p>結帳可以刷卡還有很正式的收據，然後因為非旺季又是平日，所以當天只有我們一組客人，女將(?)也很樂情的跟我稍微攀談，問我們怎麼找到他們旅館的，後來還送了小朋友一些東西，非常不好意思。</p>
<p>PS. 南知多很多旅館都有內部的全景可以看，似乎是當地的觀光協會之類的統一委託建制的，在 Google Maps 上就可以看到</p>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="001004" baseName="ui-event-order">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2024-03-24</b:date>
				<b:time>18:07:13</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>UI Event Order</b:title>
			<b:content>
				<b:summary>我一直以來都對於 DOM 事件的順序抱有一種不確定的感覺，舉例來說，當使用者點滑鼠時，你可以預期到會有 mousedown、mouseup、click 事件，但是它們的順序是什麼呢？可以確定的是 down 一定是第一個，up 一定在 down 之後，那 click 是在中間還是最後呢？更進一步，點在可以有 focus 的元件上，那 focus 事件的順序呢？如果已經有其他元件有 focus，那它的 blur 事件又是在 focus 的前面還後面呢？除了滑鼠事件外，鍵盤事件又更複雜，除了 keydown、keyup 之外還有 input、change 和 IME 的 composition 事件等，總之最近實在是太在意了，就認真的弄了個測試網頁自己測試，之後又查找了相關的標準規範，這篇就來記錄一下這些事件的順序。 首先就來說滑鼠（指標裝置）相關的事件順序吧，第一個是滑鼠點擊，就是 mousedown、mouseup、click，是在 mouseup 後才接著有 click 事件，其實仔細想了一下也是蠻合理的，要有 up 事件才代表完成了 click 事件。然後這順序其實是有定義在 UI...</b:summary>
				<b:mainContent><p>我一直以來都對於 DOM 事件的順序抱有一種不確定的感覺，舉例來說，當使用者點滑鼠時，你可以預期到會有 <code>mousedown</code>、<code>mouseup</code>、<code>click</code> 事件，但是它們的順序是什麼呢？可以確定的是 down 一定是第一個，up 一定在 down 之後，那 <code>click</code> 是在中間還是最後呢？更進一步，點在可以有 focus 的元件上，那 <code>focus</code> 事件的順序呢？如果已經有其他元件有 focus，那它的 <code>blur</code> 事件又是在 <code>focus</code> 的前面還後面呢？除了滑鼠事件外，鍵盤事件又更複雜，除了 <code>keydown</code>、<code>keyup</code> 之外還有 <code>input</code>、<code>change</code> 和 IME 的 composition 事件等，總之最近實在是太在意了，就認真的弄了個測試網頁自己測試，之後又查找了相關的標準規範，這篇就來記錄一下這些事件的順序。</p>
<p>首先就來說滑鼠（指標裝置）相關的事件順序吧，第一個是滑鼠點擊，就是 <code>mousedown</code>、<code>mouseup</code>、<code>click</code>，是在 <code>mouseup</code> 後才接著有 <code>click</code> 事件，其實仔細想了一下也是蠻合理的，要有 up 事件才代表完成了 <code>click</code> 事件。然後這順序其實是有定義在 <a href="https://www.w3.org/TR/uievents/#events-mouseevent-event-order">UI Events 5.3.3</a> 之中的，其中的最後一個表格就是一個標準的點擊時事件的順序，而且這個表格還包括了 <code>mousemove</code> 和 <code>dblclick</code> 事件，這個章節中的其他部分則是滑鼠移動經過不同、多層的 DOM node 時，不同 node 上的 <code>mouseover</code>、<code>mouseout</code> 事件的順序。</p>
</b:mainContent>
				<b:extendContent><p>除了 Mouse Events 之外，其實現在瀏覽器的實作應該是都實作 <a href="https://w3c.github.io/pointerevents/">Pointer Events</a> 了，Pointer Events 涵蓋了各種指標式的控制方式，包括了滑鼠、觸控、觸控筆等，所以可以說 Mouse Events 只能算是子集，相對應的事件名稱基本上就是把 <code>mouse</code> 換成 <code>pointer</code>，例如：<code>pointerdown</code>、<code>pointerup</code>，現在主流的瀏覽器也都已經有支援 Pointer Events 了，然後這時候問題就來了，Pointer Event 和 Mouse Events 誰先誰後？根據測試的結果，是 Pointer 先然後才 Mouse，所以更完整的順序是：</p>
<pre><code>pointerdown
mousedown
focus
focusin
pointerup
mouseup
click
</code></pre>
<p>至於這個順序是怎麼決定的呢？根據 Pointer Events 的 <a href="https://w3c.github.io/pointerevents/#compatibility-mapping-with-mouse-events">11 章「Compatibility mapping with mouse events」</a> 所述，瀏覽器開發時可以考慮同時發佈古時候的 Mouse Events，其中 11.2、11.3 就有提到先發佈 Pointer Events 接著再發佈對應的 Mouse Event。</p>
<p>然後還有一個細節是，根據 Pointer Event <a href="https://w3c.github.io/pointerevents/#the-pointerdown-event">4.2.3 The pointerdown event</a>，如果在 <code>pointerdown</code> 事件裡面呼叫 <code>event.preventDefault()</code> 取消事件的話，後面的 <code>mousedown</code> 和 <code>mouseup</code> 就都不會觸發。</p>
<p>我上面的那段事件順序，其實還多列了一個 <code>focusin</code>，這其實是一系列的新(相較於 DOM2)事件，包括了：</p>
<ul>
<li><code>focusin</code> 對應 <code>focus</code></li>
<li><code>focusout</code> 對應 <code>blur</code></li>
<li><code>mouseenter</code> 對應 <code>mouseover</code></li>
<li><code>mouseleave</code> 對應 <code>mouseout</code></li>
</ul>
<p>其實 <code>mouseenter</code> / <code>mouseleave</code> 是 IE5.5 時微軟先提出的，ppk 也有<a href="https://www.quirksmode.org/js/events_mouse.html#mouseenter">文章</a>介紹過它解決了什麼問題，jQuery 當年也有支援，後來進入了 W3C 標準，現在是放到 <a href="https://w3c.github.io/uievents/#event-type-mouseenter">UI Events</a> 裡面，這些事件最大的差異就是它們不會 bubble 到外層，減少了很多問題；<code>focusin</code> / <code>focusout</code> 則是剛好相反，它們會 bubble 而 <code>focus</code> / <code>blur</code> 不會，一樣 ppk 也有<a href="https://www.quirksmode.org/blog/archives/2008/04/delegating_the.html">文章</a>介紹到，簡單說就是 <code>focus</code> / <code>blur</code> 不會 bubble 只有 capture（外往內到 event target 的過程），但是 IE 不是用 addEventListener 所以沒有 capture 階段，所以會無法實作出 event delegation，然後只能用當年微軟 IE 特有的 <code>focusin</code> / <code>focusout</code> 事件，現在也是標準化，收到 <a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-type-focusin">DOM 3 Events</a> 裡面；而除了這四組之外，其實 Pointer Events 也有 enter 和 leave，一樣順序是在 over 和 out 的後面，然後這些成對的事件，都是比較早定義的那些先發生，才接後來定義的，和有沒有 bubble 無關。</p>
<p>接著來說 Keyboard Events，這邊就針對 input 節點上的，一個鍵盤按鍵按壓的動作，會產生 <code>keydown</code>、<code>keypress</code>、<code>keyup</code> 三個基本的事件，通常按鍵盤按鍵就是為了輸入東西，所以會有個也是比較新的 <code>input</code> 事件，會在 <code>keypress</code> 之後，<code>input</code> 則還有一個成對的 <code>beforeinput</code>，如果在 <code>beforeinput</code> 內叫 <code>preventDefault()</code> 的話則可以阻止文字的輸入，總之順序如下：</p>
<pre><code>keydown
keypress
beforeinput
input
keyup
</code></pre>
<p><code>change</code> 事件則是要在 <code>blur</code> 時才會有，順序是先 <code>change</code> 才 <code>blur</code>：</p>
<pre><code>change
blur
focusout
</code></pre>
<p>這個順序是定義在 HTML 的 User Interaction 一章的 <a href="https://html.spec.whatwg.org/multipage/interaction.html#unfocus-causes-change-event">6.6.4 Processing model</a> 裡面，明確的寫下要先 commit change 後才 <code>blur</code>。</p>
<p>如果有用 IME 的話，事情就很不單純了，還會有 Composition Events，順序是在 <code>beforeinput</code> 前面，剛開始組字會同時有 <code>compositionstart</code> 和 <code>compositionupdate</code> 兩個事件，然後沒有 <code>keypress</code>，之後的輸入組字則就是只有 <code>update</code>：</p>
<pre><code>keydown
compositionstart
compositionupdate
beforeinput
input
keyup
</code></pre>
<p>Composition Events 現在標準的文件是放在 <a href="https://w3c.github.io/uievents/#events-compositionevents">UI Events 裡面</a>，不過文件中範例的順序和實際測試的結果並不一致，目前的文件草稿中 <code>compositionupdate</code> 是在 <code>beforeinput</code> 之後，不過其實現在瀏覽器的順序是在 UI Events 的 <a href="https://github.com/w3c/uievents/issues/354">Issue 354</a> 提出的變動，只是目前文件還沒有發布更新的內容。</p>
<p>結束組字的時候，不同瀏覽器的行為就有差異了，首先是按下 <kbd>Enter</kbd> 完成組字時，Firefox 的話不會有多一個 <code>update</code>，直接就是 <code>compositionend</code>，然後是在 <code>beforeinput</code> 和 <code>input</code> 之間：</p>
<pre><code>keydown
beforeinput
compositionend
input
keyup
</code></pre>
<p>Chrome(v123) 的話就會有多一個 <code>compositionupdate</code> 然後 <code>compositionend</code> 順序也不一樣，會在 <code>input</code> 的後面：</p>
<pre><code>keydown
compositionupdate
beforeinput
input
compositionend
keyup
</code></pre>
<p>其實 <a href="https://w3c.github.io/uievents/#events-composition-key-events">UI Events 文件 5.7.5</a> 內的範例是 Firefox 那種沒有多 <code>compositionupdate</code> 的順序，這個 5.7 章節內其實還有不少其他情境下的事件順序，像是手寫輸入，取消輸入等等。</p>
<p>如果是還沒完成組字，直接切換輸入法強迫結束組字，事件順序都和按下 <kbd>Enter</kbd> 都一樣，如果是組字到一半直接切換視窗，就是標準沒定義到的狀況了，Firefox 的行為比較接近上面的樣子，先完成 <code>input</code> 才 <code>blur</code>：</p>
<pre><code>beforeinput
compositionend
input
blur
focusout
</code></pre>
<p>Chrome 則是會先產生 <code>blur</code> 然後接 <code>compositionend</code>：</p>
<pre><code>change
blur
focusout
compositionend

</code></pre>
<p>以上，大概紀錄了我一直以來都有疑惑的使用者行為所產生的事件們的順序，最後附上我用的程式碼（超單純）：</p>
<pre><code class="language-javascript">const events = [
  &quot;keydown&quot;,
  &quot;keypress&quot;,
  &quot;keyup&quot;,
  &quot;change&quot;,
  &quot;compositionstart&quot;,
  &quot;compositionupdate&quot;,
  &quot;compositionend&quot;,
  &quot;beforeinput&quot;,
  &quot;input&quot;,
  &quot;click&quot;,
  &quot;auxclick&quot;,
  &quot;contextmenu&quot;,
  &quot;mousedown&quot;,
  &quot;mouseup&quot;,
  &quot;focus&quot;,
  &quot;focusin&quot;,
  &quot;focusout&quot;,
  &quot;blur&quot;,
  &quot;pointerdown&quot;,
  &quot;pointerup&quot;,
  &quot;paste&quot;,
];

const elem1 = document.getElementById(&quot;target-1&quot;);
const elem2 = document.getElementById(&quot;target-2&quot;);

events.forEach((event) =&gt; {
  elem1.addEventListener(
    `${event}`,
    () =&gt; {
      console.log(event.target.id, event);
    },
    false
  );
  elem2.addEventListener(
    `${event}`,
    () =&gt; {
      console.log(event.target.id, event);
    },
    false
  );
});
</code></pre>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="001003" baseName="akira-toriyama">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2024-03-08</b:date>
				<b:time>23:15:52</b:time>
			</b:datetime>
			<b:category>acg</b:category>
			<b:title>鳥山明過世</b:title>
			<b:content>
				<b:summary> 今天（2024-03-08）官方發布的消息，七龍珠的作者鳥山明在三月一日時因病過世了，JUMP 也有訃報，而且還有堀井雄二、桂正和、尾田栄一郎和岸本斉史的緬懷文（巴哈姆特 GNN 有譯文），在緬懷鳥山明之餘，想來紀錄一下我對七龍珠系列的一些小心得。 首先是作者名字，其實我小時候一直搞錯，而且搞錯很久，把「鳥」當成「島」，即使到現在我都還需要在腦中確認一下，然後直到今天我才知道名字的念法（Akira Toriyama）；然後就是雖然現在大家對於 Z 那段的印象是很拖，但是其實拖的是電視動畫而已，後來我回去重看漫畫時，其實節奏還蠻明快的，當然有不少轉折拉長連載的時間，但不會在同一段劇情上拖拖拉拉；然後另外一個印象就是角色強度的通膨，以前總有個是不是一直吃書改設定的印象，像是佛力札已經號稱是宇宙最強了，怎麼後面還可以一直有更強的角色，後來重看漫畫才發現其實沒有，宇宙帝王佛力札就是在那個時間點的該宇宙中戰鬥力最高的人，接在後面的人造人是紅緞帶軍團製造出來的，魔人普烏則是古早時候就被大界王神封印的，所以佛力札作威作福時人造人還不存在，普烏則是被封印的狀態。 然後動畫故事到魔人普烏之後的續作，有「GT」和「神 vs 神」、「超」那一個系列的兩個線，其實我兩部都蠻喜歡的，比較早的 GT 是鳥山明沒有參與的，這邊就先略過，後來好不容易鳥山明回來參與的「神 vs 神」劇場版開始的世界設定，擴展了整個世界/宇宙的設定，從和界王神成對的破壞神開始到後來的多重宇宙、超級賽亞人 Blue、全王等等，我覺得都很非常的精巧，有趣而且最厲害的是沒有破壞到既有的設定，只能說真不愧是鳥山明，不知道這些設定有多詳細，和未來的企劃也不知道有多少關聯（像是那個還沒開始的大魔），不管如何，都是無限讓人惋惜啊。 最後想放一個 YouTube 的影片連結： https://www.youtube.com/watch?v=aOXs5hg0a5Y 這是龍珠超最後悟空和吉連對決最高潮的片段，也就是悟空進入「身勝手の極意」狀態的片段，似乎是在墨西哥的非官方?公開放映的景象（一開始有非授權的放映，但是後來有各種地方政府取得授權的放映活動），當初看到這影片的時候就覺得很驚訝，沒想到會在離日本這麼遙遠的地方，有個國家這麼多人都對七龍珠有這麼大的熱情，真的是個空前的成就。 追記：在發文的時間點，推特（現在的 X）的日本的 Trends 上沒有鳥山明，不過其實有三個相關的：「かめはめ波」、「スーパーサイヤ人」和「国民栄誉賞」。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53575001401/" title="鳥山明訃報 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53575001401_24c238fbc5_b.jpg" width="600" height="800" alt="鳥山明訃報" /></a></p>
<p>今天（2024-03-08）官方發布的<a href="https://dragon-ball-official.com/news/01_2499.html">消息</a>，七龍珠的作者鳥山明在三月一日時因病過世了，JUMP 也有<a href="https://www.shonenjump.com/j/2024/03/08/240308_oshirase.html">訃報</a>，而且還有堀井雄二、桂正和、尾田栄一郎和岸本斉史的緬懷文（巴哈姆特 GNN 有<a href="https://gnn.gamer.com.tw/detail.php?sn=264681">譯文</a>），在緬懷鳥山明之餘，想來紀錄一下我對七龍珠系列的一些小心得。</p>
<p>首先是作者名字，其實我小時候一直搞錯，而且搞錯很久，把「鳥」當成「島」，即使到現在我都還需要在腦中確認一下，然後直到今天我才知道名字的念法（Akira Toriyama）；然後就是雖然現在大家對於 Z 那段的印象是很拖，但是其實拖的是電視動畫而已，後來我回去重看漫畫時，其實節奏還蠻明快的，當然有不少轉折拉長連載的時間，但不會在同一段劇情上拖拖拉拉；然後另外一個印象就是角色強度的通膨，以前總有個是不是一直吃書改設定的印象，像是佛力札已經號稱是宇宙最強了，怎麼後面還可以一直有更強的角色，後來重看漫畫才發現其實沒有，宇宙帝王佛力札就是在那個時間點的該宇宙中戰鬥力最高的人，接在後面的人造人是紅緞帶軍團製造出來的，魔人普烏則是古早時候就被大界王神封印的，所以佛力札作威作福時人造人還不存在，普烏則是被封印的狀態。</p>
<p>然後動畫故事到魔人普烏之後的續作，有「GT」和「神 vs 神」、「超」那一個系列的兩個線，其實我兩部都蠻喜歡的，比較早的 GT 是鳥山明沒有參與的，這邊就先略過，後來好不容易鳥山明回來參與的「神 vs 神」劇場版開始的世界設定，擴展了整個世界/宇宙的設定，從和界王神成對的破壞神開始到後來的多重宇宙、超級賽亞人 Blue、全王等等，我覺得都很非常的精巧，有趣而且最厲害的是沒有破壞到既有的設定，只能說真不愧是鳥山明，不知道這些設定有多詳細，和未來的企劃也不知道有多少關聯（像是那個還沒開始的大魔），不管如何，都是無限讓人惋惜啊。</p>
<p>最後想放一個 YouTube 的影片連結：</p>
<p><a href="https://www.youtube.com/watch?v=aOXs5hg0a5Y">https://www.youtube.com/watch?v=aOXs5hg0a5Y</a></p>
<p>這是龍珠超最後悟空和吉連對決最高潮的片段，也就是悟空進入「身勝手の極意」狀態的片段，似乎是在墨西哥的非官方?公開放映的景象（一開始有非授權的放映，但是後來有各種地方政府取得授權的放映活動），當初看到這影片的時候就覺得很驚訝，沒想到會在離日本這麼遙遠的地方，有個國家這麼多人都對七龍珠有這麼大的熱情，真的是個空前的成就。</p>
<p>追記：在發文的時間點，推特（現在的 X）的日本的 Trends 上沒有鳥山明，不過其實有三個相關的：「かめはめ波」、「スーパーサイヤ人」和「国民栄誉賞」。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53575020381/" title="Japan Trends 2024-03-08 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53575020381_d36fbe330e_b.jpg" width="387" height="1024" alt="Japan Trends 2024-03-08" srcset="https://live.staticflickr.com/65535/53575020381_37c354f542_k.jpg 2x" /></a></p>
</b:mainContent>
				<b:extendContent></b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="001002" baseName="qr-code-history">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2024-01-12</b:date>
				<b:time>23:42:13</b:time>
			</b:datetime>
			<b:category>diary</b:category>
			<b:title>QR Code 發明歷史展</b:title>
			<b:content>
				<b:summary> 去年去名古屋時，有去了 Toyota 產業技術紀念館，館內的展覽其實著重在技術介紹，分為紡織和汽車，其實我以前不知道 Toyota 是紡織起家的，展覽的內容非常不錯，很多機器都還可以運作，而且也可以讓訪客按按鈕自動展示，非常用心：...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53400019990/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53400019990_281e6bd784_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53400019990_9636388588_k.jpg 2x" /></a></p>
<p><a href="https://blog.othree.net/log/2024/01/06/2023-nagoya/">去年去名古屋</a>時，有去了 <a href="https://www.tcmit.org/">Toyota 產業技術紀念館</a>，館內的展覽其實著重在技術介紹，分為紡織和汽車，其實我以前不知道 Toyota 是紡織起家的，展覽的內容非常不錯，很多機器都還可以運作，而且也可以讓訪客按按鈕自動展示，非常用心：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53400018490/" title="トヨタ産業技術記念館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53400018490_75533ab6f8_b.jpg" width="1024" height="683" alt="トヨタ産業技術記念館" srcset="https://live.staticflickr.com/65535/53400018490_9bfe9edc2b_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53398655727/" title="トヨタ産業技術記念館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53398655727_79d94ac64f_b.jpg" width="1024" height="683" alt="トヨタ産業技術記念館" srcset="https://live.staticflickr.com/65535/53398655727_1525f1a646_k.jpg 2x" /></a></p>
</b:mainContent>
				<b:extendContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53400010890/" title="トヨタ産業技術記念館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53400010890_481e2c8b8e_b.jpg" width="1024" height="683" alt="トヨタ産業技術記念館" srcset="https://live.staticflickr.com/65535/53400010890_b51e087f6e_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53399581111/" title="トヨタ産業技術記念館 by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53399581111_f6dc3bdb30_b.jpg" width="1024" height="683" alt="トヨタ産業技術記念館" srcset="https://live.staticflickr.com/65535/53399581111_5924ffeee2_k.jpg 2x" /></a></p>
<p>而除了兩個展覽館之外，其實這段時間在入口附近還有一個特別企劃的 <a href="https://www.tcmit.org/information/news/2023/10/50182">QR Code 發明歷史展</a>，應該是因為去年是 QR Code 發明的 30 週年吧，我自然是對這個很有興趣，雖然展區小小的但是也有些收穫，為了寫這篇文章我也又查了不少資料。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53400021685/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53400021685_84f171c074_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53400021685_deea6cb207_k.jpg 2x" /></a></p>
<p>QR Code 的很多資訊其實在 Wikipedia 上都有，不過我是看展覽才注意到原來是因日本電装（Denso）內部的需求而要開始研發二維條碼，設計出 QR Code 的原昌宏當然也是日本電装的員工，該社的研發能力蠻強的，日本電装還有一個東西是我以前在介紹<a href="https://blog.othree.net/log/2022/12/23/japan-postal-code/">日本郵遞區號</a>時有提過的，就是日本導航常用的 <a href="https://www.denso-solution.com/mapcode/whats.html">Mapcode</a>，都是非常廣泛使用的東西，由於是 Toyota 子公司，這些發明也都是圍繞著汽車相關而生的，Mapcode 主要應用在導航，而 QR Code 當初主要是為了「かんばん」系統的汽車生產零件管理，而會能像現在這樣廣泛的被使用，我覺得有兩個主要的因素，第一個是原昌宏在設計 QR Code 時，底層的設計很通用，而沒有特化於汽車零件，另一個就是日本電装當時雖然有申請專利，但各種考量後決定公開來讓大家自由使用，接下來就來看看展覽的內容吧：</p>
<p>專利書：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53399914129/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53399914129_7bf2d481fc_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53399914129_327369b27d_k.jpg 2x" /></a></p>
<p>原昌宏是設計 QR Code 的人，渡部元秋則是主要的軟體開發者，一開始的研發團隊就只有這兩位，另外三位當中的野尻忠雄是主管，另外兩位則是 Toyota 中央研究所的成員，應該是協助軟體開發的。</p>
<p>還有列出其他的關係者，以前比較沒機會看到的團隊成員、負責人還有推動公開標準化的成員等：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53398660467/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53398660467_e106eb192a_b.jpg" width="600" height="900" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53398660467_51b68c3a7f_k.jpg 2x" /></a></p>
<p>讀本裡面有介紹其他的二維條碼：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53399914069/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53399914069_b81e43605b_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53399914069_3e03ed7782_k.jpg 2x" /></a></p>
<p>簡單的歷史：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53399589081/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53399589081_e89a7a029f_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53399589081_9835b3e861_k.jpg 2x" /></a></p>
<p>中間有提到開放的原因之一，就是為了搶佔市占率，然後他們可以從 code reader 和印刷市場來賺取收益。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53400020610/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53400020610_8ba2bb2c6b_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53400020610_99d696225f_k.jpg 2x" /></a></p>
<p>在各個關係者當中，負責標準化的柴田彰於 2022 年八月有在 Digital Practice 發表「<a href="https://www.ipsj.or.jp/dp/contents/publication/51/S1303-S05.html">QRコードの事業戦略と標準化</a>」一文，內容很多，有各種背景介紹，競爭對手，還有像是 Toyota 內部的「かんばん」系統在導入 QR Code 前後的標籤；與其他二維條碼的比較，有一組對照不同條碼相同設定相同資料的面積差異；還有標準化的各種紀錄，像是 ISO 15394 的包裹標籤在使用 QR Code 前後的差異等，非常值得看看。</p>
<p>然後就是我覺得最貴重的研究手稿了，不知道有沒有數位化保存：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53399912629/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53399912629_b8d3024ed9_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53399912629_9736eb38c1_k.jpg 2x" /></a></p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53400019990/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53400019990_281e6bd784_b.jpg" width="1024" height="683" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53400019990_9636388588_k.jpg 2x" /></a></p>
<p>然後是各種的變形版 QR Code：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53398659582/" title="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～ by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53398659582_23a22e9a85_b.jpg" width="600" height="900" alt="QRコード発明ヒストリー～QRコードはトヨタグループの発明だった！～" srcset="https://live.staticflickr.com/65535/53398659582_47e87667dd_k.jpg 2x" /></a></p>
<p>展覽中列出的有：</p>
<ul>
<li><a href="https://www.qrcode.com/codes/microqr.html">Micro QR Code</a>: 比較小的 QR Code，只有一個定位點；</li>
<li><a href="https://www.qrcode.com/codes/rmqr.html">rMQR Code(Rectangular Micro QR Code)</a>: 矩形的 Micro QR Code，可以弄成長方形列印在比較狹窄的地方；</li>
<li><a href="https://www.denso-wave.com/ja/system/qr/product/sqrc.html">SQRC(Security QR Code)</a>: 包含隱藏資料區的 code，要特定的 code reader 才可以讀取到隱藏內容，還有配合用特殊油墨列印的防複製的方法；</li>
<li><a href="https://www.denso-wave.com/ja/system/qr/product/frame.html">Frame QR</a>: 中間有留白一塊可以任意加工的版本。</li>
</ul>
<p>除了以上四種之外，其實還有：</p>
<ul>
<li><a href="https://www.qrcode.com/codes/iqr.html">iQR</a>: 也是可以做成長方形的 code，不過其實是過渡規格，沒有標準化，相關的設計後來就是用在 rMQR 中；</li>
<li><a href="https://www.denso-wave.com/ja/adcd/event/aice2019/tqr.pdf">tQR</a>: t 是 toughness，是東京都營地下鐵和 Denso Wave（日本電装子公司，負責 QR Code 的部門已經拆分至此）合作的，專門用來判斷列車車門位置用的，官方的介紹就有提到為什麼需要這種機制判斷車門位置，為的像是對應不同編成的列車或是不同車門配置的車廂等等，另外有一份日本自動識別系統協會的<a href="https://www.jaisa.or.jp/action/aim/pdfs/vol64.pdf">會報</a>（4-6 頁）裡面也有介紹部分的系統運作機制，而 tQR 就是這個系統所使用的特規的 QR Code，第一眼應該就可以發現三個定位點的位置不一樣，然後編碼的容錯率則有加強到 50%。</li>
</ul>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53458136027/" title="tQR by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53458136027_270911a92b_o_d.jpg" width="201" height="200" alt="tQR" /></a></p>
<p>然後除了這些，回來查資料後我還發現其實普通的 QR Code 就可以多個連接，日文就稱為「連接」，英文則是稱為 Structured Append，最多可以連接 16 個，如下圖：</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53458187002/" title="Structure Append QR Code by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53458187002_dddb55862e_b.jpg" width="1024" height="630" alt="Structure Append QR Code" /></a></p>
<p>這個機制除了可以增加資料量外，也是早期在 iQR 或是 rMQR 出來前，可以把正方形轉成長方形的一種方式，不過有支援的裝置和軟體比較少，例如我用 iPhone 相機就不支援一次全部讀取，然後如果要讀取單一個 code 就可能會跑出「找不到可用的資料」，事實上，前面介紹的 QR Code 的變形版本，iPhone 內建的相機也都不支援。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53459436824/" title="Structure Appended QR Code by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53459436824_dc9923ca6e_b.jpg" width="473" height="1024" alt="Structure Appended QR Code" srcset="https://live.staticflickr.com/65535/53459436824_5117b13520_k.jpg 2x" /></a></p>
<p>所以接下來就要介紹最後一個收穫了，官方的 QR Code Scanner App：<a href="https://www.qrqrq.com/">クルクル（QRQR）</a>，其實我很久以前，就一直很好奇到底有沒有所謂官方的 QR Code reader 了，古早以前都是用 ZXing 的 <a href="https://play.google.com/store/apps/details?id=com.google.zxing.client.android">Barcode Scanner</a>，不過其實這是 Open Source 專案，現在也已經沒在維護了。而 Denso Wave 的官方 app，則是在 2017 年才和 Arara Inc（Denso Wave 是股東之一）一起合作<a href="https://www.denso-wave.com/ja/adcd/info/detail__14521.html">推出</a>的，當時名稱叫「Q」，後來則更名為 QRQR，免費，有多語系也沒廣告，佛心，然後支援很多種格式，包括了 Barcode、兩種標準的 QR Code，還有 Micro QR、iQR、rMQR、Frame QR 以及剛剛最後提到的連結的 QR Code，解碼速度也很快，不過曾經有過偷收集資料的壞紀錄，所以要不要用就自行評估啦。</p>
<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/53459416788/" title="クルクル（QRQR） by othree, on Flickr"><img src="https://live.staticflickr.com/65535/53459416788_2e2fcae982_b.jpg" width="1024" height="686" alt="クルクル（QRQR）" srcset="https://live.staticflickr.com/65535/53459416788_7efb432723_k.jpg 2x" /></a></p>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
