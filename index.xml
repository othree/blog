<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>i</b:listType>
			<b:listData listID="index"/>
		</b:entriesMeta>

		<b:entry entryID="000877" baseName="native-true-color-vim">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-10-03</b:date>
				<b:time>23:44:12</b:time>
			</b:datetime>
			<b:category>vim</b:category>
			<b:title>Native True Color Vim</b:title>
			<b:content>
				<b:summary>因為最近 Vim 8 發佈了，所以就又研究一下現在最新的 True Color Vim 安裝方法，結果發現已經併進 master branch 許久了，然後從 7.4.1784 開始，也不用加特別參數來編譯，只要 --with-features 的值是 big 或是更大的 huge 就會把這功能編譯進去，所以現在就不用 ZyX 維護的版本了，目前用的編譯指令為： git clone https://github.com/vim/vim.git cd vim cd src &amp;&amp; make autoconf &amp;&amp; cd .. ./configure \ --enable-gui=no \ --without-x \...</b:summary>
				<b:mainContent><p>因為最近 Vim 8 發佈了，所以就又研究一下現在最新的 True Color Vim 安裝方法，結果發現已經併進 master branch 許久了，然後從 <a href="https://github.com/vim/vim/commit/8e9eb3a6a1e589949f1c878c839528d917fdfc4a">7.4.1784</a> 開始，也不用加特別參數來編譯，只要 <code>--with-features</code> 的值是 <code>big</code> 或是更大的 <code>huge</code> 就會把這功能編譯進去，所以現在就不用 ZyX 維護的版本了，目前用的編譯指令為：</p>

<pre><code>git clone https://github.com/vim/vim.git

cd vim
cd src &amp;&amp; make autoconf &amp;&amp; cd ..

./configure \
  --enable-gui=no \
  --without-x \
  --enable-multibyte \
  --with-tlib=ncurses \
  --enable-cscope \
  --with-features=huge \
  --disable-nls \
  --enable-perlinterp \
  --enable-pythoninterp \
  --enable-rubyinterp

make
make install
</code></pre>

<p>然後現在也不需要 <code>guicolors</code> 的設定，好像直接就生效了，顏色畫出來和之前的 ZyX 的版本似乎有一點差異，我想應該現在新的版本是比較正確才是。追蹤這功能追了這麼久，總算也是告一段落了，感覺...好像也沒什麼特別的感覺...</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000876" baseName="safari-10">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-09-21</b:date>
				<b:time>23:57:08</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>Safari 10 for Developer</b:title>
			<b:content>
				<b:summary>Safari 10 跟著 macOS 一起出來了，這次更新了不少東西（對於網頁開發者來說），Apple 也依舊放了一份文件在他們的 Developer Library 裡面，以下列出我覺得比較有趣的： CSP 2.0 CSP 2.0 和之前的版本相比，最主要是多了非常多可以控制的權限，也有幾個名稱有改掉，不過基本上格式是相容的。 Shadow DOM Shadow DOM 1.0 標準，這也讓 Web Component 的理想又往前賣進一步了。 ES 6 號稱支援度 100%，看起來是依據 ECMAScript compatable table 的，不過在 module 的面前，還沒有真的 100% 的啊，另外主流瀏覽器其實支援度都蠻高了，之前 Edge 還放話說領先的，沒想到現在就已經被 Safari 10 和...</b:summary>
				<b:mainContent><p>Safari 10 跟著 macOS 一起出來了，這次更新了不少東西（對於網頁開發者來說），Apple 也依舊放了一份<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html">文件</a>在他們的 Developer Library 裡面，以下列出我覺得比較有趣的：</p>

<h4>CSP 2.0</h4>

<p>CSP 2.0 和之前的版本相比，最主要是多了非常多可以控制的權限，也有幾個名稱有改掉，不過基本上格式是相容的。</p>

<h4>Shadow DOM</h4>

<p>Shadow DOM 1.0 標準，這也讓 Web Component 的理想又往前賣進一步了。</p>

<h4>ES 6</h4>

<p>號稱支援度 100%，看起來是依據 <a href="http://kangax.github.io/compat-table/es6/#safari10">ECMAScript compatable table</a> 的，不過在 module 的面前，還沒有真的 100% 的啊，另外主流瀏覽器其實支援度都蠻高了，之前 Edge 還放話說領先的，沒想到現在就已經被 Safari 10 和 Chrome 超過了，而 Chrome 看來也之差 tail call 而已，接下來應該又要開始效能比拼了吧。</p>

<h4>Inline and Auto Video Playback in iOS</h4>

<p>這也是等很久的功能，之前就有先開放靜音影片能直接在 iOS Safari 上自動播放，主要的考量是，gif 和 mp4 相比，還是 gif 比較吃資源啊。</p>

<h4>ES Internationalization</h4>

<p>ECMA-402 支援，這也是希望快點普及的東西啊，不然數字、日期什麼的搞本地化實在很麻煩。</p>

<h4>WOFF 2.0 Support</h4>

<p>令人意外的有點慢，不過還算很有誠意的把很新的 <a href="https://drafts.csswg.org/css-font-loading/">CSS Font Loading Module Level 3</a> 的 API 做好了。</p>

<h4>#RRGGBBAA</h4>

<p>新的 CSS color 格式，也是前陣子才 propose 出來而已，這樣以後就可以讓 CSS 裡的顏色格式統一點了。</p>

<h4>Right-to-Left Language Support</h4>

<p>主要是 RTL 頁面 scrollbar 的位置終於會換邊了。</p>

<h4>Media Query for Wide Color Gamut Support</h4>

<p>廣色域的 CSS media query，主要是因為最新的 iMac 和 iPhone 7 都有支援 P3 色域了。</p>

<h4>WebDriver Support</h4>

<p>主流瀏覽器最後一個支援的...</p>

<h4>Apple Pay for the Web</h4>

<p>這真的蠻兇狠的，不過 Google 也有在 Android 做類似的<a href="https://android.googleblog.com/2016/09/tap-pay-yes-android-pay-welcomes-chase.html">事</a>就是了。</p>

<p>大概就這些了，其實也列出超過一半的項目了，Safari 這種更新頻率其實比起其它幾家來說吃虧不少，不過還是一直有跟上最新進度，其實也蠻厲害的，更何況現在 Google 都把人拉到 Blink 去，有回到 Webkit 的貢獻似乎比例上不高。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000875" baseName="git-mrt">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-09-17</b:date>
				<b:time>11:41:49</b:time>
			</b:datetime>
			<b:category>software</b:category>
			<b:title>MRT &amp; GIT</b:title>
			<b:content>
				<b:summary>/* A_A */ 今年 COSCUP Lightening Talk 分享的主題是 GIT &amp; MRT，主題就是紀錄我之前用 GIT 線圖畫台北捷運路線圖的過程，投影片在上面，這篇文章是補充一下被省略的部分和講不完的部分，當天我有用 Ricoh Theta 錄影，也丟上 YouTube 了：...</b:summary>
				<b:mainContent><script async="async" class="speakerdeck-embed" data-id="a6c9e72eb4b44e16b5862fc3e7c84153" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js">/* A_A */</script>

<p>今年 COSCUP Lightening Talk 分享的主題是 GIT &amp; MRT，主題就是紀錄我之前用 GIT 線圖畫台北捷運路線圖的過程，投影片在上面，這篇文章是補充一下被省略的部分和講不完的部分，當天我有用 Ricoh Theta 錄影，也丟上 YouTube 了：</p>

<div class="embed_16_9">
<iframe width="853" height="480" src="https://www.youtube.com/embed/OBadluXaJi8?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
</b:mainContent>
				<b:extendContent><p>接著要來說一下當天省略的部分吧，就是 <code>git branch</code> 和 <code>git log</code> 我所學到的東西，不過要把這內容講清楚，需要先介紹一下 <code>.git</code> 這個資料匣，這是 git repository 的所有資料儲存的地方，包括所有的 branch、commit 資訊、檔案和目錄結構等等都在裡面，一般 <code>git clone</code> 也是先把這個目錄的內容抓下來，然後才把從裡面把工作目錄（working directory）的檔案弄出來，那麼，如果現在已經把 <code>.git</code> 的資料都抓下來後，要怎麼取出工作目錄的檔案呢，首先要看 <code>.git/HEAD</code> 這個檔案，一般而言，內容會是：</p>

<pre><code>ref: refs/heads/master
</code></pre>

<p>意思是 reference 到 <code>.git/refs/heads/master</code>，所以就看一下這個檔案的內容，以 <a href="https://github.com/othree/immutable-quadtree-js">immutable-quadtree-js</a> 為例，<code>.git/refs/heads/master</code> 的內容如下：</p>

<pre><code>4b5c03ea81e0e24714bea66de3892a40165fe56f
</code></pre>

<p>這是一段 sha-1 hash，那麼要到哪裡找這個 hash 的內容呢？其實這個檔案的位置就在：</p>

<pre><code>.git/objects/4b/5c03ea81e0e24714bea66de3892a40165fe56f
</code></pre>

<p>檔案（又稱為 object）內容是用 zlib 壓縮過的，git 有簡單的工具可以幫忙檢視內容，就是 <code>git cat-file</code>，只要給他 hash 它就會自動去定位了，例如：</p>

<pre><code>$ git cat-file -p 4b5c03ea81e0e24714bea66de3892a40165fe56f
</code></pre>

<p>或是</p>

<pre><code>$ git cat-file -p 4b5c03
</code></pre>

<p>就會把上面那個 object 的內容印出來：</p>

<pre><code>tree 96602375208c5d4f028bdbcd7873f049a70d9287
parent 280142567c56235af3fc7c35513edeb978c1b465
author othree &lt;othree@gmail.com&gt; 1429321581 +0800
committer othree &lt;othree@gmail.com&gt; 1429321581 +0800

Use same name in node and global module
</code></pre>

<p>這就是一個 commit 的內容，記錄了現在這個 commit 的檔案狀態（tree）、上一個 commit（parent）、還有作者、提交者及 commit message，要把工作目錄的內容抓出來會需要的是 tree，後面的值也是一個 object hash，所以就來看看內容吧：</p>

<pre><code>100644 blob 31843d5c03e1a3a0618b40bdd2034b0c492f2132    .gitignore
100644 blob 20fd86b6a5bee335c75b4efea34312ff7f3a039e    .travis.yml
100644 blob fd7bce4d5095540e4cb83f56276b9cd831f9ec76    DOC.md
100644 blob 3c983c1efb8ab258bca8b7a0aed13bd97cf1b47f    LICENSE
100644 blob c11ab5fc05c2cc398f2be094451f34bf428e0a9e    Makefile
100644 blob fa3477c3305c08116408aea0ad30520627598804    README.md
040000 tree 61cc224cb5de89713ac3bdaddc7835ec2dbea129    dist
100644 blob 3ceec31471c4e4d8e38e0f0e506762feda7b852c    package.json
040000 tree 48614476be4f27aad0137d57170852a9d5bdd227    src
040000 tree 05181d9234207ffcc34e0bc4574bd9fb4e3210ad    test
</code></pre>

<p>很容易可以理解這個內容的意思，它其實就是這個 commit (HEAD)，根目錄下的檔案和目錄，分成四個 column 紀錄，第一欄是檔案權限、第二欄是 object type，第三欄是 hash，最後一欄是檔案/目錄名稱，其中的 object type 如果是 <code>tree</code> 就是子目錄，<code>blob</code> 就是檔案，然後每一筆資料都透過 hash 指引到一個 object 檔案，如果是 tree  object 就會看到一樣結構的內容，如果是 blob object 就是該檔案本身，所以就可以透過遞迴操作來把整個工作目錄取出（這是我理解 git 資料結構後認為的作法，不是去看 git 原始碼得知的）。</p>

<p>再回到前面的 commit object，裡面的 parent 屬性就是唯一可以連結每個 commit 之間關係的屬性，如果是 merge point 則會有多個 parent，例如 <a href="https://github.com/othree/taipei-mrt">taipei-mrt</a> 中的南京復興站：</p>

<pre><code>$ git cat-file -p f747e466dd826ff6b81550505412f7bf4875fd68

tree d6d7e908638af9bb8759870723c0c6deed174faf
parent 460ff499e9917051e747a5305daa19bcd80a86ea
parent 5f913238492d3b8ea5a15893b463492681ae59ff
author othree &lt;othree@gmail.com&gt; 1455717204 +0800
committer othree &lt;othree@gmail.com&gt; 1455717204 +0800

南京復興
</code></pre>

<p>所以可以理解的是，git 不是紀錄每個 commit 間的 diff，而是記錄每個 commit 的狀態，然後 commit 間的關係只能透過 parent 來連接，是個單向的關係，每個 commit 都只能往上尋找自己的祖先，沒辦法從 commit 連結到自己的子孫，而這個單向的關係，也影響了 branch 的定義。</p>

<p>Git 的 branch 嚴格說起來，其實只是進入 commit tree 的入口，一開始預設只有 master branch 這個入口，就如同上面介紹要怎麼把工作目錄的資料抓出來時一樣，git 會先去看 <code>.git/HEAD</code>，HEAD 是一個特殊的參考（reference），預設會指到 master branch，上面介紹時，master branch 的 reference 檔案位置在 <code>.git/refs/heads/</code>，事實上，所有的 branch 的 reference 都在這個位置：</p>

<pre><code>$ ll .git/refs/heads/

total 72
drwxr-xr-x  11 othree  staff  374 Sep 10 00:02 .
drwxr-xr-x   5 othree  staff  170 Feb 15  2016 ..
-rw-r--r--   1 othree  staff   41 Aug 14 23:45 blue
-rw-r--r--   1 othree  staff   41 Sep 10 00:02 brown
-rw-r--r--   1 othree  staff   41 Feb 16  2016 green
-rw-r--r--   1 othree  staff   41 Feb 15  2016 green-a
-rw-r--r--   1 othree  staff   41 Feb 15  2016 orange
-rw-r--r--   1 othree  staff   41 Sep 10 00:02 orange-a
-rw-r--r--   1 othree  staff   41 Sep  9 00:06 orange-b
-rw-r--r--   1 othree  staff   41 Sep 10 00:02 red
-rw-r--r--   1 othree  staff   41 Sep 10 00:02 red-27
</code></pre>

<p>每個檔案內容都是一個 commit hash：</p>

<pre><code>$ cat .git/refs/heads/*

1873fddf2b760cbb753f6d81076e50a079acd687
1873fddf2b760cbb753f6d81076e50a079acd687
91631c62df972ee49f7699eb6b15cbda913f50e3
a245d40e28f75e3bed1b7a8d726906eb230bd6fe
f861f243e367c15b681919ebc2b1d9d9ceccde17
e73351a53945ebb3fcf0f9bbc078969bdb6dc29b
c13ea61e77de42bc579ecf2a1cf32aa2a4a9d6e0
9ad00b514fccdec7f7f5bb0a91e6d5cb678c2a6f
99e31bceea7e9446e37603c00cafa04f8c4827a2
</code></pre>

<p>有這些入口後，就可以進到編輯歷史裡，然後透過每個 commit 的 parent 來串連起 branch 的修改歷史。事實上這種設計並沒有限制 branch 之間一定要有相連，所以就有了可以完全獨立的 <a href="https://ihower.tw/blog/archives/5691">orphan branch</a>，最常見被用來做 <a href="https://pages.github.com/">Github Pages</a>，也可以用來放一些相關的資料，不過實務上，會需要放相關資料在 repository 李的話，通常會在根目錄先建立好不同用途的子目錄，不然要查詢時還要切換 branch 實在也不方便，不過要畫捷運路網時， orphan branch 卻是幫助很大，可以簡單的建立不同路線的起點。</p>

<p>在瞭解 branch 之後，就可以來用 Git 線圖建立路網的交錯了，其實原理很簡單，就是先把兩個分支 branch merge 起來，並且讓兩個 branch 都指向到同一個 merge commit 上，作法就是兩個 branch 互相 merge：</p>

<pre><code>git merge orphan --allow-unrelated-historie
git co orphan
git merge master --allow-unrelated-historie
</code></pre>

<p>在 Git 2.9 之後需要加上 <code>--allow-unrelated-historie</code> 這個參數，第一個 merge 完成會變這樣：</p>

<pre><code>M─┐ [master] Merge branch 'orphan'
│ I [orphan] Commit B
I Commit A
</code></pre>

<p>第二個 merge 會是 fast-forward ，然後結果就變成：</p>

<pre><code>M─┐ [orphan] [master] Merge branch 'orphan'
│ I Commit B
I Commit A
</code></pre>

<p>可以看到兩個 branch 現在都指向到同個 commit 了，然後分別在兩個 branch 建立新的 commit，就可以分支成兩條線出去了：</p>

<pre><code>o [orphan] Commit D
│ o [master] Commit C
M─┘ Merge branch 'orphan'
│ I Commit B
I Commit A
</code></pre>

<p>不過由於 Git 的歷史紀錄只能靠 parent 屬性建立，branch 也只是一個進入編輯歷史的入口，所以追塑到 merge commit 後，就無法分辨更之前的 commit 是屬於那個 branch 了，我的 MRT 線圖也是如此，其實只能維持到 topology 正確，而沒辦法讓所有的 commit 都能分辨出來是哪條線的。</p>

<p>第二個要說的則是 <code>git log</code> 的部分，當天的分享有講到用 <a href="https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html#_specifying_ranges">git log range</a> 來查詢捷運路線，主要用的是 <code>A..B</code> 和 <code>A...B</code>，其實在一般只有一條線的情形下用，<code>..</code> 和 <code>...</code> 都可以用來擷取 A 和 B 兩個 commit 中間的變化，但是用來查捷運路線，就會發現很多時候結果不如預期，事實上，這兩個 syntax 都有其代表的邏輯操作，如同上面所說，git 歷史的記錄只能靠 parent 來建構起來，一般的 <code>git log</code> 就會從 HEAD 指到的 commit 開始，透過 parent 屬性，把所有可以連結到的 commit 都列出來，而 <code>E..B</code> 的意思，則是從 E 開始，列出所有 E 能連結到的 commit，但是不列出 B 能連結到的 commit，只有一條線的情境來看：</p>

<pre><code>E-D-C-B-A
</code></pre>

<p>E 能連結到的包括了：</p>

<pre><code>E-D-C-B-A
  ^ ^ ^ ^
</code></pre>

<p>B 能連結到的包括了：</p>

<pre><code>E-D-C-B-A
        ^
</code></pre>

<p>把上面的扣掉下面的就變成：</p>

<pre><code>E-D-C-B-A
  ^ ^ ^
</code></pre>

<p>看起來就剛好是 B 到 E 中間的變化歷程，至於 <code>...</code> 又有點不同，它的定義是列出所有 B 和 E 可以到達的 commit，但是不列出兩者都可以到達的 commit，單一條線的時候，結果會和 <code>..</code> 是一樣的，所以差異是在有分支的情形才會出現，舉例來說：</p>

<pre><code>o [master] &lt;E&gt; Commit E
│ o [orphan] &lt;F&gt; Commit F
│ o Commit D
o │ Commit C
M─┘ Merge branch 'orphan'
│ I Commit B
I Commit A
</code></pre>

<p>如果用 <code>...</code> 看 E 到 F 的話：</p>

<pre><code>$ git log E...F --oneline --graph

* 8d6c4d5 Commit E
* d2f593f Commit C
* f4dad66 Commit F
* c3ac3ca Commit D
</code></pre>

<p>就可以達成類似從 E 站到 F 站的效果，不過由於 Merge commit 是兩邊都可以到達的 commit，所以不會出現，另外就是出現的順序不會正確。所以我在未來發展那邊有提到可以開發一個工具來專門查詢捷運路線，大概要用的方法就是要從每個 branch 進去找，然後還要尋找 merge commit，再從 merge commit，實際上還要仔細想想才能確定查詢的流程就是。</p>

<p>以上就是這次學習到的 git 相關知識，當時投影片上寫著下略五千字，沒想到寫起來真的蠻多的，這篇文章的字數統計還真的有達標。</p>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000874" baseName="input-event">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-09-11</b:date>
				<b:time>00:21:40</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>Input Event</b:title>
			<b:content>
				<b:summary> 今天做了一個特殊的 input 欄位，其實目標只是做成類似像輸入信用卡號那樣，輸入 1234 完，準備要輸入 5 的時候，會在 4 後面補上一個 -，變成 1234-5，不過我預期做的完美一點，所以考慮了很多狀況，例如： 複製貼上沒有 - 的資料後會自動格式化 已經輸入一部分資料後，游標移到前面插入資料也會正確格式化 直接用 DEL 或 Backspace 來刪除資料，要讓使用者感覺不到 - 先選取一些字元然後用 DEL 或 Backspace 甚至是剪下來刪除資料後會重新格式化 以上幾種操作都不會讓游標亂跳 簡單看過目前一些信用卡相關的 library，在卡號輸入的部分是沒有全部達到的，要達成這些目標，幾乎是等於每個使用者的操作都要攔截下來，然後要抓到當欄位內的值，會用到的事件包括了 keyup、keydown、paste 和 input，等，其中本來我對於一般使用者敲打鍵盤輸入的事件是用 keyup，keyup 事件後會判斷游標位置和輸入的內容，如果需要的話就加上 -，然後調整游標位置，通常是 +1，弄好後測試一陣，發現如果按鍵輸入很快的話，游標位置會亂掉，應該要 +1 的卻錯過了，深入除錯一陣子之後發現，keyup 事件其實和欄位內的...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/acerriteno/4111105424/" title="Playtime Credit Card by Alberto+Cerriteño, on Flickr"><img src="https://farm3.staticflickr.com/2487/4111105424_0fbd64cbd9_z.jpg?zz=1" width="640" height="427" alt="Playtime Credit Card, " srcset="https://farm3.staticflickr.com/2487/4111105424_0fbd64cbd9_z.jpg?zz=1 640w" /></a></p>

<p>今天做了一個特殊的 input 欄位，其實目標只是做成類似像輸入信用卡號那樣，輸入 <code>1234</code> 完，準備要輸入 <code>5</code> 的時候，會在 <code>4</code> 後面補上一個 <code>-</code>，變成 <code>1234-5</code>，不過我預期做的完美一點，所以考慮了很多狀況，例如：</p>

<ul>
<li>複製貼上沒有 <code>-</code> 的資料後會自動格式化</li>
<li>已經輸入一部分資料後，游標移到前面插入資料也會正確格式化</li>
<li>直接用 <code>DEL</code> 或 <code>Backspace</code> 來刪除資料，要讓使用者感覺不到 <code>-</code></li>
<li>先選取一些字元然後用 <code>DEL</code> 或 <code>Backspace</code> 甚至是剪下來刪除資料後會重新格式化</li>
<li>以上幾種操作都不會讓游標亂跳</li>
</ul>

<p>簡單看過目前一些信用卡相關的 library，在卡號輸入的部分是沒有全部達到的，要達成這些目標，幾乎是等於每個使用者的操作都要攔截下來，然後要抓到當欄位內的值，會用到的事件包括了 keyup、keydown、paste 和 input，等，其中本來我對於一般使用者敲打鍵盤輸入的事件是用 keyup，keyup 事件後會判斷游標位置和輸入的內容，如果需要的話就加上 <code>-</code>，然後調整游標位置，通常是 +1，弄好後測試一陣，發現如果按鍵輸入很快的話，游標位置會亂掉，應該要 +1 的卻錯過了，深入除錯一陣子之後發現，keyup 事件其實和欄位內的 value 變更是非同步的，所以不能確保 keyup 事件拿到的欄位值是正確的，能確保欄位值正確的，其實是 <a href="https://developer.mozilla.org/zh-TW/docs/Web/Events/input">input 事件</a>，不過 input 事件沒有 keyCode，所以只能自己判斷輸入了什麼，另外刪除內容時也不會觸發 input，還好 <code>DEL</code> 和 <code>Backspace</code> 是用 keydown 事件來處理，兩邊剛好錯開了。</p>

<p>雖然 input 事件似乎很好用，不過其實它在早期的時候支援度是不太好的，算是比較新的事件，有類似狀況的還有一個是 change 事件，我的印象中是某些瀏覽器的行為會不太正確，所以其實我一直都還不太使用，至於 input 事件，我則是需要在不支援的瀏覽器中 fallback 到 keyup 事件，所以就會需要偵測，找了一下在 Modernizr 有<a href="https://github.com/Modernizr/Modernizr/blob/master/feature-detects/event/oninput.js">支援</a>，仔細看一下內容其實可以發現不是很好偵測，然後我也不是很喜歡 Modernizr 的介面，所以目前用的是在 Modernizr <a href="https://github.com/modernizr/modernizr/issues/210#issuecomment-1325576">Issue 210</a> 裡面 AndyE 提供的版本，稍微精簡一些：</p>

<pre><code>var inputSupport = "oninput" in document.body || checkEvent(document.body);
/*
   The following function tests an element for oninput support in Firefox.  Many thanks to
        http://blog.danielfriesen.name/2010/02/16/html5-browser-maze-oninput-support/
*/
function checkEvent(el) {
    // First check, for if Firefox fixes its issue with el.oninput = function
    el.setAttribute("oninput", "return");
    if (typeof el.oninput == "function")
        return true;

    // Second check, because Firefox doesn't map oninput attribute to oninput property
    try {
        var e  = document.createEvent("KeyboardEvent"),
            ok = false,
            tester = function(e) {
                ok = true;
                e.preventDefault();
                e.stopPropagation();
            }
        e.initKeyEvent("keypress", true, true, window, false, false, false, false, 0, "e".charCodeAt(0));
        document.body.appendChild(el);
        el.addEventListener("input", tester, false);
        el.focus();
        el.dispatchEvent(e);
        el.removeEventListener("input", tester, false);
        document.body.removeChild(el);
        return ok;
    } catch(e) {}
}
</code></pre>

<p>測試困難的主因是 Firefox 4 有 bug，所以需要真的建立一個 input 元件，然後用完整模擬 input 事件。然後雖然這個版本的比較精簡好懂，不過之後還是會因為 license 的關係改用 Modernizr 的版本吧。至於我做的 input field 呢，現在當然還是公司資產，大概要等我有空在假日重寫一個 Credit Card 的版本才會放出來吧。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000873" baseName="modern-html-email-develop">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-08-25</b:date>
				<b:time>23:12:54</b:time>
			</b:datetime>
			<b:category>css-html</b:category>
			<b:title>Modern HTML Email Development</b:title>
			<b:content>
				<b:summary>今天在 Modern Web 分享的主題 其實最主要是想介紹 MJML 這個工具，不過最後介紹的篇幅有些不夠，有些可惜，話說今天設備也有些狀況，一是投影機解析度和預期的不一樣，二是無線麥克風聲音會延遲，對於講者來說還蠻干擾的，最後時間還剩的比預期多，覺得愧疚啊。 最後附上這次介紹的一些資源的連結，方便取用： Email Marketing Reactions List of mso attributes Coding Mobile First Emails The Ultimate Guide to CSS Will It Work The Email Design Conference Innovations in Email Design Email Client Market Share...</b:summary>
				<b:mainContent><p>今天在 Modern Web 分享的主題</p>

<script async="async" class="speakerdeck-embed" data-id="17350d3dd0d14841ba8dd055400bd96f" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"><!-- A_A --></script>

<p>其實最主要是想介紹 <a href="https://mjml.io/">MJML</a> 這個工具，不過最後介紹的篇幅有些不夠，有些可惜，話說今天設備也有些狀況，一是投影機解析度和預期的不一樣，二是無線麥克風聲音會延遲，對於講者來說還蠻干擾的，最後時間還剩的比預期多，覺得愧疚啊。</p>

<p>最後附上這次介紹的一些資源的連結，方便取用：</p>

<ul>
<li><a href="http://emailmarketingreactions.tumblr.com/">Email Marketing Reactions</a></li>
<li><a href="https://stackoverflow.com/questions/14376783/list-of-mso-attributes">List of mso attributes</a></li>
<li><a href="https://medium.com/cm-engineering/coding-mobile-first-emails-1513ac4673e#.ksru1wvbm">Coding Mobile First Emails</a></li>
<li><a href="https://www.campaignmonitor.com/css/">The Ultimate Guide to CSS</a></li>
<li><a href="https://www.campaignmonitor.com/dev-resources/will-it-work/">Will It Work</a></li>
<li><a href="https://litmus.com/conference">The Email Design Conference</a></li>
<li><a href="https://www.dropbox.com/s/qkh68xkz3vp5yvr/eis-design-innovation.pdf?dl=0">Innovations in Email Design</a></li>
<li><a href="https://emailclientmarketshare.com/">Email Client Market Share</a></li>
</ul>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000872" baseName="json-web-token">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2016-08-13</b:date>
				<b:time>18:46:54</b:time>
			</b:datetime>
			<b:category>server</b:category>
			<b:title>JSON Web Token</b:title>
			<b:content>
				<b:summary> 之前的 JSON Universe 那篇文章在寫的時候，還沒發現到有這東西，直到上個月才發現到 JSON Web Token(JWT) 這個標準，研究過後覺得要單獨介紹一下，不過由於相關的標準有好幾個，花了些時間才搞清楚各個標準之間的關係；這一系列標準是由 JOSE(JSON Object Signing and Encryption) Working Group 所制訂的 RFC 標準，目前包括了： JSON Web Signature JSON Web Encryption JSON Web Key JSON Web Algorithms JSON Web Token 共五個 RFC 標準，事實上，JSON Web Token 是要最後談到的；這一系列標準的目的是提供一個標準的協定，用在傳輸...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/14015411664/" title="大丸百貨 by othree, on Flickr"><img src="https://farm3.staticflickr.com/2895/14015411664_8cebe3a88c_b.jpg" width="1024" height="683" alt="大丸百貨" srcset="https://farm3.staticflickr.com/2895/14015411664_8cebe3a88c_b.jpg 1024w, https://farm3.staticflickr.com/2895/14015411664_aa01b9bc05_h.jpg 1600w" /></a></p>

<p>之前的 <a href="https://blog.othree.net/log/2016/01/11/json-universe/">JSON Universe</a> 那篇文章在寫的時候，還沒發現到有這東西，直到上個月才發現到 <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a>(JWT) 這個標準，研究過後覺得要單獨介紹一下，不過由於相關的標準有好幾個，花了些時間才搞清楚各個標準之間的關係；這一系列標準是由 <a href="https://datatracker.ietf.org/wg/jose/charter/">JOSE(JSON Object Signing and Encryption) Working Group</a> 所制訂的 RFC 標準，目前包括了：</p>

<ul>
<li><a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature</a></li>
<li><a href="https://tools.ietf.org/html/rfc7516">JSON Web Encryption</a></li>
<li><a href="https://tools.ietf.org/html/rfc7517">JSON Web Key</a></li>
<li><a href="https://tools.ietf.org/html/rfc7518">JSON Web Algorithms</a></li>
<li><a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a></li>
</ul>

<p>共五個 RFC 標準，事實上，JSON Web Token 是要最後談到的；這一系列標準的目的是提供一個標準的協定，用在傳輸 JSON 資料時提供可靠性（簽章、signature）和安全性（加密、encryption），眼尖的人可能發現了，怎麼沒有 JOSE 的文件呢？事實上是真的沒有，而且也沒官方文件清楚解釋 JOSE 到底是什麼，最常看到的詞就是 JOSE Header 了，思考許久後才理解，JOSE 其實包括了兩種格式，分別是 JSON Web Signature(JWS) 和 JSON Web Encryption(JWE)，JWS 只是加上驗證用的簽章，其實內容是明碼的，JWE 才是真的有把傳輸的資料加密過，至於簽章和加密用的演算法則是用 JWA 格式來紀錄，然後需要用到的 key，例如用非對稱加密保護加密內容的 key 給收信端，這時則是用 JWK 格式來記錄要使用的 public key，而這些資訊就是 JOSE Header 的內容了，JWK 和 JWA 都是很簡單的格式，基本上就是一個物件，然後有定義好的屬性：</p>

<pre><code>{
  "kty":"EC",
  "crv":"P-256",
  "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU",
  "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0",
  "kid":"Public key used in JWS spec Appendix A.3 example"
}
</code></pre>

<p>例如這個 JWK 文件範例中的 <code>kty</code> 代表的是 Key Type；<code>crv</code>、<code>x</code> 和 <code>y</code> 則是橢圓曲線加密（ECC）類演算法會用到的參數；<code>kid</code> 則是自訂的 Key ID，用來在一堆 JWK 當中尋找所要的 key 使用；其它還有像是 X.509 憑證驗證會需要的資訊，各種加密演算法會用到的 Initialization Vector、Salt 等，都有定義好的屬性名稱。</p>

<p>JWS 和 JWK 就比較複雜些了，以 JWS 來說，你會先有要傳輸的資料 payload，然後一組 meta data，又稱為 JOSE Header，內容基本上就是 JWA + JWK + 一些基本的屬性，像是 <code>cty</code>、<code>typ</code>：</p>

<pre><code>{
  "typ":"JWT",
  "alg":"HS256"
}
</code></pre>

<p>這就是一個最簡單的 JOSE Header，它說明傳輸的資料內容和簽名用的 HMAC 演算法，然後這個 JOSE Header 和 payload 要分別轉成 <a href="https://tools.ietf.org/html/rfc7515#appendix-C">base64url</a> 編碼，其實和 base64 沒差很多，就先把 JSON String 轉成 base64 encoding string 後，把 padding 的 <code>=</code> 都拿掉，然後 <code>+</code> 用 <code>-</code> 取代，<code>/</code> 用 <code>_</code> 取代。例如 <code>ab?ab</code> 這個 ASCII 字串，用 base64 encoding 就會變成：</p>

<pre><code>YWI/YmE=
</code></pre>

<p>用 base64url 的話就變成：</p>

<pre><code>YWI_YmE
</code></pre>

<p>然後現在我們有一個 JOSE Header 和一個要傳輸的 JSON payload，以 base64url 編碼呈現並且用 <code>.</code> 接起來：</p>

<pre><code>BASE64URL(UTF8(JOSE Header)) || '.' || 
BASE64URL(JWS Payload))
</code></pre>

<p>接著把這個字串拿去用 JOSE Header 裡面指定的 HMAC 演算法搭配一組 key 來算出簽章（signature），至此我們就有了 JWS 三樣必須的元素了：</p>

<ul>
<li>JOSE Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>

<p>JWS 文件中定義了兩種格式可以用來傳輸這三個元素，第一種是精簡格式（Compact Serialization Syntax），格式很簡單，就和上面算 signature 用的格式一樣，只是現在多加了 signature 在後面，一樣用 base64url 形式：</p>

<pre><code>BASE64URL(UTF8(JWS Protected Header)) || '.' ||
BASE64URL(JWS Payload) || '.' ||
BASE64URL(JWS Signature)
</code></pre>

<p>長的會看起來像是：</p>

<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>

<p>另外一種則是 JSON 格式（JSON Serialization Syntax）：</p>

<pre><code>{
  "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
  "signatures":[
     {"protected":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
      "signature":"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"}]
}
</code></pre>

<p>這種形式其實是最完整的版本，還可以加上 public header （沒 signature 驗證）和多個 signature；另外也有 flatten 版，只能放一個 signature：</p>

<pre><code>{
  "payload":"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9",
  "protected":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
  "signature":"TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"
}
</code></pre>

<p>雖然有 JSON 格式的 JWS，不過 精簡格式目前應該是最廣為通行的，一來是它資料量比較小，二是它比較方便在不同環境下傳輸使用，例如後面會提到的，放在 HTTP Header 內，如果沒有特殊需求要多個 signature，實在很沒有用 JSON 格式的需求。</p>

<p>最後，JWS 還有一個特殊的 case，就是它其實允許不加上簽章的，使用這組 JOSE Header：</p>

<pre><code>{"alg":"none"}
</code></pre>

<p>然後 signature 是空字串，所以精簡格式的就會變成：</p>

<pre><code> eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
</code></pre>

<p>最後是 <code>.</code> 結尾。</p>

<p>JWE 和 JWS 的狀態其實也很像，只是三個元素變成五個，包括了:</p>

<ul>
<li>JOSE Header</li>
<li>Encrypted Key</li>
<li>Initialization Vector</li>
<li>Ciphertext</li>
<li>Authentication Tag</li>
</ul>

<p>其中 JOSE Header 和 JWS 的內容差不多，Encrypted Key 和 Initialization Vector(IV) 是加密時的輸入，這邊的 Encrypted Key 是一把加密過的 Key，被加密保護的 Key 又稱為 Content Encryption Key(CEK)，是實際上用來加密保護內容時所使用的 Key，這把 CEK 和 IV 都是亂數產生的，那又有一個問題是，用什麼 Key 加密 CEK 來產生 Encrypted Key 呢？這邊建議的是用非對稱加密，拿收信方的 public key 來加密，當然 JOSE Header 裡面也可以塞進 x.509 的相關資訊用來確保 public key 的正確性；最後兩個，Ciphertext 和 Authentication Tag 則是加密的輸出，Authentication Tag 是 authentication encryption 會產生的，用來驗證內容正確性的資訊，就像是 JWS 的 signature 一樣用途，主要也是避免 Ciphertext 被用中間人攻擊替換掉，不過我還不太清楚如果可以偷到 key 偽造出 Ciphertext，是怎樣會沒法同時有另外一組 Authentication Tag 就是了。</p>

<p>然後一樣有精簡格式和 JSON 格式，精簡格式看起來就如下：</p>

<pre><code> eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6jiSdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ
</code></pre>

<p>注意找的話就可以發現四個 <code>.</code> 把資料切成五段。</p>

<p>最後終於要來介紹 JSON Web Token（JWT）了，JWT 是什麼呢，它其實就是一個 JOSE 的應用，一句話來說，就是使用 JWS 或 JWE 來做現在網路服務的身分認證協定中常見的 token（權杖）的傳遞。所以 JWT 其實就是規範了一組 JSON 資料的屬性（claim），和身分認證相關，然後要求這個 JSON 資料要用 JWS 或 JWE 來傳輸提供保護，這些預先定義好的屬性有：</p>

<ul>
<li><code>iss</code>, Issuer</li>
<li><code>sub</code>, Subject</li>
<li><code>aud</code>, Audience</li>
<li><code>exp</code>, Expiration Time</li>
<li><code>nbf</code>, Not Before</li>
<li><code>iat</code>, Issued At</li>
<li><code>jti</code>, JWT ID</li>
</ul>

<p>都是非常 meta 的 token 屬性，這些名稱基本上是從 <a href="http://openid.net/specs/openid-connect-core-1_0.html#IDToken">OpenID Connect</a> 那邊來的，除了這些定義好的屬性之外，還可以加上其它自訂的資料，只是這些已經被定義且<a href="http://www.iana.org/assignments/jwt/jwt.xhtml">註冊</a>好的名稱不能另做他用，OpenID Connect 也有不少個人資料的屬性已經註冊上 IANA 了，像是 <code>first_name</code>、<code>country</code> 之類的 profile 資訊，有一種使用 JWT 的方法就是直接把個人 profile 存在客戶端，server 只要驗證簽名是否正確，這樣一個好處是 server 不用保存 session 資訊，減少很多資源的需求，實做起來其實複雜度也比較低。另外由於是用作 token 之用，自然也可以當成 OAuth 的 token 使用，這部分資訊在 <a href="https://tools.ietf.org/html/rfc7523">RFC-7523</a> 這份文件有說明，至於要如何使用 OAuth token 則是在 <a href="https://tools.ietf.org/html/rfc6750">RFC-6750</a> 有介紹，比較常見的是放在 HTTP Auth Header 裡面：</p>

<pre><code>Authorization: Bearer eyJhbGciOiJub25lIn0.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
</code></pre>

<p>之前鴨七也有整理過中文的<a href="https://blog.yorkxin.org/2013/09/30/oauth2-6-bearer-token">說明</a>，看起來比較輕鬆，而且說明很完整（不過我承認我沒有從頭看到尾）。</p>

<p>目前搜尋 JWT 一定會看到一個網站 <a href="https://jwt.io/">jwt.io</a>，這個網站用淺顯易懂的方式來<a href="https://jwt.io/introduction/">介紹</a> JWT，把比較複雜的關係，像是 JWS、JWE 等等都隱藏起來幫助瞭解，還有一個線上除錯工具和不同語言的 library 整理，不過除錯工具只有支援 JWS，另外也有和一些其它類似標準做比較，還蠻值得看一看的，這個網站是由 <a href="https://auth0.com/">Auth0</a> 提供的，他們其實就是一家專門提供身分認證服務的公司，似乎都已經轉到使用 JWT 了，在 jwt.io 有提到他們似乎是把他用作 stateless 的 token 來用，我對這間公司之前印象是還不錯，一來是 API 文件看起來還蠻不錯的，另外有不少的開放原碼<a href="https://auth0.com/opensource">專案</a>，當然有一些是串接他們家服務用的 library 啦。</p>

<p>PS. 對密碼學還沒很熟悉，有誤歡迎指正～</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
