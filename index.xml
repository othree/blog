<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/main.xsl"?>
<b:blog xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://blog.othree.net" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://blog.othree.net http://blog.othree.net/blooog.xsd">
	<b:blogTitle>O3noBLOG</b:blogTitle>
	<b:blogDescription></b:blogDescription>
	<b:entries>
		<b:entriesMeta>
			<b:listType>i</b:listType>
			<b:listData listID="index"/>
		</b:entriesMeta>

		<b:entry entryID="000838" baseName="ecmascript-6-final-draft">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-03-30</b:date>
				<b:time>18:34:07</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>ECMAScript 6 Final Draft Approved</b:title>
			<b:content>
				<b:summary>Ecma-TC39 just approved the final ES6 draft. It now goes to the Ecma General Assembly for approval in June- Allen Wirfs-Brock (@awbjs) 2015 3月 24日...</b:summary>
				<b:mainContent><blockquote class="twitter-tweet" lang="zh-tw"><p>Ecma-TC39 just approved the final ES6 draft. It now goes to the Ecma General Assembly for approval in June</p>- Allen Wirfs-Brock (@awbjs) <a href="https://twitter.com/awbjs/status/580321916403216384">2015 3月 24日</a></blockquote>

<script async="async" src="//platform.twitter.com/widgets.js" charset="utf-8"><!-- --></script>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000837" baseName="for-the-entire-web">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-03-28</b:date>
				<b:time>13:25:25</b:time>
			</b:datetime>
			<b:category>web</b:category>
			<b:title>For the Entire Web</b:title>
			<b:content>
				<b:summary>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實是根本上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 React Is A Terrible Idea，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。 再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和...</b:summary>
				<b:mainContent><p>這陣子有兩件事情引起我的一些注意，覺得值得寫下，兩件事情我覺得其實是根本上是同一件事情，先來看一下第一件事情，就是 Daniel Yoder 寫了篇文章 <a href="https://www.pandastrike.com/posts/20150311-react-bad-idea">React Is A Terrible Idea</a>，這篇文章在 React 當紅的時間出現，自然引起很多人的不滿，隨便在 Google 上搜尋就可以找到一堆回應，我自己對於 React 其實是沒特別感覺，沒有喜歡也沒有覺得它做錯什麼，真的要說的話大概還有點覺得它方向正確，我是認為 React 和 Angular 的 directive 都在把 component 的觀念引入前端工程師的視野之中，而這對於 Web Component 的發展應該會是有正面影響的。</p>

<p>再回到 Terriable Idea 這篇文章，作者對 React 的評論我其實不完全認同，最後面有提到用 Web Component 而不要用 React，這部分我覺得是作者誤會了 React 的角色，不過有些地方有人說 React 明明就可以和 Web Component 合作，還附上 ng-conf 的<a href="https://www.youtube.com/watch?v=g0TD0efcwVg">演講影片</a>，我到覺得他們也完全沒搞清楚作者的重點在哪裡；提到 Flipboard 的 <a href="https://github.com/flipboard/react-canvas">react-canvas</a> 那部分算是我認為最能表現出作者想要講什麼的，作者想說的重點是現在的網路環境有限制、有問題，但是遇到時不要用一些旁門左道的方法來處理，因為這些問題終究會被解決，而問題被解決時，你之前所花的時間和資源就等於是完全浪費掉，與其要浪費在走旁門左道，還不如把這些時間和資源用在從正確的地方解決這個問題，而最後受惠的不只是自己，還有所有網際網路的開發者、使用者，這是從一個很高等生命體的角度來看事情，就如同這篇文章的標題：「For the Entire Web」，要你犧牲自己的部分利益去成就整體網際網路的利益，當然這是有些理想化，很多商業公司可能要短時間就有產品出來，不太可能所有的開發在遇到問題時都停下來等瀏覽器或是標準齊備，但是對於不少的大型企業，我就覺得他們確實應該要好好正確的回饋網路環境來解決這些問題，像是文中提到 Facebook，還有接下來要說的 Google，不過他說 Facebook 是為了和 Google 競爭才開發 React 之類的論點我就不予評論了，太多臆測～</p>

<p>可能有人會說，有沒有這些資源的投入應該差距也不大吧，最近就剛好有另外一件事情可以佐證，<a href="http://news.dartlang.org/2015/03/dart-for-entire-web.html">Dart for the Entire Web</a> 這篇 Dart 官方的公告說到，Dart VM 將不會進入到 Chrome 裡面，也就是說要在瀏覽器上跑 Dart，將還是只有轉成 JavaScript 這個選項，這件事其實是蠻大的一件事，上一個在網頁裡面跑的另外一種語言是微軟的 VBScript，最大的問題不在於好不好寫，而是在於他被單一企業把持，不過後來結果大家也都知道，所以當 Google 推出 Dart 而且說以後 Chrome 會可以直接跑 Dart 的時候，我想大部分人都是都不看好的，甚至部分人是覺得 Google 怎麼為做微軟做過的蠢事。而剛好在這個官方公告出來後幾天內，Brendan Eich 在 Hacker News 上回應一串討論<a href="https://news.ycombinator.com/item?id=9269355">回應</a>的蠻激動的，這串本來是在說 ECMAScript 新版本有很多東西根本是從 Dart 來的，Brendan Eich 則是反駁說很多東西在 Dart 出來前就已經在討論有 Proposal 了，然後到後來寫了一篇幾乎都在抱怨 Dart，還提到 V8 team reset 的事情，從這邊看起來，似乎是因為新的 V8 team 不打算作 Dart VM 進去，才有了 Dart 那篇公告；而 Brendan Eich 抱怨的重點，其實就是前面那段提到的，Google 花了超多人力資源去搞 Dart，而不是來幫忙改進既有的 ECMAScript，而這確實有實際的影響，他舉了一個例子，就是大數(<a href="http://wiki.ecmascript.org/doku.php?id=strawman:bignums">bignums</a>)的支援，Dart 有支援，在 ES 這邊目前有一點可能性會在 ES7(2016) 中出來，但這東西其實從 2010 就已經開始有討論了，如果有人來將這些討論規格化，並實做起來，那大數應該在現在的 ES6(2015) 就有了。</p>

<p>最後再回到 Terriable Idea 這篇文章，我雖然不完全認同他對 React 的看法，但是我認為他的重點沒錯，如果他拿 Dart 出來講可能就不會引出這麼多砲火吧（可是可能也比較沒人注意），其實 react-canvas 我覺得也是很有趣的實驗，不過做成正式產品上線就是另外一回事了，最大的問題，他完全放棄了親和力的問題，而 Flipboard 這種內容為主的產品性質是不該放棄親和力的。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000836" baseName="vim-syntax-regexp-note">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-03-18</b:date>
				<b:time>18:45:07</b:time>
			</b:datetime>
			<b:category>vim</b:category>
			<b:title>Vim Syntax and Regexp Note</b:title>
			<b:content>
				<b:summary>前陣子為了寫更好的 Vim syntax 還去學了 compiler 的課程，雖然沒上完不過也對怎麼解析語法理解不少，不過其實 Vim syntax highlight 系統為了效能問題，有不少限制，沒辦法真的和 compiler 的 parse 原理完全互通，其中兩個限制影響比較大，第一個是沒辦法有完整的 AST 並解析其語意，因此除非寫得非常繁複，一定會有無法正確 highlight 的地方，例如 comment，不是說 comment 不能正確標示，問題是 comment 可以插入在很多地方，像是參數序列的中間，function 關鍵字和後面 () 的中間等等，幾乎是可以放空白字元的地方就可以放 comment，然後不會影響程式語意，本來，不考慮註解時，我可以用 skipwhite、skipempty 然後加上 nextgroup 就可以指定下一個 token 是什麼，以 JavaScript function declaration 來說： function fn (a)...</b:summary>
				<b:mainContent><p>前陣子為了寫更好的 Vim syntax 還去學了 compiler 的課程，雖然沒上完不過也對怎麼解析語法理解不少，不過其實 Vim syntax highlight 系統為了效能問題，有不少限制，沒辦法真的和 compiler 的 parse 原理完全互通，其中兩個限制影響比較大，第一個是沒辦法有完整的 AST 並解析其語意，因此除非寫得非常繁複，一定會有無法正確 highlight 的地方，例如 comment，不是說 comment 不能正確標示，問題是 comment 可以插入在很多地方，像是參數序列的中間，<code>function</code> 關鍵字和後面 <code>()</code> 的中間等等，幾乎是可以放空白字元的地方就可以放 comment，然後不會影響程式語意，本來，不考慮註解時，我可以用 <code>skipwhite</code>、<code>skipempty</code> 然後加上 <code>nextgroup</code> 就可以指定下一個 token 是什麼，以 JavaScript function declaration 來說：</p>

<pre><code>function fn (a) {}
</code></pre>

<p>這樣的程式碼我把他拆成四個部分，function keyword、function name、function parameter、function body，然後用 Vim syntax 語法設定：</p>

<pre><code>syntax keyword javascriptFuncKeyword function nextgroup=javascriptFuncName skipwhite
syntax match   javascriptFuncName    contained /\k\+/ nextgroup=javascriptFuncParam skipwhite
syntax match   javascriptFuncParam   contained /([^()]*)/ nextgroup=javascriptFuncBody skipwhite
syntax region  javascriptFuncBody    contained start=/{/ end=/}/
</code></pre>

<p>除了 function keyword 外都有 <code>contained</code>，用途是讓該 rule 不會在 TOP region 下生效，一個好處是減少 TOP region 下要檢查的 rule 數量，另一個好處是有些相同的 token pattern，但是其實語意上是不一樣的，可以盡量用這種機制拆分開來，到這裡都還很美好，但是加上 comment 後問題就變複雜了，先簡單寫一下 comment 的 syntax rule：</p>

<pre><code>syntax region  javascriptComment     start=/\/\*/ end=/\*\//
</code></pre>

<p>然後 comment 可以放在哪些地方呢：</p>

<pre><code>function /*cc*/ fn (a) {}
function fn /*cc*/ (a) {}
function fn (a) /*cc*/ {}
</code></pre>

<p>也就是本來 nextgroup 連接的地方都可以插入個 comment，可是只要插入了 comment，後面的 token 就不會被正確 highlight，因為 comment 的 rule 沒有 nextgroup，所以他的部分結束後就會回到用 TOP region 的情境，而後面應該符合的 rule 都有設上 <code>contained</code>，所以就沒機會對到。當然現在要解決這個問題也不是沒方法可以避開，但是非常不好看，就是如下的設計：</p>

<pre><code>syntax keyword javascriptFuncKeyword function nextgroup=javascriptFuncName,comment1 skipwhite
syntax match   javascriptFuncName    contained /\k\+/ nextgroup=javascriptFuncParam,comment2 skipwhite
syntax match   javascriptFuncParam   contained /([^()]*)/ nextgroup=javascriptFuncBody,comment3 skipwhite
syntax region  javascriptFuncBody    contained start=/{/ end=/}/

syntax region  comment1     start=/\/\*/ end=/\*\// nextgroup=javascriptFuncName,comment1 skipwhite
syntax region  comment2     start=/\/\*/ end=/\*\// nextgroup=javascriptFuncParam,comment2 skipwhite
syntax region  comment3     start=/\/\*/ end=/\*\// nextgroup=javascriptFuncBody,comment3 skipwhite
</code></pre>

<p>如此可以確保 comment 插入也不會讓後面的 token 沒 highlight，但是這樣的設計，實際寫起來會非常繁瑣，完全不想去研究 JavaScript 中會有多少類似的狀況。其實我是覺得 Vim syntax 應該是希望盡量都用前後獨立的 rule 來 highlight，盡量不要有前後相依的關係存在，就不會有上面的問題，也可以讓 highlight 過程比較單純，理想上是從頭開始，一個 token 一個 token 各自獨立的 highlight，不過是事情當然沒這麼簡單，第二個想記錄下來的事情也和這個有關係。</p>

<p>假設目前 highlight 處理中，parse 到一個 <code>=</code>，然後看到一組小括號 <code>(a)</code>，連起來如下：</p>

<pre><code>= (a)
</code></pre>

<p>這時你會覺得 <code>(a)</code> 是什麼呢？是小括號，裡面是一個 expression 然後回傳變數 <code>a</code> 嗎？相信很多人會這樣認為，如果他後面是接分號的話：</p>

<pre><code>= (a);
</code></pre>

<p>但是其實也可能是這樣子的：</p>

<pre><code>= (a) =&gt; {}
</code></pre>

<p>ES6 的 arrow function，也就是說，如果一個 token 一個 token 解析，一定無法直接知道目前 token 代表的正確意義，所以 compiler 把程式碼轉成 AST 的時候，有時候會先往後面看一下來判斷現在的 token 到底是什麼意義。然而 Vim syntax 系統並沒有這種能力，嚴格來說，是可以用 match 來達成，不過還是很受限制。再來則是往前看的問題，我在設定運算子的 match rule 的時候，會希望嚴謹一點，本來想在兩邊加上 word boundary 的 pattern，在 Vim 裡面是 <code>\&lt;</code> 和 <code>\&gt;</code>，不過測試幾回發現，我的字元本身不是文字字元的話，這個 pattern 是沒有用的：</p>

<pre><code>/\&lt;word
</code></pre>

<p>這樣是有效的，但是下面想要 match <code>==</code> 的會沒用：</p>

<pre><code>/\&lt;==
</code></pre>

<p>所以變成要自己寫往前看的 regexp，在 Vim 裡面有兩種類似的東西可以用，分別是 <code>\zs</code> 和 <code>\@&lt;=</code>，通常，<code>\zs</code> 效能比較好，會推薦使用，他的用途是標註你的 regexp 的 match 的起點，當然同時也有一個 <code>\ze</code> 是終點：</p>

<pre><code>/abcd\zsefgh\zeijkl
</code></pre>

<p>上面這串 regexp 的目標是 <code>efgh</code>，但是他的前後分別是 <code>abcd</code> 和 <code>ijkl</code>，實際執行時會去找 <code>abcdefghijkl</code> 這串字串，完整比對到之後，只會回中間的 <code>efgh</code> 作為 match 的範圍，這設計要做一些操作的時候就會有差，像是文字取代。本來我就想要用這個來做 syntax，可是就發現還是不生效，所以改成用 <code>\@&lt;=</code> 試試看：</p>

<pre><code>/\(abcd\)\@&lt;=efgh\@=\(ijkl\)
</code></pre>

<p>就發現成功了，想了許久才理解其原因，然後才瞭解，真的往前看的是 <code>\@&lt;=</code>，<code>\zs</code> 並沒有往前看，兩者最大的差異在於 pattern match 操作的起點，一般的使用大概感覺不太到差異，不過像是 syntax highlight 這種一個 token 一個 token 逐步處理的就會有差，當目標是 <code>efgh</code> 時，通常處理進度到 <code>e</code> 這個位置時，前面的 <code>abcd</code> 已經被處理過了，所以這時候會和 regexp 比對的字串就變成 <code>efghijkl</code>，使用 <code>\zs</code> 的話，因為它還是要完整比對到 <code>abcdefghijkl</code>，起點是 <code>a</code>，就不會和 <code>efghijkl</code> 相符，但是用 <code>\@&lt;=</code> 的話，pattern 的起點是 <code>efgh</code> 的 <code>e</code>，這樣就可以 match 到目前剩餘的字串了。</p>

<p>前面說的個 token 一個 token 逐步處理的問題還有一個情形也讓我困擾很久，不過這次不是東西被用掉，問題是沒被用掉。這個狀況發生在巢狀結構的 region，像是 JavaScript 的 block：</p>

<pre><code>syntax region  javascriptBlock start=/{/ end=/}/
</code></pre>

<p>然號要讓 block 裡面可已有 block 就要用 <code>contains</code>：</p>

<pre><code>syntax region  javascriptBlock start=/{/ end=/}/ contains=javascriptBlock
</code></pre>

<p>這時候就會發生奇怪的現象了，因為外面的 region 包括了頭尾的括號，然後進入 block 內要做 syntax match 的時候，一開始的 <code>{</code> 又 match 到 block，結果 Vim 就直接覺得這已經是第二層的 block 了，雖然好像有其它機制讓他不會一直循環下去變成無限多層，不過這樣還是會造成後面的 code 有被判斷錯誤的機會，因為 block 的開關不 match，這裡的關鍵也是要讓 <code>{</code> 和 <code>}</code> 被處理掉，進入 region 內部就不會跑到上一層的起點，而這裡要用的就是 <code>matchgroup</code>：</p>

<pre><code>syntax region  javascriptBlock matchgroup=bracks start=/{/ end=/}/ contains=javascriptBlock
</code></pre>

<p>如此就都會正常了，因為這樣的設定會讓 <code>{</code> 和 <code>}</code> 直接被當成 <code>bracks</code> 這個 group，然後就被當成已經被解析過的 token，從它的下一個 token 繼續 highlight 分析，但是千萬不要另外加上 <code>bracks</code> 的 syntax rule，剛好又 match 到 region 的起點和終點：</p>

<pre><code>syntax match   bracks  /[{}]/
</code></pre>

<p>這樣的話也會發生其它的怪異現象，總之 nested region 的重點在於，要用 matchgroup，然後不要用和 matchgrouop 同樣名稱，同樣 pattern 另外又設定一組 rule。</p>

<p>最後一個要紀錄的則是 Vim syntax 裡面的優先度，基本上是 keyoword 優先度最高，也就是有 match 到 keyword 的話，你的 match pattern 就都無效了，所以像是 JavaScript 裡面，label 雖然不可以用關鍵字，像是 <code>continue:</code> 就不合法，但是因為會先 match 到 <code>continue</code> 關鍵字，所以就很難用 syntax highlight 來標出這種錯誤，而在 keyword 比對完之後，才輪的到 region 和 match，兩者是同樣權重，但是後定義的優先，而且不受 <code>contains</code> 和 <code>nextgroup</code> 裡面的順序影響，搞清楚優先順序在做細部的 syntax highlight 的時候還蠻重要的。另外要順便說說 region contains 和 nextgroup 的差異，nextgroup 其實還蠻不錯的，他不是限制下一個 token 一定是哪些東西，而是改變優先順序，先檢查完 nextgroup 裡面的東西，再檢查該 region 下的其它可能性，region contains 就不一樣了，該 region 裡面只有在 contains 裡面的東西會出現，另外還要特別注意一點，region 的處理並不管該 region 能不能正確的關閉，只要 match 到起點，就會把 region 打開，然後剛剛有提到，region 和 match 是同樣權重的所以就要非常注意：</p>

<pre><code>syntax match  javascriptLabel       /\k\+:/
syntax region javascriptLabelblock  start=/\k\+: {/ end=/}/
</code></pre>

<p>這樣兩條 syntax highlight rule 然後配上下面的程式碼：</p>

<pre><code>abcd: {
  var ii = 1 + 1;

var jj = 2 + 2;
</code></pre>

<p>要注意我的 block 其實沒有結束，但是結果 Vim 只會 match 到 label block 那條規則，而且由於一直找不到 region 的結束點，所以下面的 <code>var jj</code> 那行也是被認為在 block 內。</p>

<p>最後的最後要推薦一下 <a href="https://github.com/gerw/vim-HiLinkTrace">gerw/vim-HiLinkTrace</a> 這個 Vim plugin，可以很完整的 trace syntax highlight 的狀況。</p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000835" baseName="macbook-2015">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-03-12</b:date>
				<b:time>23:43:36</b:time>
			</b:datetime>
			<b:category>mac</b:category>
			<b:title>MacBook 2015</b:title>
			<b:content>
				<b:summary>前兩天發表的 MacBook 很多人不看好，不過我倒是很看好的那邊，連我都想買了，不到一公斤但是確是台完整的 OSX 電腦，有正常大小的鍵盤、感壓觸控版，加上 Retina Display，買一台金色的去咖啡廳簡直要橫著走了，不過更讓我好奇的是它竟然沒取代 Air，Air 還比較重真是情何以堪，我推測比較可能的發展是 Air 產品線未來會收掉，回到之前兩條產品線的狀況。 另外還有一點讓我很好奇的就是觸控版的部分，一來是好奇他的感壓加上震動回饋操作起來的感覺 ，二來是 MacBook Pro 13 吋有更新，但是 15 吋卻沒更新，要知道相較於 13 吋 MBP，15 吋更新的頻率實在是低很多，在這個新觸控版的更新上竟然還沒有 15 吋的，實在不太合理，所以我猜蘋果是等另外一個產品出來：27 吋 5K 的 Cinema Display，可能很多人不知道，蘋果之前出的 iMac 5K 和以往不一樣，不能當作外接螢幕，其中一個最大的原因是目前通行的傳輸介面還不能傳輸到 5K 解析度，市場上的 DisplayPort 幾乎都是 1.2，至少要到 1.3 才有辦法處理...</b:summary>
				<b:mainContent><p>前兩天發表的 MacBook 很多人不看好，不過我倒是很看好的那邊，連我都想買了，不到一公斤但是確是台完整的 OSX 電腦，有正常大小的鍵盤、感壓觸控版，加上 Retina Display，買一台金色的去咖啡廳簡直要橫著走了，不過更讓我好奇的是它竟然沒取代 Air，Air 還比較重真是情何以堪，我推測比較可能的發展是 Air 產品線未來會收掉，回到之前兩條產品線的狀況。</p>

<p>另外還有一點讓我很好奇的就是觸控版的部分，一來是好奇他的感壓加上震動回饋操作起來的感覺
，二來是 MacBook Pro 13 吋有更新，但是 15 吋卻沒更新，要知道相較於 13 吋 MBP，15 吋更新的頻率實在是低很多，在這個新觸控版的更新上竟然還沒有 15 吋的，實在不太合理，所以我猜蘋果是等另外一個產品出來：27 吋 5K 的 Cinema Display，可能很多人不知道，蘋果之前出的 iMac 5K 和以往不一樣，不能當作外接螢幕，其中一個最大的原因是目前通行的傳輸介面還不能傳輸到 5K 解析度，市場上的 DisplayPort 幾乎都是 1.2，至少要到 1.3 才有辦法處理 5K 解析度，iMac 5K 發表則只比 DisplayPort 1.3 晚一個月左右，蘋果除了要等 DisplayPort 1.3 之外，還有另外一個就是這次 MacBook 的主角之一：USB 3.1 Type-C，這條新的介面真的很強，除了向下相容外，可以反差，可以傳更多電力，傳輸資料量當然更大，還可以傳輸影像訊號，用的就是 DisplayPort 規格，嚴格說來是 DisplayPort  規範有個 Alternate Mode 可以使用其它線材做傳輸，而 DisplayPort 1.3 理想最高資料量的情況下（其實就是 5K 解析度）都還塞不滿 USB 3.1，可以邊傳完整 5K 畫面邊傳資料。我的猜測就是 15 吋 MBP 下次更新除了新的觸控版外，還有 USB 3.1 Type-C，更強的顯示卡，然後同場加映 27 吋 5K 的 Cinema Display，用 USB 3.1 Type-C 連接，同時供電，傳資料，以前 Cinema Display 那條三頭的線就一條 USB 解決了。</p>

<p>最後話題回來 MacBook，其實我覺得這台打的目標消費者族群很明確，就是買 MacBook Air 的那個族群，MacBook Air 剛出來其實是比 MacBook 還要高級一點的，現在兩邊角色正好互換，其實也是蠻有趣的。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16606304008/" title="MacBook_OP90_Tilt_Gld-PRINT by othree, on Flickr"><img src="https://farm8.staticflickr.com/7603/16606304008_fcb25667a4_b.jpg" width="607" height="1024" alt="MacBook_OP90_Tilt_Gld-PRINT" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7603/16606304008_fcb25667a4.jpg 1x, https://farm8.staticflickr.com/7603/16606304008_fcb25667a4_b.jpg 2x" src-2="https://farm8.staticflickr.com/7603/16606304008_35277c0292_k.jpg 2x" /></a></p>
</b:mainContent>
				<b:extendContent>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000834" baseName="csp">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-02-14</b:date>
				<b:time>15:26:33</b:time>
			</b:datetime>
			<b:category>script</b:category>
			<b:title>CSP</b:title>
			<b:content>
				<b:summary> Communicating Sequential Processes，簡稱 CSP，和 Content Security Policy 不一樣，是用來處理非同步執行序之間溝通的一個數學模型，我最早是在 Addy Osmani 的 JavaScript Application Architecture On The Road To 2015 這篇文章裡面看到的，花了蠻多時間試著去瞭解，最近終於覺得懂一點皮毛可以紀錄一下了。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16440158642/" title="CSP by othree, on Flickr"><img src="https://farm9.staticflickr.com/8598/16440158642_62042f3837_b.jpg" width="791" height="1024" alt="CSP" srcset="https://farm9.staticflickr.com/8598/16440158642_62042f3837.jpg 768w, https://farm9.staticflickr.com/8598/16440158642_62042f3837_b.jpg 768w 2x" /></a></p>

<p>Communicating Sequential Processes，簡稱 CSP，和 Content Security Policy 不一樣，是用來處理非同步執行序之間溝通的一個數學模型，我最早是在 Addy Osmani 的 <a href="https://medium.com/@addyosmani/javascript-application-architecture-on-the-road-to-2015-d8125811101b">JavaScript Application Architecture On The Road To 2015</a> 這篇文章裡面看到的，花了蠻多時間試著去瞭解，最近終於覺得懂一點皮毛可以紀錄一下了。</p>
</b:mainContent>
				<b:extendContent><p>CSP 其實不是新東西，是 <a href="http://en.wikipedia.org/wiki/Tony_Hoare">C. A. R. Hoare</a> 在 1978 年就發表的<a href="http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf">論文</a>(PDF)，1985 還出了整本書來介紹，而且<a href="http://www.usingcsp.com/cspbook.pdf">全文 PDF</a> 都有在網路上，可是這本書實在太理論了，看了一點點就看不下去，只好找其它資源，發現還真的蠻少的，但是確有找到一些近幾年的實做，像是 Go 的 routine 間用 channel 溝通，或是 Clojure 的 core.async，當然 Addy Osmani 那篇也有提到 JavaScript 的部分。</p>

<p>根據我目前淺薄的理解，CSP 就是用 channel 的非同步溝通機制，channel 怎麼用呢，顧名思義，就是一個傳遞訊息用的頻道，不過我覺得用管線可以更精確的描述它，而且這是一個單向的管線，一邊只能傳訊息進去，一邊只能拿訊息出來，可以達成非同步的溝通最主要在於拿訊息這邊，當你在其中一個 process 中說你要跟某個 channel 拿一個訊息出來時，如果那個 channel 裡面沒有東西，則這邊的 process 就會停下來等到那個 channel 有訊息出現，這個等待的機制不同語言有各自的方法實做。</p>

<p>先來看看 Go 的範例吧，因為實在是比 JavaScript 的直覺多了：</p>

<pre><code>package main
import "fmt"

func main() {
    messages := make(chan string, 1)

    messages &lt;- "ping"

    msg := &lt;-messages
    fmt.Println(msg)
}
</code></pre>

<p>這段程式碼是基於 Go by Example 說明 channel 的<a href="https://gobyexample.com/channels">範例</a>，程式碼很好理解，<code>messages := make(chan string, 1)</code>這行用 make 產生一個 channel 指派給 messages 這個變數，<code>messages &lt;- "ping"</code> 表示把 "ping" 這個字串丟進去 message 這個 channel 裡面，然後 <code>msg := &lt;-messages</code> 表示從 message channel 裡面抓訊息出來，丟到 msg 這個變數，<code>:=</code> 是指派同時宣告變數的運算子，<code>&lt;-</code> 則是用來描述操作中訊息傳遞方向用的運算子，當它是箭頭就很好理解，在 Go 裡面稱為 <a href="https://golang.org/ref/spec#Receive_operator">receive operator</a>。</p>

<p>在第一個例子當中，因為是先送資料進去 channel 才拿出來，所以還不太有感覺，接下來看第二個例子，一樣是 Go by Example 的，這段是 <a href="https://gobyexample.com/channel-synchronization">Channel Synchronization</a> 的範例：</p>

<pre><code>package main

import "fmt"
import "time"

func worker(done chan bool) {
    fmt.Print("working...")
    time.Sleep(time.Second)
    fmt.Println("done")

    done &lt;- true
}

func main() {

    done := make(chan bool, 1)
    go worker(done)

    &lt;-done
}
</code></pre>

<p>這個範例稍微複雜一點，<code>done := make(chan bool, 1)</code> 先產生一個 done channel，然後用 <code>go worker(done)</code> 產生一個 concurrent routine，跑的是 worker 這個 function，內容在 main 的上面，基本上就是 sleep 一下然後傳訊息回 done channel，然後 main 最後的 <code>&lt;-done</code> 就是從 done channel 拿訊息出來，先不管平行出去的 routine，通常的程式跑到這行結束，整個程式就結束關閉了，不過，就是這個不過，正常情況下，有 <code>&lt;-channel</code> 的話，該 routine 程式執行到這邊就會暫停下來，直到有從 channel 裡面拿到訊息才會繼續跑下去（或是裡面已經有訊息，直接拿到就繼續往下）。</p>

<p>Go 的 channel 還有一些細節可以參考 <a href="http://guzalexander.com/2013/12/06/golang-channels-tutorial.html">Golang channels tutorial</a> 這篇文章，其實就是一個可以跨 routine 的傳遞資料的管道，資料可以一直傳，沒有限制數量，不過還有一些相關的細節，像是 sync channel，還有 channel 的 buffer 等等。</p>

<p>綜合以上的兩個範例，可以歸納出來，要支援 CSP 有兩個必要條件，第一個是可以做得出 channel 物件的機制，可以放資料進去，可以拿資料出來，是先進先出機制，這部分其實不是問題，問題是第二個條件，程式碼要能跑一跑停下來等訊息然後又繼續跑下去，這可不是用 <code>while (1)</code> 可以處理的狀況，用 recursive function call 效能也不太好，以前的 JavaScript 是無法良好的達成第二個條件的，直到 ES6 的 async function 出現。</p>

<p>ES6 async function 之前有<a href="https://blog.othree.net/log/2014/05/24/es6-iterable/">文章</a>介紹過，這邊就不再說明，不過總之就是執行到 <code>yield</code> 後，這個 function call 就會先停下來，把值傳出，直到下次再次執行該 function 才會繼續往下執行，這樣停下來的機制，正好可以利用來作為 CSP 等訊息的機制，不過利用 <code>yield</code> 的話有一個限制，就是一定要在 async function 裡面才可以利用 channel，不像 Go 由於是建在語言裡面的，main thread 也可以跟 channel 溝通。</p>

<p>雖然說可以利用 async function 可以做出 CSP 的架構出來，不過要只用 async function 來寫出像 Go 那樣簡短的程式碼實在是很困難，中間還有很多機制需要補起來，所以就開始有 library 實做，目前最有名的是 <a href="https://github.com/ubolonton/js-csp">js-csp</a>，Facebook 最近的 React.js Conf 其中一場議程介紹 CSP 時也是用 js-csp 做範例，錄影在這，作為入門 CSP 我覺得是蠻不錯的一場演講：</p>

<iframe width="853" height="480" src="https://www.youtube.com/embed/W2DgDNQZOwo?list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p>js-csp 裡面其實做了很多事情，目前看起來像是參考 Go 來設計，例如這樣的 Go <a href="http://talks.golang.org/2013/advconc.slide#6">程式碼</a>：</p>

<pre><code>package main
import "fmt"
import "time"

type Ball struct{ hits int }

func player(name string, table chan *Ball) {
    for {
        ball := &lt;-table
        ball.hits++
        fmt.Println(name, ball.hits)
        time.Sleep(100 * time.Millisecond)
        table &lt;- ball
    }
}

func main() {
    table := make(chan *Ball)
    go player("ping", table)
    go player("pong", table)

    table &lt;- new(Ball) // game on; toss the ball
    time.Sleep(1 * time.Second)
    &lt;-table // game over; grab the ball
}
</code></pre>

<p>改成用 js-csp 寫的話就變成：</p>

<pre><code>function* player(name, table) {
  while (true) {
    var ball = yield csp.take(table);
    if (ball === csp.CLOSED) {
      console.log(name + ": table's gone");
      return;
    }
    ball.hits += 1;
    console.log(name + " " + ball.hits);
    yield csp.timeout(100);
    yield csp.put(table, ball);
  }
}

csp.go(function* () {
  var table = csp.chan();

  csp.go(player, ["ping", table]);
  csp.go(player, ["pong", table]);

  yield csp.put(table, {hits: 0});
  yield csp.timeout(1000);
  table.close();
});
</code></pre>

<p>用 <code>csp.chan</code> 產生 channel，用 <code>yield csp.take</code> 代替從 channel 取訊息，用 <code>yield csp.put</code> 代替送訊息到 channel，然後最重要的是用 <code>csp.go</code> 來代替從 Go 裡面用 <code>go</code> 產生 routine 的操作，然後不說可能沒人注意到，js-csp 把 routine(<a href="https://github.com/ubolonton/js-csp/blob/master/src/impl/process.js">process</a>)、<a href="https://github.com/ubolonton/js-csp/blob/master/src/impl/dispatch.js">ticker</a> 等比較底層的基礎建設都做起來了，也就是如此才能讓程式碼和 Go 的看起來這麼接近。</p>

<p>js-csp 基本上就是仿照 Go 的的語法來設計，只是常常需要 yield，語法還是不如 Go 來的簡潔，至於何種情境比較適合使用 CSP 呢，以 channel 的特性來說，目前看起來是常常會發生的 event 比較適合，像是常常被拿出來講的 mousemove 事件，另外就是有要分 thread 做平行運算的話也不錯，不過目前看起來是無法接上 WebWorker，主要是因為 <code>postMessage</code> 無法傳遞物件 instance 過去，而是會<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm">複製</a>一份；另外因為 channel 可以關起來，所以要用來實做 Promise 也不是不行，不過就沒什麼必要如此搞就是。</p>

<p>講到做事件的處理，應該會有人注意到實做上的細節問題，就是要怎麼讓多個 process 去讀取同一個 channel 呢，一般而言，channel 的訊息是只能讀取一次的，就是說雖然你可以多個 process 等同一個 channel 的訊息，但是只會有一個 process 會真的拿到新的訊息，而實務上，一個事件綁了多個 handler 的情形非常常見，照 channel 的機制，應該是不能用下去的，不然就要自己管裡 handler，又多繞了一圈，事實上，CSP 模型是有一些<a href="https://github.com/ubolonton/js-csp/blob/master/src/csp.operations.js">運算</a>可以用的，像要處理多個 handler 的問題，就可以用 <code>mult</code>，可以把一個 channel 轉成<a href="http://rupsshankar.tumblr.com/post/66648884392/demystifying-core-asyncs-tap-and-mult">一對多</a>，其它還有多對一的 share resource、Clojure 的 onto <a href="http://www.slideshare.net/borgesleonardo/clojure-reducers-cljsyd-aug-2012?ref=http://www.leonardoborges.com/writings/presentations/">等等</a>，應該是想的到的情形都已經有數學模型或是不同語言的實做可以處理了，不過 js-csp 在這部分還在開發中，像是 mult 就還在 beta 階段，其實還不太能真的用，作者有說現在的介面可能會改，也因此還沒寫到文件裡面。</p>

<p>最後想要記錄一下 Clojure 所提出的 transducer，transducer 的目的是讓 reduce 的操作可以用 compose 來組合，什麼是 reduce  操作呢，其實包括像 map、filter 都可以算是，但是這些操作以前是無法用 function composition 來做組合的，直到有了 transducer，又加上 transducer 把處理資料的型別也 decouple 出去了，所以 channel message 也可以利用。有兩篇文章可以參考，第一篇文章是 <a href="http://phuu.net/2014/08/31/csp-and-transducers.html">CSP and transducers in JavaScript</a>，這篇講得非常清楚，他是從無到有把 transducer 建構起來，我是第二次認真看這篇文章才理解的，另外一篇文章是 <a href="http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data">Transducers.js: A JavaScript Library for Transformation of Data</a>，是 Transducer.js 的作者寫的，從不太一樣的角度來看 Transducer 這個設計，有機會再來分享詳細一點。</p>

<p>這篇文章其實也不算是介紹或教學 CSP on JavaScript，比較是記錄一些我花時間想辦法理解的問題，包括為什麼現在才有人用 JavaScript 實做 CSP，實際上怎麼實做，目前適用的地方，還有整理了對 transducer 的理解，如果單純是想理解 CSP，除了前面提到的文章之外，還有幾篇文章可以參考 <a href="https://swannodette.github.io/2013/08/24/es6-generators-and-csp/">ES6 Generators Deliver Go Style Concurrency</a>、<a href="http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript">Taming the Asynchronous Beast with CSP Channels in JavaScript</a>。</p>
</b:extendContent>
			</b:content>


		</b:entry>

		<b:entry entryID="000833" baseName="tokyo-illumination">
			<b:author>
				<b:authorName>othree</b:authorName>
				<b:authorEmail>othree@gmail.com</b:authorEmail>
				<b:authorUrl></b:authorUrl>
			</b:author>
			<b:datetime>
				<b:date>2015-02-10</b:date>
				<b:time>23:49:05</b:time>
			</b:datetime>
			<b:category>diary</b:category>
			<b:title>東京點燈</b:title>
			<b:content>
				<b:summary> 去年底去那趟東京主要的目標之一是看聖誕的燈飾，日本人喜歡用 Illumination 這個字，如果是用這個字的話，翻譯起來就變成是點燈了，總之，本來主要的目標大概就是六本木 Midtown、Caretta 汐留和台場富士電視台三個，不過日本聖誕節前真的是到處都有燈飾，上面第一張照片就是 Midtown 裡面的景色了。...</b:summary>
				<b:mainContent><p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16179501782/" title="東京 Midtown Illumination by othree, on Flickr"><img src="https://farm8.staticflickr.com/7469/16179501782_e2bf9e5441_b.jpg" width="1024" height="683" alt="東京 Midtown Illumination" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7469/16179501782_e2bf9e5441.jpg 1x, https://farm8.staticflickr.com/7469/16179501782_e2bf9e5441_b.jpg 2x" src-2="https://farm8.staticflickr.com/7469/16179501782_073c18e1ce_k.jpg 2x" /></a></p>

<p>去年底去那趟東京主要的目標之一是看聖誕的燈飾，日本人喜歡用 Illumination 這個字，如果是用這個字的話，翻譯起來就變成是點燈了，總之，本來主要的目標大概就是六本木 Midtown、Caretta  汐留和台場富士電視台三個，不過日本聖誕節前真的是到處都有燈飾，上面第一張照片就是 Midtown 裡面的景色了。</p>
</b:mainContent>
				<b:extendContent><p>其實在羽田機場就有了，用小燈點綴的樹枝。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16180233965/" title="東京 羽田機場 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7476/16180233965_30d7dd550d_b.jpg" width="683" height="1024" alt="東京 羽田機場" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7476/16180233965_30d7dd550d.jpg 1x, https://farm8.staticflickr.com/7476/16180233965_30d7dd550d_b.jpg 2x" src-2="https://farm8.staticflickr.com/7476/16180233965_00bcaf33a9_k.jpg 2x" /></a></p>

<p>接著去了 Midtown，這邊排隊的人就很多，要繞來繞去，最後才走到展區，平常展區那塊草地和步道是直接可以走過去的。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15994464187/" title="東京 Midtown Illumination by othree, on Flickr"><img src="https://farm8.staticflickr.com/7503/15994464187_f9e10f6a73_b.jpg" width="1024" height="683" alt="東京 Midtown Illumination" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7503/15994464187_f9e10f6a73.jpg 1x, https://farm8.staticflickr.com/7503/15994464187_f9e10f6a73_b.jpg 2x" src-2="https://farm8.staticflickr.com/7503/15994464187_9205f30315_k.jpg 2x" /></a></p>

<p>主要展區，有不斷輪撥的表演，藍光配上音效營造出讓人置身未來世界的感覺。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15557892534/" title="東京 Midtown Illumination by othree, on Flickr"><img src="https://farm8.staticflickr.com/7489/15557892534_a34eea8f8e_b.jpg" width="1024" height="683" alt="東京 Midtown Illumination" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7489/15557892534_a34eea8f8e.jpg 1x, https://farm8.staticflickr.com/7489/15557892534_a34eea8f8e_b.jpg 2x" src-2="https://farm8.staticflickr.com/7489/15557892534_808451b2ce_k.jpg 2x" /></a></p>

<p>去森大樓看東京鐵塔後，就在裡面發現天花板上的雪花燈飾。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16179485552/" title="東京 六本木 森大樓 by othree, on Flickr"><img src="https://farm9.staticflickr.com/8678/16179485552_bcbfb958e5_b.jpg" width="683" height="1024" alt="東京 六本木 森大樓" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8678/16179485552_bcbfb958e5.jpg 1x, https://farm9.staticflickr.com/8678/16179485552_bcbfb958e5_b.jpg 2x" src-2="https://farm9.staticflickr.com/8678/16179485552_7ecbe87ce3_k.jpg 2x" /></a></p>

<p>然後是森大樓外面的聖誕樹，很特別的設計，基本上是拍不太起來的設計，只能故意對不準焦來讓顏色顯現。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15560455013/" title="東京 六本木 森大樓 by othree, on Flickr"><img src="https://farm9.staticflickr.com/8665/15560455013_79a812fdf6_b.jpg" width="683" height="1024" alt="東京 六本木 森大樓" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8665/15560455013_79a812fdf6.jpg 1x, https://farm9.staticflickr.com/8665/15560455013_79a812fdf6_b.jpg 2x" src-2="https://farm9.staticflickr.com/8665/15560455013_4f116cb7d6_k.jpg 2x" /></a></p>

<p>到箱根的小王子博物館也有聖誕樹和特別的投影表演。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15993952618/" title="箱根 小王子博物館 星の王子さまミュージアム by othree, on Flickr"><img src="https://farm8.staticflickr.com/7560/15993952618_d6f5768f3f_b.jpg" width="1024" height="683" alt="箱根 小王子博物館 星の王子さまミュージアム" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7560/15993952618_d6f5768f3f.jpg 1x, https://farm8.staticflickr.com/7560/15993952618_d6f5768f3f_b.jpg 2x" src-2="https://farm8.staticflickr.com/7560/15993952618_764244f18d_k.jpg 2x" /></a></p>

<p>然後是之前介紹過的 Disney TIMELESS STORY。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15999327639/" title="新丸大樓 魔髮奇緣 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7531/15999327639_d7e1eef74b_b.jpg" width="1024" height="683" alt="新丸大樓 魔髮奇緣" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7531/15999327639_d7e1eef74b.jpg 1x, https://farm8.staticflickr.com/7531/15999327639_d7e1eef74b_b.jpg 2x" src-2="https://farm8.staticflickr.com/7531/15999327639_e723a6ccb4_k.jpg 2x" /></a></p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15999578907/" title="丸大樓 Frozen by othree, on Flickr"><img src="https://farm9.staticflickr.com/8587/15999578907_2502cbddb4_b.jpg" width="1024" height="683" alt="丸大樓 Frozen" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8587/15999578907_2502cbddb4.jpg 1x, https://farm9.staticflickr.com/8587/15999578907_2502cbddb4_b.jpg 2x" src-2="https://farm9.staticflickr.com/8587/15999578907_89f9909fce_k.jpg 2x" /></a></p>

<p>兩棟丸大樓後面的仲通り也裝飾的很漂亮，本來在六本木沒看到的街道燈飾也在這邊看到了></p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16185368255/" title="丸の内仲通り イルミネーション 丸之內仲通 illumination by othree, on Flickr"><img src="https://farm8.staticflickr.com/7562/16185368255_7920432223_b.jpg" width="1024" height="683" alt="丸の内仲通り イルミネーション 丸之內仲通 illumination" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7562/16185368255_7920432223.jpg 1x, https://farm8.staticflickr.com/7562/16185368255_7920432223_b.jpg 2x" src-2="https://farm8.staticflickr.com/7562/16185368255_dd326fadf9_k.jpg 2x" /></a></p>

<p>然後是東京郵政總局改的 Kitte 裡面也有聖誕樹，而且也有固定的表演。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16184598772/" title="Kitte by othree, on Flickr"><img src="https://farm9.staticflickr.com/8566/16184598772_751560bbd9_b.jpg" width="1024" height="683" alt="Kitte" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8566/16184598772_751560bbd9.jpg 1x, https://farm9.staticflickr.com/8566/16184598772_751560bbd9_b.jpg 2x" src-2="https://farm9.staticflickr.com/8566/16184598772_4e494dc35c_k.jpg 2x" /></a></p>

<p>這是旅館附近的大樓，回去時剛好看到。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15562993324/" title="東京 田町 by othree, on Flickr"><img src="https://farm9.staticflickr.com/8584/15562993324_591684a8a2_b.jpg" width="1024" height="683" alt="東京 田町" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8584/15562993324_591684a8a2.jpg 1x, https://farm9.staticflickr.com/8584/15562993324_591684a8a2_b.jpg 2x" src-2="https://farm9.staticflickr.com/8584/15562993324_a48c5bd1de_k.jpg 2x" /></a></p>

<p>再來就是彩色的彩虹橋。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16007370108/" title="彩虹橋 by othree, on Flickr"><img src="https://farm9.staticflickr.com/8563/16007370108_0e2501b4f9_b.jpg" width="1024" height="683" alt="彩虹橋" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8563/16007370108_0e2501b4f9.jpg 1x, https://farm9.staticflickr.com/8563/16007370108_0e2501b4f9_b.jpg 2x" src-2="https://farm9.staticflickr.com/8563/16007370108_b851522356_k.jpg 2x" /></a></p>

<p>小小的台場點燈。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/15575022383/" title="台場  illumination by othree, on Flickr"><img src="https://farm8.staticflickr.com/7478/15575022383_44e08d2af3_b.jpg" width="1024" height="683" alt="台場  illumination" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7478/15575022383_44e08d2af3.jpg 1x, https://farm8.staticflickr.com/7478/15575022383_44e08d2af3_b.jpg 2x" src-2="https://farm8.staticflickr.com/7478/15575022383_3630dd6cd8_k.jpg 2x" /></a></p>

<p>目標之二的富士電視台，還蠻有趣的，不過其實內容都是在廣告，然後現場直接用肉眼看會發現畫面太大，點陣圖看不太出來是什麼，透過相機小螢幕反而可以看的出來。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16009043237/" title="富士電視台 illumination by othree, on Flickr"><img src="https://farm8.staticflickr.com/7583/16009043237_b71b09e830_b.jpg" width="1024" height="683" alt="富士電視台 illumination" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7583/16009043237_b71b09e830.jpg 1x, https://farm8.staticflickr.com/7583/16009043237_b71b09e830_b.jpg 2x" src-2="https://farm8.staticflickr.com/7583/16009043237_b9c3878cab_k.jpg 2x" /></a></p>

<p>第一次到台場 Decks，他外面也有一顆聖誕樹。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16194829755/" title="台場 Decks by othree, on Flickr"><img src="https://farm8.staticflickr.com/7552/16194829755_f9ae1de7dc_b.jpg" width="1024" height="683" alt="台場 Decks" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7552/16194829755_f9ae1de7dc.jpg 1x, https://farm8.staticflickr.com/7552/16194829755_f9ae1de7dc_b.jpg 2x" src-2="https://farm8.staticflickr.com/7552/16194829755_1cde8ad1d8_k.jpg 2x" /></a></p>

<p>目標之三的 Caretta  汐留，最喜歡的點，剛好走天橋過去，從上面看的時候真的有種異世界的感覺，在下面人很多沒機會這樣感覺～</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16203842762/" title="Caretta  汐留 Illumination by othree, on Flickr"><img src="https://farm9.staticflickr.com/8610/16203842762_3a4695db7f_b.jpg" width="1024" height="683" alt="Caretta  汐留 Illumination" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8610/16203842762_3a4695db7f.jpg 1x, https://farm9.staticflickr.com/8610/16203842762_3a4695db7f_b.jpg 2x" src-2="https://farm9.staticflickr.com/8610/16203842762_7936f95dd4_k.jpg 2x" /></a></p>

<p>這裡其實還可以排隊去照相，幾乎都是情侶，然後表演很頻繁，大概 15 分一次，在表演間的空檔才輪流拍照，另外也可以去走走道，穿過燈光的隧道，也是表演間的空檔一次開放一批人。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16202775001/" title="Caretta  汐留 Illumination by othree, on Flickr"><img src="https://farm9.staticflickr.com/8658/16202775001_c0d468fa97_b.jpg" width="1024" height="683" alt="Caretta  汐留 Illumination" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8658/16202775001_c0d468fa97.jpg 1x, https://farm9.staticflickr.com/8658/16202775001_c0d468fa97_b.jpg 2x" src-2="https://farm9.staticflickr.com/8658/16202775001_27ff2a51e5_k.jpg 2x" /></a></p>

<p>Caretta  汐留點燈晚上很漂亮，不過白天經過的話，就會夢想破滅了～～</p>

<p>迪士尼樂園裡面也有很大的聖誕樹。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16049979098/" title="Tokyo Disney Resort by othree, on Flickr"><img src="https://farm8.staticflickr.com/7564/16049979098_b79bdbaed1_b.jpg" width="1024" height="683" alt="Tokyo Disney Resort" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7564/16049979098_b79bdbaed1.jpg 1x, https://farm8.staticflickr.com/7564/16049979098_b79bdbaed1_b.jpg 2x" src-2="https://farm8.staticflickr.com/7564/16049979098_9937dee4dc_k.jpg 2x" /></a></p>

<p>最後一天到銀座也看到一些特別的裝飾，像是 BVLGARI 的蛇。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16077055787/" title="BVLGARI 銀座 by othree, on Flickr"><img src="https://farm8.staticflickr.com/7527/16077055787_c339145a3e_b.jpg" width="683" height="1024" alt="BVLGARI 銀座" src-1="(max-width: 768px)  https://farm8.staticflickr.com/7527/16077055787_c339145a3e.jpg 1x, https://farm8.staticflickr.com/7527/16077055787_c339145a3e_b.jpg 2x" src-2="https://farm8.staticflickr.com/7527/16077055787_f3bc2b7aae_k.jpg 2x" /></a></p>

<p>還有其中一條小路的路燈。</p>

<p><a class="thumbnail" href="https://www.flickr.com/photos/othree/16261121991/" title="Ginza by othree, on Flickr"><img src="https://farm9.staticflickr.com/8572/16261121991_eef742a898_b.jpg" width="1024" height="683" alt="Ginza" src-1="(max-width: 768px)  https://farm9.staticflickr.com/8572/16261121991_eef742a898.jpg 1x, https://farm9.staticflickr.com/8572/16261121991_eef742a898_b.jpg 2x" src-2="https://farm9.staticflickr.com/8572/16261121991_4da229e19b_k.jpg 2x" /></a></p>

<p>以上就是這趟看到的聖誕燈飾了，有一些聖誕節過後就沒有了，有一些會維持到新年過後，所以如果瞄準這個來看的話還是要聖誕節前就到，數量真的是很多，日本好浪費電的啊～～</p>
</b:extendContent>
			</b:content>


		</b:entry>

	</b:entries>
</b:blog>
